// [Lists, Lists, Lists, Console, Console, Console, Files, Files, Files, Characters, Characters, Characters, Strings, Strings, Strings, Actual, Actual, Actual, Namespace, Namespace, Namespace, Collector, Collector, Collector, EmptyHead, EmptyHead, EmptyHead, FlatMapHead, FlatMapHead, FlatMapHead, Head, Head, Head, HeadedQuery, HeadedQuery, HeadedQuery, MapHead, MapHead, MapHead, RangeHead, RangeHead, RangeHead, SingleHead, SingleHead, SingleHead, ZipHead, ZipHead, ZipHead, Joiner, Joiner]
import magma.api.option.{ Option, None, Some };
import magma.api.collect.{ Collector };
import magma.api.collect.list.{ List };
export struct Joiner implements Collector<&[I8], Option<&[I8]>> {
	mut delimiter: &[I8];
	constructor (mut delimiter: &[I8]) {
		this.delimiter = delimiter;
	}
	static def empty(): Joiner {
		return Joiner("");
	}
	static def joinOrEmpty(items: List<&[I8]>, delimiter: &[I8], prefix: &[I8], suffix: &[I8]): &[I8] {
		return items/*List<&[I8]>*/.query(/*auto*/).collect(Joiner(delimiter/*&[I8]*/)).map((mut inner: &[I8]) => prefix/*&[I8]*/ + inner/*auto*/ + suffix/*&[I8]*/).orElse("");
	}
	def createInitial(): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def fold(maybe: Option<&[I8]>, element: &[I8]): Option<&[I8]> {
		return Some<&[I8]>(maybe/*Option<&[I8]>*/.map((mut inner: &[I8]) => inner/*auto*/ + this/*auto*/.delimiter + element/*&[I8]*/).orElse(element/*&[I8]*/));
	}
}
