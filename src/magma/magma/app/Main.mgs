import jvm.api.io.Files;
import magma.api.io.Path;
import magma.api.collect.list.List;
import magma.api.io.IOError;
import magma.api.option.Some;
import jvm.api.io.Console;
import magma.api.option.Option;
import magma.app.io.Source;
import magma.api.collect.list.ListCollector;
import magma.app.compile.ImmutableCompileState;
import magma.app.compile.CompileState;
import magma.api.Tuple2;
import magma.api.Tuple2Impl;
import magma.api.option.None;
import magma.app.io.Platform;
import magma.app.io.Location;
import jvm.api.collect.list.Lists;
import magma.api.collect.Queries;
import magma.app.compile.Import;
import magma.api.collect.Joiner;
import jvm.api.text.Strings;
import magma.app.compile.text.DivideState;
import magma.api.Type;
import magma.app.compile.define.Parameter;
import magma.app.compile.define.Definition;
import magma.app.compile.value.ConstructorHeader;
import magma.app.compile.define.FunctionHeader;
import magma.app.compile.FunctionSegment;
import magma.app.compile.value.Value;
import magma.app.compile.value.ConstructionCaller;
import magma.app.compile.value.Caller;
import magma.app.compile.value.Argument;
import magma.app.compile.value.InvokableNode;
import magma.app.compile.value.StringNode;
import magma.app.compile.value.NotNode;
import magma.app.compile.value.LambdaNode;
import magma.app.compile.type.PrimitiveType;
import magma.app.compile.value.SymbolNode;
import magma.app.compile.value.AccessNode;
import magma.app.compile.value.OperationNode;
import magma.api.collect.head.HeadedQuery;
import magma.api.collect.head.RangeHead;
import jvm.api.text.Characters;
import magma.app.compile.text.Whitespace;
import magma.app.compile.text.Placeholder;
import magma.app.compile.type.ArrayType;
import magma.app.compile.type.VariadicType;
import magma.app.compile.type.SliceType;
import magma.app.compile.type.BooleanType;
import magma.app.compile.type.TemplateType;
import magma.app.compile.type.FunctionType;
export struct Main {
	static def main(): void {
		let sourceDirectory: Path = Files/*auto*/.get(".", "src", "java");
		sourceDirectory/*auto*/.walk(/*auto*/).match((mut children: List<Path>) => Main/*auto*/.runWithChildren(children/*auto*/, sourceDirectory/*auto*/), (mut value: IOError) => Some<IOError>(value/*auto*/)).map((mut error: IOError) => error/*auto*/.display(/*auto*/)).ifPresent((mut displayed: &[I8]) => Console/*auto*/.printErrLn(displayed/*auto*/));
	}
	static def runWithChildren(children: List<Path>, sourceDirectory: Path): Option<IOError> {
		let sources: List<Source> = children/*auto*/.query(/*auto*/).filter((mut source: Path) => source/*auto*/.endsWith(".java")).map((mut child: Path) => Source(sourceDirectory/*auto*/, child/*auto*/)).collect(ListCollector<Source>(/*auto*/));
		let initial: CompileState = sources/*auto*/.query(/*auto*/).foldWithInitial(ImmutableCompileState/*auto*/.createInitial(/*auto*/), (mut state: CompileState, mut source: Source) => state/*auto*/.addSource(source/*auto*/));
		return sources/*auto*/.query(/*auto*/).foldWithInitial(Main/*auto*/.createInitialState(initial/*auto*/), (mut current: Tuple2<CompileState, Option<IOError>>, mut source1: Source) => Main/*auto*/.foldChild(current/*auto*/.left(/*auto*/), current/*auto*/.right(/*auto*/), source1/*auto*/)).right(/*auto*/);
	}
	static def createInitialState(state: CompileState): Tuple2<CompileState, Option<IOError>> {
		return Tuple2Impl<CompileState, Option<IOError>>(state/*auto*/, None<IOError>(/*auto*/));
	}
	static def foldChild(state: CompileState, maybeError: Option<IOError>, source: Source): Tuple2<CompileState, Option<IOError>> {
		if (maybeError/*auto*/.isPresent(/*auto*/)) {
			return Tuple2Impl<CompileState, Option<IOError>>(state/*auto*/, maybeError/*auto*/);
		}
		return Main/*auto*/.runWithSource(state/*auto*/, source/*auto*/);
	}
	static def runWithSource(state: CompileState, source: Source): Tuple2<CompileState, Option<IOError>> {
		return source/*auto*/.read(/*auto*/).match((mut input: &[I8]) => Main/*auto*/.getCompileStateOptionTuple2(state/*auto*/, source/*auto*/, input/*auto*/), (mut value: IOError) => Tuple2Impl<CompileState, Option<IOError>>(state/*auto*/, Some<IOError>(value/*auto*/)));
	}
	static def getCompileStateOptionTuple2(state: CompileState, source: Source, input: &[I8]): Tuple2Impl<CompileState, Option<IOError>> {
		let typeScriptTuple: Tuple2<CompileState, Option<IOError>> = Main/*auto*/.compileAndWrite(state/*auto*/, source/*auto*/, input/*auto*/, Platform/*auto*/.TypeScript);
		let magmaTuple: Tuple2<CompileState, Option<IOError>> = Main/*auto*/.compileAndWrite(typeScriptTuple/*auto*/.left(/*auto*/), source/*auto*/, input/*auto*/, Platform/*auto*/.Magma);
		let windowsTuple: Tuple2<CompileState, Option<IOError>> = Main/*auto*/.compileAndWrite(magmaTuple/*auto*/.left(/*auto*/), source/*auto*/, input/*auto*/, Platform/*auto*/.Windows);
		return Tuple2Impl<CompileState, Option<IOError>>(windowsTuple/*auto*/.left(/*auto*/), typeScriptTuple/*auto*/.right(/*auto*/).or(() => magmaTuple/*auto*/.right(/*auto*/)).or(() => windowsTuple/*auto*/.right(/*auto*/)));
	}
	static def compileAndWrite(state: CompileState, source: Source, input: &[I8], platform: Platform): Tuple2<CompileState, Option<IOError>> {
		let state1: CompileState = state/*auto*/.withLocation(source/*auto*/.computeLocation(/*auto*/)).withPlatform(platform/*auto*/);
		let output: Tuple2Impl<CompileState, Map<&[I8], &[I8]>> = Main/*auto*/.compileRoot(state1/*auto*/, source/*auto*/, input/*auto*/);
		let location: Location = output/*auto*/.left(/*auto*/).findCurrentLocation(/*auto*/).orElse(Location(Lists/*auto*/.empty(/*auto*/), ""));
		let targetDirectory: Path = Files/*auto*/.get(".", "src", platform/*auto*/.root);
		let targetParent: Path = targetDirectory/*auto*/.resolveChildSegments(location/*auto*/.namespace(/*auto*/));
		if (!targetParent/*auto*/.exists(/*auto*/)) {
			let maybeError: Option<IOError> = targetParent/*auto*/.createDirectories(/*auto*/);
			if (maybeError/*auto*/.isPresent(/*auto*/)) {
				return Tuple2Impl<CompileState, Option<IOError>>(output/*auto*/.left(/*auto*/), maybeError/*auto*/);
			}
		}
		let initial: Option<IOError> = None<IOError>(/*auto*/);
		let ioErrorOption1: Option<IOError> = Queries/*auto*/.fromArray(platform/*auto*/.extension).foldWithInitial(initial/*auto*/, (ioErrorOption: Option<IOError>, extension: &[I8]) => {
			let target: Path = targetParent/*auto*/.resolveChild(location/*auto*/.name(/*auto*/) + "." + extension/*auto*/);
			return ioErrorOption/*auto*/.or(() => target/*auto*/.writeString(output/*auto*/.right(/*auto*/).get(extension/*auto*/)));
		});
		return Tuple2Impl<CompileState, Option<IOError>>(output/*auto*/.left(/*auto*/), ioErrorOption1/*auto*/);
	}
	static def compileRoot(state: CompileState, source: Source, input: &[I8]): Tuple2Impl<CompileState, Map<&[I8], &[I8]>> {
		let statementsTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileStatements(state/*auto*/, input/*auto*/, Main/*auto*/.compileRootSegment);
		let statementsState: CompileState = statementsTuple/*auto*/.left(/*auto*/);
		let imports: &[I8] = statementsState/*auto*/.imports(/*auto*/).query(/*auto*/).map((mut anImport: Import) => anImport/*auto*/.generate(state/*auto*/.platform(/*auto*/))).collect(Joiner("")).orElse("");
		let compileState: CompileState = statementsState/*auto*/.clearImports(/*auto*/).clear(/*auto*/);
		let withMain: &[I8] = Main/*auto*/.createMain(source/*auto*/);
		let entries: HashMap<&[I8], &[I8]> = HashMap<&[I8], &[I8]>(/*auto*/);
		let platform: Platform = state/*auto*/.platform(/*auto*/);
		if (Platform/*auto*/.Windows === platform/*auto*/) {
			let value: &[I8] = /* source.computeNamespace().query().collect(new Joiner("_")).map((String inner) -> inner + "_").orElse("") + source.computeName()*/;
			/*entries.put(Platform.Windows.extension[0], Main.generateDirective("ifndef " + value) + Main.generateDirective("define " + value) + imports + Main.generateDirective("endif"))*/;
			/*entries.put(Platform.Windows.extension[1], Main.generateDirective("include \"./" + source.computeName() + ".h\"") + statementsState.join() + statementsTuple.right() + withMain)*/;
		}
		else {
			/*entries.put(platform.extension[0], imports + statementsState.join() + statementsTuple.right() + withMain)*/;
		}
		return Tuple2Impl<>(compileState/*auto*/, entries/*auto*/);
	}
	static def generateDirective(content: &[I8]): &[I8] {
		return "#" + content/*auto*/ + "\n";
	}
	static def createMain(source: Source): &[I8] {
		if (Strings/*auto*/.equalsTo(source/*auto*/.computeName(/*auto*/), "Main")) {
			return "Main.main();";
		}
		return "";
	}
	static def compileStatements(state: CompileState, input: &[I8], mapper: (arg0 : CompileState, arg1 : &[I8]) => Tuple2<CompileState, &[I8]>): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileAll(state/*auto*/, input/*auto*/, Main/*auto*/.foldStatements, mapper/*auto*/, Main/*auto*/.mergeStatements);
	}
	static def compileAll(state: CompileState, input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState, mapper: (arg0 : CompileState, arg1 : &[I8]) => Tuple2<CompileState, &[I8]>, merger: (arg0 : &[I8], arg1 : &[I8]) => &[I8]): Tuple2<CompileState, &[I8]> {
		let folded: Tuple2<CompileState, List<&[I8]>> = Main/*auto*/.parseAll(state/*auto*/, input/*auto*/, folder/*auto*/, (mut state1: CompileState, mut s: &[I8]) => Some<Tuple2<CompileState, &[I8]>>(mapper/*auto*/(state1/*auto*/, s/*auto*/))).orElse(Tuple2Impl<CompileState, List<&[I8]>>(state/*auto*/, Lists/*auto*/.empty(/*auto*/)));
		return Tuple2Impl<CompileState, &[I8]>(folded/*auto*/.left(/*auto*/), Main/*auto*/.generateAll(folded/*auto*/.right(/*auto*/), merger/*auto*/));
	}
	static def generateAll(elements: List<&[I8]>, merger: (arg0 : &[I8], arg1 : &[I8]) => &[I8]): &[I8] {
		return elements/*auto*/.query(/*auto*/).foldWithInitial("", merger/*auto*/);
	}
	static def parseAll<T>(state: CompileState, input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState, biFunction: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, List<T>>> {
		return Main/*auto*/.divide(input/*auto*/, folder/*auto*/).query(/*auto*/).foldWithInitial(Some<Tuple2<CompileState, List<T>>>(Tuple2Impl<CompileState, List<T>>(state/*auto*/, Lists/*auto*/.empty(/*auto*/))), (maybeCurrent: Option<Tuple2<CompileState, List<T>>>, segment: &[I8]) => maybeCurrent/*auto*/.flatMap((current: Tuple2<CompileState, List<T>>) => {
			let currentState: CompileState = current/*auto*/.left(/*auto*/);
			let currentElement: List<T> = current/*auto*/.right(/*auto*/);
			return biFunction/*auto*/(currentState/*auto*/, segment/*auto*/).map((mappedTuple: Tuple2<CompileState, T>) => {
				let mappedState: CompileState = mappedTuple/*auto*/.left(/*auto*/);
				let mappedElement: T = mappedTuple/*auto*/.right(/*auto*/);
				return Tuple2Impl<CompileState, List<T>>(mappedState/*auto*/, currentElement/*auto*/.addLast(mappedElement/*auto*/));
			});
		}));
	}
	static def mergeStatements(cache: &[I8], element: &[I8]): &[I8] {
		return cache/*auto*/ + element/*auto*/;
	}
	static def divide(input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState): List<&[I8]> {
		mut let current: DivideState = DivideState/*auto*/.createInitial(input/*auto*/);
		while (true/*auto*/) {
			let poppedTuple0: Tuple2<Bool, Tuple2<DivideState, I8>> = current/*auto*/.pop(/*auto*/).toTuple(Tuple2Impl<DivideState, I8>(current/*auto*/, "\0"));
			if (!poppedTuple0/*auto*/.left(/*auto*/)) {
				break;
			}
			let poppedTuple: Tuple2<DivideState, I8> = poppedTuple0/*auto*/.right(/*auto*/);
			let poppedState: DivideState = poppedTuple/*auto*/.left(/*auto*/);
			let popped: I8 = poppedTuple/*auto*/.right(/*auto*/);
			current/*auto*/ = Main/*auto*/.foldSingleQuotes(poppedState/*auto*/, popped/*auto*/).or(() => Main/*auto*/.foldDoubleQuotes(poppedState/*auto*/, popped/*auto*/)).orElseGet(() => folder/*auto*/(poppedState/*auto*/, popped/*auto*/));
		}
		return current/*auto*/.advance(/*auto*/).segments(/*auto*/);
	}
	static def foldDoubleQuotes(state: DivideState, c: I8): Option<DivideState> {
		if ("\"" !== c/*auto*/) {
			return None<DivideState>(/*auto*/);
		}
		mut let appended: DivideState = state/*auto*/.append(c/*auto*/);
		while (true/*auto*/) {
			let maybeTuple: Tuple2<Bool, Tuple2<DivideState, I8>> = appended/*auto*/.popAndAppendToTuple(/*auto*/).toTuple(Tuple2Impl<DivideState, I8>(appended/*auto*/, "\0"));
			if (!maybeTuple/*auto*/.left(/*auto*/)) {
				break;
			}
			let tuple: Tuple2<DivideState, I8> = maybeTuple/*auto*/.right(/*auto*/);
			appended/*auto*/ = tuple/*auto*/.left(/*auto*/);
			if ("\\" === tuple/*auto*/.right(/*auto*/)) {
				appended/*auto*/ = appended/*auto*/.popAndAppendToOption(/*auto*/).orElse(appended/*auto*/);
			}
			if ("\"" === tuple/*auto*/.right(/*auto*/)) {
				break;
			}
		}
		return Some<DivideState>(appended/*auto*/);
	}
	static def foldSingleQuotes(state: DivideState, c: I8): Option<DivideState> {
		if ("\'" !== c/*auto*/) {
			return None<DivideState>(/*auto*/);
		}
		return state/*auto*/.append(c/*auto*/).popAndAppendToTuple(/*auto*/).flatMap(Main/*auto*/.foldEscaped).flatMap((mut state1: DivideState) => state1/*auto*/.popAndAppendToOption(/*auto*/));
	}
	static def foldEscaped(tuple: Tuple2<DivideState, I8>): Option<DivideState> {
		let state: DivideState = tuple/*auto*/.left(/*auto*/);
		let c: I8 = tuple/*auto*/.right(/*auto*/);
		if ("\\" === c/*auto*/) {
			return state/*auto*/.popAndAppendToOption(/*auto*/);
		}
		return Some<DivideState>(state/*auto*/);
	}
	static def foldStatements(state: DivideState, c: I8): DivideState {
		let appended: DivideState = state/*auto*/.append(c/*auto*/);
		if (";" === c/*auto*/ && appended/*auto*/.isLevel(/*auto*/)) {
			return appended/*auto*/.advance(/*auto*/);
		}
		if ("}" === c/*auto*/ && appended/*auto*/.isShallow(/*auto*/)) {
			return appended/*auto*/.advance(/*auto*/).exit(/*auto*/);
		}
		if ("{" === c/*auto*/ || "(" === c/*auto*/) {
			return appended/*auto*/.enter(/*auto*/);
		}
		if ("}" === c/*auto*/ || ")" === c/*auto*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def compileRootSegment(state: CompileState, input: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileOrPlaceholder(state/*auto*/, input/*auto*/, Lists/*auto*/.of(Main/*auto*/.compileWhitespace, Main/*auto*/.compileNamespaced, Main/*auto*/.createStructureRule("class ", "class "), Main/*auto*/.createStructureRule("interface ", "interface "), Main/*auto*/.createStructureRule("record ", "class "), Main/*auto*/.createStructureRule("enum ", "class ")));
	}
	static def createStructureRule(sourceInfix: &[I8], targetInfix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>> {
		return (state: CompileState, input1: &[I8]) => Main/*auto*/.compileFirst(input1/*auto*/, sourceInfix/*auto*/, (beforeInfix: &[I8], afterInfix: &[I8]) => Main/*auto*/.compileFirst(afterInfix/*auto*/, "{", (beforeContent: &[I8], withEnd: &[I8]) => Main/*auto*/.compileSuffix(Strings/*auto*/.strip(withEnd/*auto*/), "}", (inputContent: &[I8]) => Main/*auto*/.compileLast(beforeInfix/*auto*/, "\n", (s: &[I8], s2: &[I8]) => {
			let annotations: List<&[I8]> = Main/*auto*/.parseAnnotations(s/*auto*/);
			if (annotations/*auto*/.contains("Actual", Strings/*auto*/.equalsTo)) {
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*auto*/, ""));
			}
			return Main/*auto*/.compileStructureWithImplementing(state/*auto*/, annotations/*auto*/, Main/*auto*/.parseModifiers(s2/*auto*/), targetInfix/*auto*/, beforeContent/*auto*/, inputContent/*auto*/);
		}).or(() => {
			let modifiers: List<&[I8]> = Main/*auto*/.parseModifiers(beforeContent/*auto*/);
			return Main/*auto*/.compileStructureWithImplementing(state/*auto*/, Lists/*auto*/.empty(/*auto*/), modifiers/*auto*/, targetInfix/*auto*/, beforeContent/*auto*/, inputContent/*auto*/);
		}))));
	}
	static def compileStructureWithImplementing(state: CompileState, annotations: List<&[I8]>, modifiers: List<&[I8]>, targetInfix: &[I8], beforeContent: &[I8], content: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileLast(beforeContent/*auto*/, " implements ", (s: &[I8], s2: &[I8]) => Main/*auto*/.parseType(state/*auto*/, s2/*auto*/).flatMap((implementingTuple: Tuple2<CompileState, Type>) => Main/*auto*/.compileStructureWithExtends(implementingTuple/*auto*/.left(/*auto*/), annotations/*auto*/, modifiers/*auto*/, targetInfix/*auto*/, s/*auto*/, Some<Type>(implementingTuple/*auto*/.right(/*auto*/)), content/*auto*/))).or(() => Main/*auto*/.compileStructureWithExtends(state/*auto*/, annotations/*auto*/, modifiers/*auto*/, targetInfix/*auto*/, beforeContent/*auto*/, None<Type>(/*auto*/), content/*auto*/));
	}
	static def compileStructureWithExtends(state: CompileState, annotations: List<&[I8]>, modifiers: List<&[I8]>, targetInfix: &[I8], beforeContent: &[I8], maybeImplementing: Option<Type>, inputContent: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(beforeContent/*auto*/, " extends ", (mut beforeExtends: &[I8], mut afterExtends: &[I8]) => Main/*auto*/.compileStructureWithParameters(state/*auto*/, annotations/*auto*/, modifiers/*auto*/, targetInfix/*auto*/, beforeExtends/*auto*/, Some<&[I8]>(afterExtends/*auto*/), maybeImplementing/*auto*/, inputContent/*auto*/)).or(() => Main/*auto*/.compileStructureWithParameters(state/*auto*/, annotations/*auto*/, modifiers/*auto*/, targetInfix/*auto*/, beforeContent/*auto*/, None<&[I8]>(/*auto*/), maybeImplementing/*auto*/, inputContent/*auto*/));
	}
	static def compileStructureWithParameters(state: CompileState, annotations: List<&[I8]>, modifiers: List<&[I8]>, targetInfix: &[I8], beforeContent: &[I8], maybeSuperType: Option<&[I8]>, maybeImplementing: Option<Type>, inputContent: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(beforeContent/*auto*/, "(", (rawName: &[I8], withParameters: &[I8]) => Main/*auto*/.compileFirst(withParameters/*auto*/, ")", (parametersString: &[I8], _: &[I8]) => {
			let name: &[I8] = Strings/*auto*/.strip(rawName/*auto*/);
			let parametersTuple: Tuple2<CompileState, List<Parameter>> = Main/*auto*/.parseParameters(state/*auto*/, parametersString/*auto*/);
			let parameters: List<Definition> = Main/*auto*/.retainDefinitionsFromParameters(parametersTuple/*auto*/.right(/*auto*/));
			return Main/*auto*/.compileStructureWithTypeParams(parametersTuple/*auto*/.left(/*auto*/), targetInfix/*auto*/, inputContent/*auto*/, name/*auto*/, parameters/*auto*/, maybeImplementing/*auto*/, annotations/*auto*/, modifiers/*auto*/, maybeSuperType/*auto*/);
		})).or(() => Main/*auto*/.compileStructureWithTypeParams(state/*auto*/, targetInfix/*auto*/, inputContent/*auto*/, beforeContent/*auto*/, Lists/*auto*/.empty(/*auto*/), maybeImplementing/*auto*/, annotations/*auto*/, modifiers/*auto*/, maybeSuperType/*auto*/));
	}
	static def retainDefinitionsFromParameters(parameters: List<Parameter>): List<Definition> {
		return parameters/*auto*/.query(/*auto*/).map((mut parameter: Parameter) => parameter/*auto*/.asDefinition(/*auto*/)).flatMap(Queries/*auto*/.fromOption).collect(ListCollector<Definition>(/*auto*/));
	}
	static def compileStructureWithTypeParams(state: CompileState, infix: &[I8], content: &[I8], beforeParams: &[I8], parameters: List<Definition>, maybeImplementing: Option<Type>, annotations: List<&[I8]>, modifiers: List<&[I8]>, maybeSuperType: Option<&[I8]>): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(beforeParams/*auto*/), ">", (withoutTypeParamEnd: &[I8]) => Main/*auto*/.compileFirst(withoutTypeParamEnd/*auto*/, "<", (name: &[I8], typeParamsString: &[I8]) => {
			let typeParams: List<&[I8]> = Main/*auto*/.divideValues(typeParamsString/*auto*/);
			return Main/*auto*/.assembleStructure(state/*auto*/, annotations/*auto*/, modifiers/*auto*/, infix/*auto*/, name/*auto*/, typeParams/*auto*/, parameters/*auto*/, maybeImplementing/*auto*/, content/*auto*/, maybeSuperType/*auto*/);
		})).or(() => Main/*auto*/.assembleStructure(state/*auto*/, annotations/*auto*/, modifiers/*auto*/, infix/*auto*/, beforeParams/*auto*/, Lists/*auto*/.empty(/*auto*/), parameters/*auto*/, maybeImplementing/*auto*/, content/*auto*/, maybeSuperType/*auto*/));
	}
	static def assembleStructure(state: CompileState, annotations: List<&[I8]>, oldModifiers: List<&[I8]>, infix: &[I8], rawName: &[I8], typeParams: List<&[I8]>, parameters: List<Definition>, maybeImplementing: Option<Type>, content: &[I8], maybeSuperType: Option<&[I8]>): Option<Tuple2<CompileState, &[I8]>> {
		let name: &[I8] = Strings/*auto*/.strip(rawName/*auto*/);
		if (!Main/*auto*/.isSymbol(name/*auto*/)) {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
		let outputContentTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileStatements(state/*auto*/.pushStructureName(name/*auto*/), content/*auto*/, Main/*auto*/.compileClassSegment);
		let outputContentState: CompileState = outputContentTuple/*auto*/.left(/*auto*/).popStructureName(/*auto*/);
		let outputContent: &[I8] = outputContentTuple/*auto*/.right(/*auto*/);
		let platform: Platform = outputContentState/*auto*/.platform(/*auto*/);
		let constructorString: &[I8] = Main/*auto*/.generateConstructorFromRecordParameters(parameters/*auto*/, platform/*auto*/);
		let joinedTypeParams: &[I8] = Joiner/*auto*/.joinOrEmpty(typeParams/*auto*/, ", ", "<", ">");
		let implementingString: &[I8] = Main/*auto*/.generateImplementing(maybeImplementing/*auto*/);
		let newModifiers: List<&[I8]> = Main/*auto*/.modifyModifiers0(oldModifiers/*auto*/);
		let joinedModifiers: &[I8] = newModifiers/*auto*/.query(/*auto*/).map((mut value: &[I8]) => value/*auto*/ + " ").collect(Joiner/*auto*/.empty(/*auto*/)).orElse("");
		if (annotations/*auto*/.contains("Namespace", Strings/*auto*/.equalsTo)) {
			let actualInfix: &[I8] = "interface ";
			let newName: &[I8] = name/*auto*/ + "Instance";
			let generated: &[I8] = joinedModifiers/*auto*/ + actualInfix/*auto*/ + newName/*auto*/ + joinedTypeParams/*auto*/ + implementingString/*auto*/ + " {" + Main/*auto*/.joinParameters(parameters/*auto*/, platform/*auto*/) + constructorString/*auto*/ + outputContent/*auto*/ + "\n}\n";
			let withNewLocation: CompileState = outputContentState/*auto*/.append(generated/*auto*/).mapLocation((mut location: Location) => Location(location/*auto*/.namespace(/*auto*/), location/*auto*/.name(/*auto*/) + "Instance"));
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(withNewLocation/*auto*/, ""));
		}
		else {
			let extendsString: &[I8] = maybeSuperType/*auto*/.map((mut inner: &[I8]) => " extends " + inner/*auto*/).orElse("");
			let infix1: &[I8] = Main/*auto*/.retainStruct(infix/*auto*/, outputContentState/*auto*/);
			let generated: &[I8] = joinedModifiers/*auto*/ + infix1/*auto*/ + name/*auto*/ + joinedTypeParams/*auto*/ + extendsString/*auto*/ + implementingString/*auto*/ + " {" + Main/*auto*/.joinParameters(parameters/*auto*/, platform/*auto*/) + constructorString/*auto*/ + outputContent/*auto*/ + "\n}\n";
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(outputContentState/*auto*/.append(generated/*auto*/), ""));
		}
	}
	static def retainStruct(infix: &[I8], outputContentState: CompileState): &[I8] {
		if (outputContentState/*auto*/.isPlatform(Platform/*auto*/.Magma)) {
			return "struct ";
		}
		return infix/*auto*/;
	}
	static def modifyModifiers0(oldModifiers: List<&[I8]>): List<&[I8]> {
		if (oldModifiers/*auto*/.contains("public", Strings/*auto*/.equalsTo)) {
			return Lists/*auto*/.of("export");
		}
		return Lists/*auto*/.empty(/*auto*/);
	}
	static def generateImplementing(maybeImplementing: Option<Type>): &[I8] {
		return maybeImplementing/*auto*/.map((mut type: Type) => type/*auto*/.generate(/*auto*/)).map((mut inner: &[I8]) => " implements " + inner/*auto*/).orElse("");
	}
	static def generateConstructorFromRecordParameters(parameters: List<Definition>, platform: Platform): &[I8] {
		return parameters/*auto*/.query(/*auto*/).map((mut definition: Definition) => definition/*auto*/.generate(platform/*auto*/)).collect(Joiner(", ")).map((mut generatedParameters: &[I8]) => Main/*auto*/.generateConstructorWithParameterString(parameters/*auto*/, generatedParameters/*auto*/)).orElse("");
	}
	static def generateConstructorWithParameterString(parameters: List<Definition>, parametersString: &[I8]): &[I8] {
		let constructorAssignments: &[I8] = Main/*auto*/.generateConstructorAssignments(parameters/*auto*/);
		return "\n\tconstructor (" + parametersString/*auto*/ + ") {" + constructorAssignments/*auto*/ + "\n\t}";
	}
	static def generateConstructorAssignments(parameters: List<Definition>): &[I8] {
		return parameters/*auto*/.query(/*auto*/).map((mut definition: Definition) => "\n\t\tthis." + definition/*auto*/.name(/*auto*/) + " = " + definition/*auto*/.name(/*auto*/) + ";").collect(Joiner/*auto*/.empty(/*auto*/)).orElse("");
	}
	static def joinParameters(parameters: List<Definition>, platform: Platform): &[I8] {
		return parameters/*auto*/.query(/*auto*/).map((mut definition: Definition) => definition/*auto*/.generate(platform/*auto*/)).map((mut generated: &[I8]) => "\n\t" + generated/*auto*/ + ";").collect(Joiner/*auto*/.empty(/*auto*/)).orElse("");
	}
	static def compileNamespaced(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		let stripped: &[I8] = Strings/*auto*/.strip(input/*auto*/);
		if (stripped/*auto*/.startsWith("package ") || stripped/*auto*/.startsWith("import ")) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*auto*/, ""));
		}
		return None<>(/*auto*/);
	}
	static def compileOrPlaceholder(state: CompileState, input: &[I8], rules: List<(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>>): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.or(state/*auto*/, input/*auto*/, rules/*auto*/).orElseGet(() => Tuple2Impl<CompileState, &[I8]>(state/*auto*/, Main/*auto*/.generatePlaceholder(input/*auto*/)));
	}
	static def or<T>(state: CompileState, input: &[I8], rules: List<(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>>): Option<Tuple2<CompileState, T>> {
		return rules/*auto*/.query(/*auto*/).map((mut rule: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>) => Main/*auto*/.getApply(state/*auto*/, input/*auto*/, rule/*auto*/)).flatMap(Queries/*auto*/.fromOption).next(/*auto*/);
	}
	static def getApply<T>(state: CompileState, input: &[I8], rule: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, T>> {
		return rule/*auto*/(state/*auto*/, input/*auto*/);
	}
	static def compileClassSegment(state1: CompileState, input1: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileOrPlaceholder(state1/*auto*/, input1/*auto*/, Lists/*auto*/.of(Main/*auto*/.compileWhitespace, Main/*auto*/.createStructureRule("class ", "class "), Main/*auto*/.createStructureRule("interface ", "interface "), Main/*auto*/.createStructureRule("record ", "class "), Main/*auto*/.createStructureRule("enum ", "class "), Main/*auto*/.compileMethod, Main/*auto*/.compileFieldDefinition));
	}
	static def compileMethod(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(input/*auto*/, "(", (beforeParams: &[I8], withParams: &[I8]) => {
			let strippedBeforeParams: &[I8] = Strings/*auto*/.strip(beforeParams/*auto*/);
			return Main/*auto*/.compileLast(strippedBeforeParams/*auto*/, " ", (_: &[I8], name: &[I8]) => {
				if (state/*auto*/.hasLastStructureNameOf(name/*auto*/)) {
					return Main/*auto*/.compileMethodWithBeforeParams(state/*auto*/, ConstructorHeader(/*auto*/), withParams/*auto*/);
				}
				return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
			}).or(() => {
				if (state/*auto*/.hasLastStructureNameOf(strippedBeforeParams/*auto*/)) {
					return Main/*auto*/.compileMethodWithBeforeParams(state/*auto*/, ConstructorHeader(/*auto*/), withParams/*auto*/);
				}
				return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
			}).or(() => Main/*auto*/.parseDefinition(state/*auto*/, beforeParams/*auto*/).flatMap((mut tuple: Tuple2<CompileState, Definition>) => Main/*auto*/.compileMethodWithBeforeParams(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/), withParams/*auto*/)));
		});
	}
	static def compileMethodWithBeforeParams<S extends FunctionHeader<S>>(state: CompileState, header: FunctionHeader<S>, withParams: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(withParams/*auto*/, ")", (params: &[I8], afterParams: &[I8]) => {
			let parametersTuple: Tuple2<CompileState, List<Parameter>> = Main/*auto*/.parseParameters(state/*auto*/, params/*auto*/);
			let parametersState: CompileState = parametersTuple/*auto*/.left(/*auto*/);
			let parameters: List<Parameter> = parametersTuple/*auto*/.right(/*auto*/);
			let definitions: List<Definition> = Main/*auto*/.retainDefinitionsFromParameters(parameters/*auto*/);
			let newHeader: FunctionHeader<S> = Main/*auto*/.retainDef(header/*auto*/, parametersState/*auto*/);
			if (newHeader/*auto*/.hasAnnotation("Actual")) {
				let aStatic: S = newHeader/*auto*/.removeModifier("static");
				let sFunctionSegment: FunctionSegment<S> = FunctionSegment<S>(newHeader/*auto*/, definitions/*auto*/, None<>(/*auto*/));
				let generate: &[I8] = sFunctionSegment/*auto*/.generate(parametersState/*auto*/.platform(/*auto*/), "\n\t");
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(parametersState/*auto*/, generate/*auto*/));
			}
			return Main/*auto*/.compilePrefix(Strings/*auto*/.strip(afterParams/*auto*/), "{", (withoutContentStart: &[I8]) => Main/*auto*/.compileSuffix(Strings/*auto*/.strip(withoutContentStart/*auto*/), "}", (withoutContentEnd: &[I8]) => {
				let compileState1: CompileState = parametersState/*auto*/.enterDepth(/*auto*/);
				let compileState: CompileState = /* compileState1.isPlatform(Platform.Windows) ? compileState1 : compileState1.enterDepth()*/;
				let statementsTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileFunctionStatements(compileState/*auto*/.defineAll(definitions/*auto*/), withoutContentEnd/*auto*/);
				let compileState2: CompileState = statementsTuple/*auto*/.left(/*auto*/).exitDepth(/*auto*/);
				let indent: &[I8] = compileState2/*auto*/.createIndent(/*auto*/);
				let exited: CompileState = /* compileState2.isPlatform(Platform.Windows) ? compileState2 : compileState2.exitDepth()*/;
				let sFunctionSegment: FunctionSegment<S> = FunctionSegment<S>(newHeader/*auto*/, definitions/*auto*/, Some<>(statementsTuple/*auto*/.right(/*auto*/)));
				let generated: &[I8] = sFunctionSegment/*auto*/.generate(parametersState/*auto*/.platform(/*auto*/), indent/*auto*/);
				if (exited/*auto*/.isPlatform(Platform/*auto*/.Windows)) {
					return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(exited/*auto*/.addFunction(generated/*auto*/), ""));
				}
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(exited/*auto*/, generated/*auto*/));
			})).or(() => {
				if (Strings/*auto*/.equalsTo(";", Strings/*auto*/.strip(afterParams/*auto*/))) {
					let sFunctionSegment: FunctionSegment<S> = FunctionSegment<S>(newHeader/*auto*/, definitions/*auto*/, None<>(/*auto*/));
					let generate: &[I8] = sFunctionSegment/*auto*/.generate(parametersState/*auto*/.platform(/*auto*/), "\n\t");
					return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(parametersState/*auto*/, generate/*auto*/));
				}
				return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
			});
		});
	}
	static def retainDef<S extends FunctionHeader<S>>(header: FunctionHeader<S>, parametersState: CompileState): FunctionHeader<S> {
		if (parametersState/*auto*/.isPlatform(Platform/*auto*/.Magma)) {
			return header/*auto*/.addModifierLast("def").removeModifier("mut");
		}
		return header/*auto*/;
	}
	static def parseParameters(state: CompileState, params: &[I8]): Tuple2<CompileState, List<Parameter>> {
		return Main/*auto*/.parseValuesOrEmpty(state/*auto*/, params/*auto*/, (mut state1: CompileState, mut s: &[I8]) => Some<Tuple2<CompileState, Parameter>>(Main/*auto*/.parseParameterOrPlaceholder(state1/*auto*/, s/*auto*/)));
	}
	static def compileFunctionStatements(state: CompileState, input: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileStatements(state/*auto*/, input/*auto*/, Main/*auto*/.compileFunctionSegment);
	}
	static def compileFunctionSegment(state: CompileState, input: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileOrPlaceholder(state/*auto*/, input/*auto*/, Lists/*auto*/.of(Main/*auto*/.compileWhitespace, Main/*auto*/.compileEmptySegment, Main/*auto*/.compileBlock, Main/*auto*/.compileFunctionStatement, Main/*auto*/.compileReturnWithoutSuffix));
	}
	static def compileEmptySegment(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		if (Strings/*auto*/.equalsTo(";", Strings/*auto*/.strip(input/*auto*/))) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*auto*/, ";"));
		}
		else {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
	}
	static def compileReturnWithoutSuffix(state1: CompileState, input1: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileReturn(input1/*auto*/, (mut withoutPrefix: &[I8]) => Main/*auto*/.compileValue(state1/*auto*/, withoutPrefix/*auto*/)).map((mut tuple: Tuple2<CompileState, &[I8]>) => Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), state1/*auto*/.createIndent(/*auto*/) + tuple/*auto*/.right(/*auto*/)));
	}
	static def compileBlock(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*auto*/), "}", (withoutEnd: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFoldedLast(withoutEnd/*auto*/, "", Main/*auto*/.foldBlockStarts), (beforeContentWithEnd: &[I8], content: &[I8]) => Main/*auto*/.compileSuffix(beforeContentWithEnd/*auto*/, "{", (beforeContent: &[I8]) => Main/*auto*/.compileBlockHeader(state/*auto*/, beforeContent/*auto*/).flatMap((headerTuple: Tuple2<CompileState, &[I8]>) => {
			let contentTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileFunctionStatements(headerTuple/*auto*/.left(/*auto*/).enterDepth(/*auto*/), content/*auto*/);
			let indent: &[I8] = state/*auto*/.createIndent(/*auto*/);
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(contentTuple/*auto*/.left(/*auto*/).exitDepth(/*auto*/), indent/*auto*/ + headerTuple/*auto*/.right(/*auto*/) + "{" + contentTuple/*auto*/.right(/*auto*/) + indent/*auto*/ + "}"));
		}))));
	}
	static def foldBlockStarts(state: DivideState, c: I8): DivideState {
		let appended: DivideState = state/*auto*/.append(c/*auto*/);
		if ("{" === c/*auto*/) {
			let entered: DivideState = appended/*auto*/.enter(/*auto*/);
			if (entered/*auto*/.isShallow(/*auto*/)) {
				return entered/*auto*/.advance(/*auto*/);
			}
			else {
				return entered/*auto*/;
			}
		}
		if ("}" === c/*auto*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def compileBlockHeader(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.or(state/*auto*/, input/*auto*/, Lists/*auto*/.of(Main/*auto*/.createConditionalRule("if"), Main/*auto*/.createConditionalRule("while"), Main/*auto*/.compileElse));
	}
	static def createConditionalRule(prefix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>> {
		return (mut state1: CompileState, mut input1: &[I8]) => Main/*auto*/.compilePrefix(Strings/*auto*/.strip(input1/*auto*/), prefix/*auto*/, (withoutPrefix: &[I8]) => {
			let strippedCondition: &[I8] = Strings/*auto*/.strip(withoutPrefix/*auto*/);
			return Main/*auto*/.compilePrefix(strippedCondition/*auto*/, "(", (withoutConditionStart: &[I8]) => Main/*auto*/.compileSuffix(withoutConditionStart/*auto*/, ")", (withoutConditionEnd: &[I8]) => {
				let tuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileValueOrPlaceholder(state1/*auto*/, withoutConditionEnd/*auto*/);
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), prefix/*auto*/ + " (" + tuple/*auto*/.right(/*auto*/) + ") "));
			}));
		});
	}
	static def compileElse(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		if (Strings/*auto*/.equalsTo("else", Strings/*auto*/.strip(input/*auto*/))) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*auto*/, "else "));
		}
		else {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
	}
	static def compileFunctionStatement(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*auto*/), ";", (withoutEnd: &[I8]) => {
			let valueTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileFunctionStatementValue(state/*auto*/, withoutEnd/*auto*/);
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(valueTuple/*auto*/.left(/*auto*/), state/*auto*/.createIndent(/*auto*/) + valueTuple/*auto*/.right(/*auto*/) + ";"));
		});
	}
	static def compileFunctionStatementValue(state: CompileState, withoutEnd: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileOrPlaceholder(state/*auto*/, withoutEnd/*auto*/, Lists/*auto*/.of(Main/*auto*/.compileReturnWithValue, Main/*auto*/.compileAssignment, (mut state1: CompileState, mut input: &[I8]) => Main/*auto*/.parseInvokable(state1/*auto*/, input/*auto*/).map((mut tuple: Tuple2<CompileState, Value>) => Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/).generate(tuple/*auto*/.left(/*auto*/).platform(/*auto*/)))), Main/*auto*/.createPostRule("++"), Main/*auto*/.createPostRule("--"), Main/*auto*/.compileBreak));
	}
	static def compileBreak(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		if (Strings/*auto*/.equalsTo("break", Strings/*auto*/.strip(input/*auto*/))) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*auto*/, "break"));
		}
		else {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
	}
	static def createPostRule(suffix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>> {
		return (mut state1: CompileState, mut input: &[I8]) => Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*auto*/), suffix/*auto*/, (child: &[I8]) => {
			let tuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileValueOrPlaceholder(state1/*auto*/, child/*auto*/);
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/) + suffix/*auto*/));
		});
	}
	static def compileReturnWithValue(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileReturn(input/*auto*/, (mut value1: &[I8]) => Main/*auto*/.compileValue(state/*auto*/, value1/*auto*/));
	}
	static def compileReturn(input: &[I8], mapper: (arg0 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compilePrefix(Strings/*auto*/.strip(input/*auto*/), "return ", (value: &[I8]) => mapper/*auto*/(value/*auto*/).flatMap((tuple: Tuple2<CompileState, &[I8]>) => Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), "return " + tuple/*auto*/.right(/*auto*/)))));
	}
	static def parseInvokable(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*auto*/), ")", (withoutEnd: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFoldedLast(withoutEnd/*auto*/, "", Main/*auto*/.foldInvocationStarts), (callerWithArgStart: &[I8], args: &[I8]) => Main/*auto*/.compileSuffix(callerWithArgStart/*auto*/, "(", (callerString: &[I8]) => Main/*auto*/.compilePrefix(Strings/*auto*/.strip(callerString/*auto*/), "new ", (type: &[I8]) => Main/*auto*/.compileType(state/*auto*/, type/*auto*/).flatMap((callerTuple: Tuple2<CompileState, &[I8]>) => {
			let callerState: CompileState = callerTuple/*auto*/.left(/*auto*/);
			let caller: &[I8] = callerTuple/*auto*/.right(/*auto*/);
			return Main/*auto*/.assembleInvokable(callerState/*auto*/, ConstructionCaller(caller/*auto*/, callerState/*auto*/.platform(/*auto*/)), args/*auto*/);
		})).or(() => Main/*auto*/.parseValue(state/*auto*/, callerString/*auto*/).flatMap((callerTuple: Tuple2<CompileState, Value>) => Main/*auto*/.assembleInvokable(callerTuple/*auto*/.left(/*auto*/), callerTuple/*auto*/.right(/*auto*/), args/*auto*/))))));
	}
	static def splitFoldedLast(input: &[I8], delimiter: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState): Option<Tuple2<&[I8], &[I8]>> {
		return Main/*auto*/.splitFolded(input/*auto*/, folder/*auto*/, (mut divisions1: List<&[I8]>) => Main/*auto*/.selectLast(divisions1/*auto*/, delimiter/*auto*/));
	}
	static def splitFolded(input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState, selector: (arg0 : List<&[I8]>) => Option<Tuple2<&[I8], &[I8]>>): Option<Tuple2<&[I8], &[I8]>> {
		let divisions: List<&[I8]> = Main/*auto*/.divide(input/*auto*/, folder/*auto*/);
		if (2/*auto*/ > divisions/*auto*/.size(/*auto*/)) {
			return None<Tuple2<&[I8], &[I8]>>(/*auto*/);
		}
		return selector/*auto*/(divisions/*auto*/);
	}
	static def selectLast(divisions: List<&[I8]>, delimiter: &[I8]): Option<Tuple2<&[I8], &[I8]>> {
		let beforeLast: List<&[I8]> = divisions/*auto*/.subList(0/*auto*/, divisions/*auto*/.size(/*auto*/) - 1/*auto*/).orElse(divisions/*auto*/);
		let last: &[I8] = divisions/*auto*/.findLast(/*auto*/).orElse("");
		let joined: &[I8] = beforeLast/*auto*/.query(/*auto*/).collect(Joiner(delimiter/*auto*/)).orElse("");
		return Some<Tuple2<&[I8], &[I8]>>(Tuple2Impl<&[I8], &[I8]>(joined/*auto*/, last/*auto*/));
	}
	static def foldInvocationStarts(state: DivideState, c: I8): DivideState {
		let appended: DivideState = state/*auto*/.append(c/*auto*/);
		if ("(" === c/*auto*/) {
			let entered: DivideState = appended/*auto*/.enter(/*auto*/);
			if (entered/*auto*/.isShallow(/*auto*/)) {
				return entered/*auto*/.advance(/*auto*/);
			}
			else {
				return entered/*auto*/;
			}
		}
		if (")" === c/*auto*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def assembleInvokable(state: CompileState, oldCaller: Caller, argsString: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.parseValues(state/*auto*/, argsString/*auto*/, (mut state1: CompileState, mut s: &[I8]) => Main/*auto*/.parseArgument(state1/*auto*/, s/*auto*/)).flatMap((argsTuple: Tuple2<CompileState, List<Argument>>) => {
			let argsState: CompileState = argsTuple/*auto*/.left(/*auto*/);
			let args: List<Value> = Main/*auto*/.retain(argsTuple/*auto*/.right(/*auto*/), (mut argument: Argument) => argument/*auto*/.toValue(/*auto*/));
			let newCaller: Caller = Main/*auto*/.transformCaller(argsState/*auto*/, oldCaller/*auto*/);
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(argsState/*auto*/, InvokableNode(newCaller/*auto*/, args/*auto*/)));
		});
	}
	static def transformCaller(state: CompileState, oldCaller: Caller): Caller {
		return oldCaller/*auto*/.findChild(/*auto*/).flatMap((parent: Value) => {
			let parentType: Type = parent/*auto*/.resolve(state/*auto*/);
			if (parentType/*auto*/.isFunctional(/*auto*/)) {
				return Some<Caller>(parent/*auto*/);
			}
			return None<Caller>(/*auto*/);
		}).orElse(oldCaller/*auto*/);
	}
	static def retain<T, R>(args: List<T>, mapper: (arg0 : T) => Option<R>): List<R> {
		return args/*auto*/.query(/*auto*/).map(mapper/*auto*/).flatMap(Queries/*auto*/.fromOption).collect(ListCollector<R>(/*auto*/));
	}
	static def parseArgument(state1: CompileState, input: &[I8]): Option<Tuple2<CompileState, Argument>> {
		return Main/*auto*/.parseValue(state1/*auto*/, input/*auto*/).map((mut tuple: Tuple2<CompileState, Value>) => Tuple2Impl<CompileState, Argument>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/)));
	}
	static def compileAssignment(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(input/*auto*/, "=", (destination: &[I8], source: &[I8]) => {
			let sourceTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileValueOrPlaceholder(state/*auto*/, source/*auto*/);
			let destinationTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileValue(sourceTuple/*auto*/.left(/*auto*/), destination/*auto*/).or(() => Main/*auto*/.parseDefinition(sourceTuple/*auto*/.left(/*auto*/), destination/*auto*/).map((definitionTuple: Tuple2<CompileState, Definition>) => {
				let definitionState: CompileState = definitionTuple/*auto*/.left(/*auto*/);
				let definition: Definition = definitionTuple/*auto*/.right(/*auto*/);
				let let: Definition = Main/*auto*/.attachLet(definitionState/*auto*/, definition/*auto*/);
				let generate: &[I8] = let/*auto*/.generate(definitionState/*auto*/.platform(/*auto*/));
				return Tuple2Impl<CompileState, &[I8]>(definitionState/*auto*/, generate/*auto*/);
			})).orElseGet(() => Tuple2Impl<CompileState, &[I8]>(sourceTuple/*auto*/.left(/*auto*/), Main/*auto*/.generatePlaceholder(destination/*auto*/)));
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(destinationTuple/*auto*/.left(/*auto*/), destinationTuple/*auto*/.right(/*auto*/) + " = " + sourceTuple/*auto*/.right(/*auto*/)));
		});
	}
	static def attachLet(definitionState: CompileState, definition: Definition): Definition {
		/*final Definition let*/;
		if (definitionState/*auto*/.isPlatform(Platform/*auto*/.Windows)) {
			let/*auto*/ = definition/*auto*/;
		}
		else {
			let/*auto*/ = definition/*auto*/.addModifierLast("let");
		}
		return let/*auto*/;
	}
	static def compileValueOrPlaceholder(state: CompileState, input: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileValue(state/*auto*/, input/*auto*/).orElseGet(() => Tuple2Impl<CompileState, &[I8]>(state/*auto*/, Main/*auto*/.generatePlaceholder(input/*auto*/)));
	}
	static def compileValue(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseValue(state/*auto*/, input/*auto*/).map((tuple: Tuple2<CompileState, Value>) => {
			let generated: &[I8] = tuple/*auto*/.right(/*auto*/).generate(tuple/*auto*/.left(/*auto*/).platform(/*auto*/));
			return Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), generated/*auto*/);
		});
	}
	static def parseValue(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.or(state/*auto*/, input/*auto*/, Lists/*auto*/.of(Main/*auto*/.parseLambda, Main/*auto*/.createOperatorRule("+"), Main/*auto*/.createOperatorRule("-"), Main/*auto*/.createOperatorRule("<="), Main/*auto*/.createOperatorRule("<"), Main/*auto*/.createOperatorRule("&&"), Main/*auto*/.createOperatorRule("||"), Main/*auto*/.createOperatorRule(">"), Main/*auto*/.createOperatorRule(">="), Main/*auto*/.parseInvokable, Main/*auto*/.createAccessRule("."), Main/*auto*/.createAccessRule("::"), Main/*auto*/.parseSymbol, Main/*auto*/.parseNot, Main/*auto*/.parseNumber, Main/*auto*/.createOperatorRuleWithDifferentInfix("==", "==="), Main/*auto*/.createOperatorRuleWithDifferentInfix("!=", "!=="), Main/*auto*/.createTextRule("\""), Main/*auto*/.createTextRule("'")));
	}
	static def createTextRule(slice: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return (state1: CompileState, input1: &[I8]) => {
			let stripped: &[I8] = Strings/*auto*/.strip(input1/*auto*/);
			return Main/*auto*/.compilePrefix(stripped/*auto*/, slice/*auto*/, (s: &[I8]) => Main/*auto*/.compileSuffix(s/*auto*/, slice/*auto*/, (mut s1: &[I8]) => Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state1/*auto*/, StringNode(s1/*auto*/)))));
		};
	}
	static def parseNot(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.compilePrefix(Strings/*auto*/.strip(input/*auto*/), "!", (withoutPrefix: &[I8]) => {
			let childTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileValueOrPlaceholder(state/*auto*/, withoutPrefix/*auto*/);
			let childState: CompileState = childTuple/*auto*/.left(/*auto*/);
			let child: &[I8] = "!" + childTuple/*auto*/.right(/*auto*/);
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(childState/*auto*/, NotNode(child/*auto*/)));
		});
	}
	static def parseLambda(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.compileFirst(input/*auto*/, "->", (beforeArrow: &[I8], afterArrow: &[I8]) => {
			let strippedBeforeArrow: &[I8] = Strings/*auto*/.strip(beforeArrow/*auto*/);
			return Main/*auto*/.compilePrefix(strippedBeforeArrow/*auto*/, "(", (withoutStart: &[I8]) => Main/*auto*/.compileSuffix(withoutStart/*auto*/, ")", (withoutEnd: &[I8]) => Main/*auto*/.parseValues(state/*auto*/, withoutEnd/*auto*/, (mut state1: CompileState, mut s: &[I8]) => Main/*auto*/.parseParameter(state1/*auto*/, s/*auto*/)).flatMap((paramNames: Tuple2<CompileState, List<Parameter>>) => Main/*auto*/.compileLambdaWithParameterNames(paramNames/*auto*/.left(/*auto*/), Main/*auto*/.retainDefinitionsFromParameters(paramNames/*auto*/.right(/*auto*/)), afterArrow/*auto*/))));
		});
	}
	static def compileLambdaWithParameterNames(state: CompileState, paramNames: List<Definition>, afterArrow: &[I8]): Option<Tuple2<CompileState, Value>> {
		let strippedAfterArrow: &[I8] = Strings/*auto*/.strip(afterArrow/*auto*/);
		return Main/*auto*/.compilePrefix(strippedAfterArrow/*auto*/, "{", (withoutContentStart: &[I8]) => Main/*auto*/.compileSuffix(withoutContentStart/*auto*/, "}", (withoutContentEnd: &[I8]) => {
			let statementsTuple: Tuple2<CompileState, &[I8]> = Main/*auto*/.compileFunctionStatements(state/*auto*/.enterDepth(/*auto*/).defineAll(paramNames/*auto*/), withoutContentEnd/*auto*/);
			let statementsState: CompileState = statementsTuple/*auto*/.left(/*auto*/);
			let statements: &[I8] = statementsTuple/*auto*/.right(/*auto*/);
			let exited: CompileState = statementsState/*auto*/.exitDepth(/*auto*/);
			let content: &[I8] = "{" + statements/*auto*/ + exited/*auto*/.createIndent(/*auto*/) + "}";
			if (exited/*auto*/.isPlatform(Platform/*auto*/.Windows)) {
				return Main/*auto*/.assembleLambdaWithContent(exited/*auto*/, paramNames/*auto*/, content/*auto*/);
			}
			return Main/*auto*/.getSome(exited/*auto*/, paramNames/*auto*/, content/*auto*/);
		})).or(() => Main/*auto*/.compileValue(state/*auto*/, strippedAfterArrow/*auto*/).flatMap((tuple: Tuple2<CompileState, &[I8]>) => {
			let state1: CompileState = tuple/*auto*/.left(/*auto*/);
			let content: &[I8] = tuple/*auto*/.right(/*auto*/);
			if (state1/*auto*/.isPlatform(Platform/*auto*/.Windows)) {
				return Main/*auto*/.assembleLambdaWithContent(state1/*auto*/, paramNames/*auto*/, "\n\treturn " + content/*auto*/ + ";");
			}
			return Main/*auto*/.getSome(state1/*auto*/, paramNames/*auto*/, content/*auto*/);
		}));
	}
	static def getSome(state: CompileState, parameters: List<Definition>, content: &[I8]): Some<Tuple2<CompileState, Value>> {
		return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state/*auto*/, LambdaNode(parameters/*auto*/, content/*auto*/)));
	}
	static def assembleLambdaWithContent(state: CompileState, parameters: List<Definition>, content: &[I8]): Some<Tuple2<CompileState, Value>> {
		let lambdaDefinition: Definition = Definition(PrimitiveType/*auto*/.Auto, state/*auto*/.functionName(/*auto*/));
		let value: FunctionSegment<Definition> = FunctionSegment<Definition>(lambdaDefinition/*auto*/, parameters/*auto*/, Some<>(content/*auto*/));
		return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state/*auto*/.addFunction(value/*auto*/.generate(state/*auto*/.platform(/*auto*/), "\n")), SymbolNode("lambdaDefinition", PrimitiveType/*auto*/.Auto)));
	}
	static def createOperatorRule(infix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.createOperatorRuleWithDifferentInfix(infix/*auto*/, infix/*auto*/);
	}
	static def createAccessRule(infix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return (mut state: CompileState, mut input: &[I8]) => Main/*auto*/.compileLast(input/*auto*/, infix/*auto*/, (childString: &[I8], rawProperty: &[I8]) => {
			let property: &[I8] = Strings/*auto*/.strip(rawProperty/*auto*/);
			if (!Main/*auto*/.isSymbol(property/*auto*/)) {
				return None<Tuple2<CompileState, Value>>(/*auto*/);
			}
			return Main/*auto*/.parseValue(state/*auto*/, childString/*auto*/).flatMap((childTuple: Tuple2<CompileState, Value>) => {
				let childState: CompileState = childTuple/*auto*/.left(/*auto*/);
				let child: Value = childTuple/*auto*/.right(/*auto*/);
				return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(childState/*auto*/, AccessNode(child/*auto*/, property/*auto*/)));
			});
		});
	}
	static def createOperatorRuleWithDifferentInfix(sourceInfix: &[I8], targetInfix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return (state1: CompileState, input1: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFolded(input1/*auto*/, Main/*auto*/.foldOperator(sourceInfix/*auto*/), (mut divisions: List<&[I8]>) => Main/*auto*/.selectFirst(divisions/*auto*/, sourceInfix/*auto*/)), (leftString: &[I8], rightString: &[I8]) => Main/*auto*/.parseValue(state1/*auto*/, leftString/*auto*/).flatMap((leftTuple: Tuple2<CompileState, Value>) => Main/*auto*/.parseValue(leftTuple/*auto*/.left(/*auto*/), rightString/*auto*/).flatMap((rightTuple: Tuple2<CompileState, Value>) => {
			let left: Value = leftTuple/*auto*/.right(/*auto*/);
			let right: Value = rightTuple/*auto*/.right(/*auto*/);
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(rightTuple/*auto*/.left(/*auto*/), OperationNode(left/*auto*/, targetInfix/*auto*/, right/*auto*/)));
		})));
	}
	static def selectFirst(divisions: List<&[I8]>, delimiter: &[I8]): Option<Tuple2<&[I8], &[I8]>> {
		let first: &[I8] = divisions/*auto*/.findFirst(/*auto*/).orElse("");
		let afterFirst: &[I8] = divisions/*auto*/.subList(1/*auto*/, divisions/*auto*/.size(/*auto*/)).orElse(divisions/*auto*/).query(/*auto*/).collect(Joiner(delimiter/*auto*/)).orElse("");
		return Some<Tuple2<&[I8], &[I8]>>(Tuple2Impl<&[I8], &[I8]>(first/*auto*/, afterFirst/*auto*/));
	}
	static def foldOperator(infix: &[I8]): (arg0 : DivideState, arg1 : I8) => DivideState {
		return (state: DivideState, c: I8) => {
			if (c/*auto*/ === Strings/*auto*/.charAt(infix/*auto*/, 0/*auto*/) && state/*auto*/.startsWith(Strings/*auto*/.sliceFrom(infix/*auto*/, 1/*auto*/))) {
				let length: I32 = Strings/*auto*/.length(infix/*auto*/) - 1/*auto*/;
				mut let counter: I32 = 0/*auto*/;
				mut let current: DivideState = state/*auto*/;
				while (counter/*auto*/ < length/*auto*/) {
					counter/*auto*/++;
					current/*auto*/ = current/*auto*/.pop(/*auto*/).map((mut tuple: Tuple2<DivideState, I8>) => tuple/*auto*/.left(/*auto*/)).orElse(current/*auto*/);
				}
				return current/*auto*/.advance(/*auto*/);
			}
			return state/*auto*/.append(c/*auto*/);
		};
	}
	static def parseNumber(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		let stripped: &[I8] = Strings/*auto*/.strip(input/*auto*/);
		if (Main/*auto*/.isNumber(stripped/*auto*/)) {
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state/*auto*/, SymbolNode(stripped/*auto*/, PrimitiveType/*auto*/.Auto)));
		}
		else {
			return None<Tuple2<CompileState, Value>>(/*auto*/);
		}
	}
	static def isNumber(input: &[I8]): Bool {
		let query: HeadedQuery<I32> = HeadedQuery<I32>(RangeHead(Strings/*auto*/.length(input/*auto*/)));
		return query/*auto*/.map((mut index: I32) => input/*auto*/.charAt(index/*auto*/)).allMatch((mut c: I8) => Characters/*auto*/.isDigit(c/*auto*/));
	}
	static def parseSymbol(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		let stripped: &[I8] = Strings/*auto*/.strip(input/*auto*/);
		if (Main/*auto*/.isSymbol(stripped/*auto*/)) {
			let withImport: CompileState = state/*auto*/.addResolvedImportFromCache(stripped/*auto*/);
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(withImport/*auto*/, SymbolNode(stripped/*auto*/, PrimitiveType/*auto*/.Auto)));
		}
		else {
			return None<Tuple2<CompileState, Value>>(/*auto*/);
		}
	}
	static def isSymbol(input: &[I8]): Bool {
		let query: HeadedQuery<I32> = HeadedQuery<I32>(RangeHead(Strings/*auto*/.length(input/*auto*/)));
		return query/*auto*/.allMatch((mut index: I32) => Main/*auto*/.isSymbolChar(index/*auto*/, Strings/*auto*/.charAt(input/*auto*/, index/*auto*/)));
	}
	static def isSymbolChar(index: I32, c: I8): Bool {
		return "_" === c/*auto*/ || Characters/*auto*/.isLetter(c/*auto*/) || /*auto*/(0/*auto*/ !== index/*auto*/ && Characters/*auto*/.isDigit(c/*auto*/));
	}
	static def compilePrefix<T>(input: &[I8], infix: &[I8], mapper: (arg0 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, T>> {
		if (!input/*auto*/.startsWith(infix/*auto*/)) {
			return None<Tuple2<CompileState, T>>(/*auto*/);
		}
		let slice: &[I8] = Strings/*auto*/.sliceFrom(input/*auto*/, Strings/*auto*/.length(infix/*auto*/));
		return mapper/*auto*/(slice/*auto*/);
	}
	static def compileWhitespace(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseWhitespace(state/*auto*/, input/*auto*/).map((tuple: Tuple2<CompileState, Whitespace>) => {
			let generate: &[I8] = tuple/*auto*/.right(/*auto*/).generate(tuple/*auto*/.left(/*auto*/).platform(/*auto*/));
			return Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), generate/*auto*/);
		});
	}
	static def parseWhitespace(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Whitespace>> {
		if (Strings/*auto*/.isBlank(input/*auto*/)) {
			return Some<Tuple2<CompileState, Whitespace>>(Tuple2Impl<CompileState, Whitespace>(state/*auto*/, Whitespace(/*auto*/)));
		}
		return None<Tuple2<CompileState, Whitespace>>(/*auto*/);
	}
	static def compileFieldDefinition(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*auto*/), ";", (withoutEnd: &[I8]) => Main/*auto*/.getTupleOption(state/*auto*/, withoutEnd/*auto*/).or(() => Main/*auto*/.compileEnumValues(state/*auto*/, withoutEnd/*auto*/)));
	}
	static def getTupleOption(state: CompileState, withoutEnd: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseParameter(state/*auto*/, withoutEnd/*auto*/).flatMap((definitionTuple: Tuple2<CompileState, Parameter>) => {
			let generate: &[I8] = "\n\t" + definitionTuple/*auto*/.right(/*auto*/).generate(definitionTuple/*auto*/.left(/*auto*/).platform(/*auto*/)) + ";";
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(definitionTuple/*auto*/.left(/*auto*/), generate/*auto*/));
		});
	}
	static def compileEnumValues(state: CompileState, withoutEnd: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseValues(state/*auto*/, withoutEnd/*auto*/, (state1: CompileState, s: &[I8]) => Main/*auto*/.parseInvokable(state1/*auto*/, s/*auto*/).flatMap((tuple: Tuple2<CompileState, Value>) => {
			let structureName: &[I8] = state/*auto*/.findLastStructureName(/*auto*/).orElse("");
			return tuple/*auto*/.right(/*auto*/).generateAsEnumValue(structureName/*auto*/, state/*auto*/.platform(/*auto*/)).map((stringOption: &[I8]) => Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), stringOption/*auto*/));
		})).map((tuple: Tuple2<CompileState, List<&[I8]>>) => Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/).query(/*auto*/).collect(Joiner("")).orElse("")));
	}
	static def parseParameterOrPlaceholder(state: CompileState, input: &[I8]): Tuple2<CompileState, Parameter> {
		return Main/*auto*/.parseParameter(state/*auto*/, input/*auto*/).orElseGet(() => Tuple2Impl<CompileState, Parameter>(state/*auto*/, Placeholder(input/*auto*/)));
	}
	static def parseParameter(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Parameter>> {
		return Main/*auto*/.parseWhitespace(state/*auto*/, input/*auto*/).map((mut tuple: Tuple2<CompileState, Whitespace>) => Main/*auto*/.getCompileStateParameterTuple2(tuple/*auto*/)).or(() => Main/*auto*/.parseDefinition(state/*auto*/, input/*auto*/).map((mut tuple: Tuple2<CompileState, Definition>) => Tuple2Impl<CompileState, Parameter>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/))));
	}
	static def getCompileStateParameterTuple2(tuple: Tuple2<CompileState, Whitespace>): Tuple2<CompileState, Parameter> {
		return Tuple2Impl<CompileState, Parameter>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/));
	}
	static def parseDefinition(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Definition>> {
		return Main/*auto*/.compileLast(Strings/*auto*/.strip(input/*auto*/), " ", (beforeName: &[I8], name: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFoldedLast(Strings/*auto*/.strip(beforeName/*auto*/), " ", Main/*auto*/.foldTypeSeparators), (beforeType: &[I8], type: &[I8]) => Main/*auto*/.compileLast(Strings/*auto*/.strip(beforeType/*auto*/), "\n", (annotationsString: &[I8], afterAnnotations: &[I8]) => {
			let annotations: List<&[I8]> = Main/*auto*/.parseAnnotations(annotationsString/*auto*/);
			return Main/*auto*/.parseDefinitionWithAnnotations(state/*auto*/, annotations/*auto*/, afterAnnotations/*auto*/, type/*auto*/, name/*auto*/);
		}).or(() => Main/*auto*/.parseDefinitionWithAnnotations(state/*auto*/, Lists/*auto*/.empty(/*auto*/), beforeType/*auto*/, type/*auto*/, name/*auto*/))).or(() => Main/*auto*/.parseDefinitionWithTypeParameters(state/*auto*/, Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), beforeName/*auto*/, name/*auto*/)));
	}
	static def parseAnnotations(s: &[I8]): List<&[I8]> {
		return Main/*auto*/.divide(s/*auto*/, (mut state1: DivideState, mut c: I8) => Main/*auto*/.foldDelimited(state1/*auto*/, c/*auto*/, "\n")).query(/*auto*/).map((mut s2: &[I8]) => Strings/*auto*/.strip(s2/*auto*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*auto*/)).filter((mut value: &[I8]) => 1/*auto*/ <= Strings/*auto*/.length(value/*auto*/)).map((mut value: &[I8]) => Strings/*auto*/.sliceFrom(value/*auto*/, 1/*auto*/)).map((mut s1: &[I8]) => Strings/*auto*/.strip(s1/*auto*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*auto*/)).collect(ListCollector<&[I8]>(/*auto*/));
	}
	static def parseDefinitionWithAnnotations(state: CompileState, annotations: List<&[I8]>, beforeType: &[I8], type: &[I8], name: &[I8]): Option<Tuple2<CompileState, Definition>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(beforeType/*auto*/), ">", (withoutTypeParamEnd: &[I8]) => Main/*auto*/.compileFirst(withoutTypeParamEnd/*auto*/, "<", (beforeTypeParams: &[I8], typeParamsString: &[I8]) => {
			let typeParams: List<&[I8]> = Main/*auto*/.divideValues(typeParamsString/*auto*/);
			return Main/*auto*/.parseDefinitionWithTypeParameters(state/*auto*/, annotations/*auto*/, typeParams/*auto*/, Main/*auto*/.parseModifiers(beforeTypeParams/*auto*/), type/*auto*/, name/*auto*/);
		})).or(() => {
			let divided: List<&[I8]> = Main/*auto*/.parseModifiers(beforeType/*auto*/);
			return Main/*auto*/.parseDefinitionWithTypeParameters(state/*auto*/, annotations/*auto*/, Lists/*auto*/.empty(/*auto*/), divided/*auto*/, type/*auto*/, name/*auto*/);
		});
	}
	static def parseModifiers(beforeType: &[I8]): List<&[I8]> {
		return Main/*auto*/.divide(Strings/*auto*/.strip(beforeType/*auto*/), (mut state1: DivideState, mut c: I8) => Main/*auto*/.foldDelimited(state1/*auto*/, c/*auto*/, " ")).query(/*auto*/).map((mut s: &[I8]) => Strings/*auto*/.strip(s/*auto*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*auto*/)).collect(ListCollector<&[I8]>(/*auto*/));
	}
	static def foldDelimited(state1: DivideState, c: I8, delimiter: I8): DivideState {
		if (delimiter/*auto*/ === c/*auto*/) {
			return state1/*auto*/.advance(/*auto*/);
		}
		return state1/*auto*/.append(c/*auto*/);
	}
	static def divideValues(input: &[I8]): List<&[I8]> {
		return Main/*auto*/.divide(input/*auto*/, Main/*auto*/.foldValues).query(/*auto*/).map((mut input1: &[I8]) => Strings/*auto*/.strip(input1/*auto*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*auto*/)).collect(ListCollector<&[I8]>(/*auto*/));
	}
	static def foldTypeSeparators(state: DivideState, c: I8): DivideState {
		if (" " === c/*auto*/ && state/*auto*/.isLevel(/*auto*/)) {
			return state/*auto*/.advance(/*auto*/);
		}
		let appended: DivideState = state/*auto*/.append(c/*auto*/);
		if ("<" === c/*auto*/) {
			return appended/*auto*/.enter(/*auto*/);
		}
		if (">" === c/*auto*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def parseDefinitionWithTypeParameters(state: CompileState, annotations: List<&[I8]>, typeParams: List<&[I8]>, oldModifiers: List<&[I8]>, type: &[I8], name: &[I8]): Option<Tuple2<CompileState, Definition>> {
		return Main/*auto*/.parseType(state/*auto*/, type/*auto*/).flatMap((typeTuple: Tuple2<CompileState, Type>) => {
			let newModifiers: List<&[I8]> = Main/*auto*/.modifyModifiers(oldModifiers/*auto*/, state/*auto*/.platform(/*auto*/));
			let generated: Definition = Definition(annotations/*auto*/, newModifiers/*auto*/, typeParams/*auto*/, typeTuple/*auto*/.right(/*auto*/), name/*auto*/);
			return Some<Tuple2<CompileState, Definition>>(Tuple2Impl<CompileState, Definition>(typeTuple/*auto*/.left(/*auto*/), generated/*auto*/));
		});
	}
	static def modifyModifiers(oldModifiers: List<&[I8]>, platform: Platform): List<&[I8]> {
		let list: List<&[I8]> = Main/*auto*/.retainFinal(oldModifiers/*auto*/, platform/*auto*/);
		if (oldModifiers/*auto*/.contains("static", Strings/*auto*/.equalsTo)) {
			return list/*auto*/.addLast("static");
		}
		return list/*auto*/;
	}
	static def retainFinal(oldModifiers: List<&[I8]>, platform: Platform): List<&[I8]> {
		if (oldModifiers/*auto*/.contains("final", Strings/*auto*/.equalsTo) || Platform/*auto*/.Magma !== platform/*auto*/) {
			return Lists/*auto*/.empty(/*auto*/);
		}
		return Lists/*auto*/.of("mut");
	}
	static def parseTypeOrPlaceholder(state: CompileState, type: &[I8]): Tuple2<CompileState, Type> {
		return Main/*auto*/.parseType(state/*auto*/, type/*auto*/).map((mut tuple: Tuple2<CompileState, Type>) => Tuple2Impl<CompileState, Type>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/))).orElseGet(() => Tuple2Impl<CompileState, Type>(state/*auto*/, Placeholder(type/*auto*/)));
	}
	static def compileType(state: CompileState, type: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseType(state/*auto*/, type/*auto*/).map((mut tuple: Tuple2<CompileState, Type>) => Tuple2Impl<CompileState, &[I8]>(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/).generate(/*auto*/)));
	}
	static def parseType(state: CompileState, type: &[I8]): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.or(state/*auto*/, type/*auto*/, Lists/*auto*/.of(Main/*auto*/.parseArrayType, Main/*auto*/.parseVarArgs, Main/*auto*/.parseGeneric, Main/*auto*/.parsePrimitive, Main/*auto*/.parseSymbolType));
	}
	static def parseArrayType(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		let stripped: &[I8] = Strings/*auto*/.strip(input/*auto*/);
		return Main/*auto*/.compileSuffix(stripped/*auto*/, "[]", (s: &[I8]) => {
			let child: Tuple2<CompileState, Type> = Main/*auto*/.parseTypeOrPlaceholder(state/*auto*/, s/*auto*/);
			return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(child/*auto*/.left(/*auto*/), ArrayType(child/*auto*/.right(/*auto*/))));
		});
	}
	static def parseVarArgs(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		let stripped: &[I8] = Strings/*auto*/.strip(input/*auto*/);
		return Main/*auto*/.compileSuffix(stripped/*auto*/, "...", (s: &[I8]) => {
			let child: Tuple2<CompileState, Type> = Main/*auto*/.parseTypeOrPlaceholder(state/*auto*/, s/*auto*/);
			return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(child/*auto*/.left(/*auto*/), VariadicType(child/*auto*/.right(/*auto*/))));
		});
	}
	static def parseSymbolType(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		let stripped: &[I8] = Strings/*auto*/.strip(input/*auto*/);
		if (Main/*auto*/.isSymbol(stripped/*auto*/)) {
			return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(state/*auto*/.addResolvedImportFromCache(stripped/*auto*/), SymbolNode(stripped/*auto*/, PrimitiveType/*auto*/.Auto)));
		}
		return None<Tuple2<CompileState, Type>>(/*auto*/);
	}
	static def parsePrimitive(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.findPrimitiveValue(Strings/*auto*/.strip(input/*auto*/), state/*auto*/.platform(/*auto*/)).map((mut result: Type) => Tuple2Impl<CompileState, Type>(state/*auto*/, result/*auto*/));
	}
	static def findPrimitiveValue(input: &[I8], platform: Platform): Option<Type> {
		let stripped: &[I8] = Strings/*auto*/.strip(input/*auto*/);
		if (Strings/*auto*/.equalsTo("char", stripped/*auto*/) || Strings/*auto*/.equalsTo("Character", stripped/*auto*/)) {
			if (Platform/*auto*/.TypeScript === platform/*auto*/) {
				return Some<Type>(PrimitiveType/*auto*/.String);
			}
			else {
				return Some<Type>(PrimitiveType/*auto*/.I8);
			}
		}
		if (Strings/*auto*/.equalsTo("String", stripped/*auto*/)) {
			if (Platform/*auto*/.TypeScript === platform/*auto*/) {
				return Some<Type>(PrimitiveType/*auto*/.String);
			}
			else {
				return Some<Type>(SliceType(PrimitiveType/*auto*/.I8));
			}
		}
		if (Strings/*auto*/.equalsTo("int", stripped/*auto*/) || Strings/*auto*/.equalsTo("Integer", stripped/*auto*/)) {
			if (Platform/*auto*/.Magma === platform/*auto*/) {
				return Some<Type>(PrimitiveType/*auto*/.I32);
			}
			else {
				return Some<Type>(PrimitiveType/*auto*/.Number);
			}
		}
		if (Strings/*auto*/.equalsTo("boolean", stripped/*auto*/) || Strings/*auto*/.equalsTo("Boolean", stripped/*auto*/)) {
			return Some<Type>(BooleanType(platform/*auto*/));
		}
		if (Strings/*auto*/.equalsTo("var", stripped/*auto*/)) {
			return Some<Type>(PrimitiveType/*auto*/.Var);
		}
		if (Strings/*auto*/.equalsTo("void", stripped/*auto*/)) {
			return Some<Type>(PrimitiveType/*auto*/.Void);
		}
		return None<Type>(/*auto*/);
	}
	static def parseGeneric(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*auto*/), ">", (withoutEnd: &[I8]) => Main/*auto*/.compileFirst(withoutEnd/*auto*/, "<", (baseString: &[I8], argsString: &[I8]) => {
			let argsTuple: Tuple2<CompileState, List<&[I8]>> = Main/*auto*/.parseValuesOrEmpty(state/*auto*/, argsString/*auto*/, (mut state1: CompileState, mut s: &[I8]) => Main/*auto*/.compileTypeArgument(state1/*auto*/, s/*auto*/));
			let argsState: CompileState = argsTuple/*auto*/.left(/*auto*/);
			let args: List<&[I8]> = argsTuple/*auto*/.right(/*auto*/);
			let base: &[I8] = Strings/*auto*/.strip(baseString/*auto*/);
			return Main/*auto*/.assembleFunctionType(argsState/*auto*/, base/*auto*/, args/*auto*/).or(() => {
				let compileState: CompileState = argsState/*auto*/.addResolvedImportFromCache(base/*auto*/);
				return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(compileState/*auto*/, TemplateType(base/*auto*/, args/*auto*/)));
			});
		}));
	}
	static def assembleFunctionType(state: CompileState, base: &[I8], args: List<&[I8]>): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.mapFunctionType(base/*auto*/, args/*auto*/).map((mut generated: Type) => Tuple2Impl<CompileState, Type>(state/*auto*/, generated/*auto*/));
	}
	static def mapFunctionType(base: &[I8], args: List<&[I8]>): Option<Type> {
		if (Strings/*auto*/.equalsTo("Function", base/*auto*/)) {
			return args/*auto*/.findFirst(/*auto*/).and(() => args/*auto*/.find(1/*auto*/)).map((mut tuple: Tuple2<&[I8], &[I8]>) => FunctionType(Lists/*auto*/.of(tuple/*auto*/.left(/*auto*/)), tuple/*auto*/.right(/*auto*/)));
		}
		if (Strings/*auto*/.equalsTo("BiFunction", base/*auto*/)) {
			return args/*auto*/.find(0/*auto*/).and(() => args/*auto*/.find(1/*auto*/)).and(() => args/*auto*/.find(2/*auto*/)).map((mut tuple: Tuple2<Tuple2<&[I8], &[I8]>, &[I8]>) => FunctionType(Lists/*auto*/.of(tuple/*auto*/.left(/*auto*/).left(/*auto*/), tuple/*auto*/.left(/*auto*/).right(/*auto*/)), tuple/*auto*/.right(/*auto*/)));
		}
		if (Strings/*auto*/.equalsTo("Supplier", base/*auto*/)) {
			return args/*auto*/.findFirst(/*auto*/).map((first: &[I8]) => FunctionType(Lists/*auto*/.empty(/*auto*/), first/*auto*/));
		}
		if (Strings/*auto*/.equalsTo("Consumer", base/*auto*/)) {
			return args/*auto*/.findFirst(/*auto*/).map((first: &[I8]) => FunctionType(Lists/*auto*/.of(first/*auto*/), "void"));
		}
		if (Strings/*auto*/.equalsTo("Predicate", base/*auto*/)) {
			return args/*auto*/.findFirst(/*auto*/).map((first: &[I8]) => FunctionType(Lists/*auto*/.of(first/*auto*/), "boolean"));
		}
		return None<Type>(/*auto*/);
	}
	static def compileTypeArgument(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.or(state/*auto*/, input/*auto*/, Lists/*auto*/.of((mut state2: CompileState, mut input1: &[I8]) => Main/*auto*/.compileWhitespace(state2/*auto*/, input1/*auto*/), (mut state1: CompileState, mut type: &[I8]) => Main/*auto*/.compileType(state1/*auto*/, type/*auto*/)));
	}
	static def parseValuesOrEmpty<T>(state: CompileState, input: &[I8], mapper: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Tuple2<CompileState, List<T>> {
		return Main/*auto*/.parseValues(state/*auto*/, input/*auto*/, mapper/*auto*/).orElse(Tuple2Impl<CompileState, List<T>>(state/*auto*/, Lists/*auto*/.empty(/*auto*/)));
	}
	static def parseValues<T>(state: CompileState, input: &[I8], mapper: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, List<T>>> {
		return Main/*auto*/.parseAll(state/*auto*/, input/*auto*/, Main/*auto*/.foldValues, mapper/*auto*/);
	}
	static def foldValues(state: DivideState, c: I8): DivideState {
		if ("," === c/*auto*/ && state/*auto*/.isLevel(/*auto*/)) {
			return state/*auto*/.advance(/*auto*/);
		}
		let appended: DivideState = state/*auto*/.append(c/*auto*/);
		if ("-" === c/*auto*/) {
			let peeked: I8 = appended/*auto*/.peek(/*auto*/);
			if (">" === peeked/*auto*/) {
				return appended/*auto*/.popAndAppendToOption(/*auto*/).orElse(appended/*auto*/);
			}
			else {
				return appended/*auto*/;
			}
		}
		if ("<" === c/*auto*/ || "(" === c/*auto*/) {
			return appended/*auto*/.enter(/*auto*/);
		}
		if (">" === c/*auto*/ || ")" === c/*auto*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def compileLast<T>(input: &[I8], infix: &[I8], mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return Main/*auto*/.compileInfix(input/*auto*/, infix/*auto*/, Main/*auto*/.findLast, mapper/*auto*/);
	}
	static def findLast(input: &[I8], infix: &[I8]): I32 {
		return input/*auto*/.lastIndexOf(infix/*auto*/);
	}
	static def compileSuffix<T>(input: &[I8], suffix: &[I8], mapper: (arg0 : &[I8]) => Option<T>): Option<T> {
		if (!input/*auto*/.endsWith(suffix/*auto*/)) {
			return None<T>(/*auto*/);
		}
		let length: I32 = Strings/*auto*/.length(input/*auto*/);
		let length1: I32 = Strings/*auto*/.length(suffix/*auto*/);
		let content: &[I8] = Strings/*auto*/.sliceBetween(input/*auto*/, 0/*auto*/, length/*auto*/ - length1/*auto*/);
		return mapper/*auto*/(content/*auto*/);
	}
	static def compileFirst<T>(input: &[I8], infix: &[I8], mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return Main/*auto*/.compileInfix(input/*auto*/, infix/*auto*/, Main/*auto*/.findFirst, mapper/*auto*/);
	}
	static def compileInfix<T>(input: &[I8], infix: &[I8], locator: (arg0 : &[I8], arg1 : &[I8]) => I32, mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return Main/*auto*/.compileSplit(Main/*auto*/.split(input/*auto*/, infix/*auto*/, locator/*auto*/), mapper/*auto*/);
	}
	static def compileSplit<T>(splitter: Option<Tuple2<&[I8], &[I8]>>, mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return splitter/*auto*/.flatMap((mut tuple: Tuple2<&[I8], &[I8]>) => mapper/*auto*/(tuple/*auto*/.left(/*auto*/), tuple/*auto*/.right(/*auto*/)));
	}
	static def split(input: &[I8], infix: &[I8], locator: (arg0 : &[I8], arg1 : &[I8]) => I32): Option<Tuple2<&[I8], &[I8]>> {
		let index: I32 = locator/*auto*/(input/*auto*/, infix/*auto*/);
		if (0/*auto*/ > index/*auto*/) {
			return None<Tuple2<&[I8], &[I8]>>(/*auto*/);
		}
		let left: &[I8] = Strings/*auto*/.sliceBetween(input/*auto*/, 0/*auto*/, index/*auto*/);
		let length: I32 = Strings/*auto*/.length(infix/*auto*/);
		let right: &[I8] = Strings/*auto*/.sliceFrom(input/*auto*/, index/*auto*/ + length/*auto*/);
		return Some<Tuple2<&[I8], &[I8]>>(Tuple2Impl<&[I8], &[I8]>(left/*auto*/, right/*auto*/));
	}
	static def findFirst(input: &[I8], infix: &[I8]): I32 {
		return input/*auto*/.indexOf(infix/*auto*/);
	}
	static def generatePlaceholder(input: &[I8]): &[I8] {
		let replaced: &[I8] = input/*auto*/.replace("/*", "start").replace("*/", "end");
		return "/*" + replaced/*auto*/ + "*/";
	}
}
Main.main();