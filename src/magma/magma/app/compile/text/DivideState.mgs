// [Lists, Lists, Lists, Console, Console, Console, Files, Files, Files, Characters, Characters, Characters, Strings, Strings, Strings, Actual, Actual, Actual, Namespace, Namespace, Namespace, Collector, Collector, Collector, EmptyHead, EmptyHead, EmptyHead, FlatMapHead, FlatMapHead, FlatMapHead, Head, Head, Head, HeadedQuery, HeadedQuery, HeadedQuery, MapHead, MapHead, MapHead, RangeHead, RangeHead, RangeHead, SingleHead, SingleHead, SingleHead, ZipHead, ZipHead, ZipHead, Joiner, Joiner, Joiner, List, List, List, ListCollector, ListCollector, ListCollector, Queries, Queries, Queries, Query, Query, Query, IOError, IOError, IOError, Path, Path, Path, None, None, None, Option, Option, Option, Some, Some, Some, Err, Err, Err, Ok, Ok, Ok, Result, Result, Result, Tuple2, Tuple2, Tuple2, Tuple2Impl, Tuple2Impl, Tuple2Impl, Type, Type, Type, CompileState, CompileState, CompileState, Definition, Definition, Definition, FunctionHeader, FunctionHeader, FunctionHeader, Parameter, Parameter, Parameter, FunctionSegment, FunctionSegment, FunctionSegment, ImmutableCompileState, ImmutableCompileState, ImmutableCompileState, Import, Import, Import, DivideState, DivideState]
import magma.api.collect.list.{ List };
import jvm.api.collect.list.{ Lists };
import magma.api.{ Tuple2, Tuple2Impl };
import magma.api.option.{ Option, None, Some };
import jvm.api.text.{ Strings };
export struct DivideState {
	mut segments: List<&[I8]>;
	mut buffer: &[I8];
	mut depth: I32;
	mut input: &[I8];
	mut index: I32;
	constructor (mut segments: List<&[I8]>, mut buffer: &[I8], mut depth: I32, mut input: &[I8], mut index: I32) {
		this.segments = segments;
		this.buffer = buffer;
		this.depth = depth;
		this.input = input;
		this.index = index;
	}
	static def createInitial(input: &[I8]): DivideState {
		return DivideState(Lists/*auto*/.empty(/*auto*/), "", 0/*auto*/, input/*&[I8]*/, 0/*auto*/);
	}
	def advance(): DivideState {
		return DivideState(this/*auto*/.segments.addLast(this/*auto*/.buffer), "", this/*auto*/.depth, this/*auto*/.input, this/*auto*/.index);
	}
	def append(c: I8): DivideState {
		return DivideState(this/*auto*/.segments, this/*auto*/.buffer + c/*I8*/, this/*auto*/.depth, this/*auto*/.input, this/*auto*/.index);
	}
	def isLevel(): Bool {
		return 0/*auto*/ === this/*auto*/.depth;
	}
	def enter(): DivideState {
		return DivideState(this/*auto*/.segments, this/*auto*/.buffer, this/*auto*/.depth + 1/*auto*/, this/*auto*/.input, this/*auto*/.index);
	}
	def exit(): DivideState {
		return DivideState(this/*auto*/.segments, this/*auto*/.buffer, this/*auto*/.depth - 1/*auto*/, this/*auto*/.input, this/*auto*/.index);
	}
	def isShallow(): Bool {
		return 1/*auto*/ === this/*auto*/.depth;
	}
	def pop(): Option<Tuple2<DivideState, I8>> {
		if (this/*auto*/.index >= Strings/*auto*/.length(this/*auto*/.input)) {
			return None<Tuple2<DivideState, I8>>(/*auto*/);
		}
		let c = Strings/*auto*/.charAt(this/*auto*/.input, this/*auto*/.index);
		let nextState = DivideState(this/*auto*/.segments, this/*auto*/.buffer, this/*auto*/.depth, this/*auto*/.input, this/*auto*/.index + 1/*auto*/);
		return Some<Tuple2<DivideState, I8>>(Tuple2Impl<DivideState, I8>(nextState/*auto*/, c/*I8*/));
	}
	def popAndAppendToTuple(): Option<Tuple2<DivideState, I8>> {
		return this/*auto*/.pop(/*auto*/).map((mut inner: Tuple2<DivideState, I8>) => Tuple2Impl<DivideState, I8>(inner/*auto*/.left(/*auto*/).append(inner/*auto*/.right(/*auto*/)), inner/*auto*/.right(/*auto*/)));
	}
	def popAndAppendToOption(): Option<DivideState> {
		return this/*auto*/.popAndAppendToTuple(/*auto*/).map((mut tuple: Tuple2<DivideState, I8>) => tuple/*auto*/.left(/*auto*/));
	}
	def peek(): I8 {
		return Strings/*auto*/.charAt(this/*auto*/.input, this/*auto*/.index);
	}
	def startsWith(slice: &[I8]): Bool {
		return Strings/*auto*/.sliceFrom(this/*auto*/.input, this/*auto*/.index).startsWith(slice/*&[I8]*/);
	}
}
