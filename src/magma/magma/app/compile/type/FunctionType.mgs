// [Lists, Console, Files, Characters, Strings, Actual, Namespace, Collector, EmptyHead, FlatMapHead, Head, HeadedQuery, MapHead, RangeHead, SingleHead, ZipHead, Joiner, List, ListCollector, Queries, Query, IOError, Path, None, Option, Some, Err, Ok, Result, Tuple2, Tuple2Impl, Type, CompileState, Definition, FunctionHeader, Parameter, FunctionSegment, ImmutableCompileState, Import, DivideState, Placeholder, Whitespace, ArrayType, BooleanType, FunctionType, PrimitiveType, SliceType, TemplateType, VariadicType, AccessNode, Argument, Caller, ConstructionCaller, ConstructorHeader, InvokableNode, LambdaNode, NotNode, OperationNode, StringNode, SymbolNode, Value, Location, Platform, Source, Main, Lists, Console, Files, Characters, Strings, Actual, Namespace, Collector, EmptyHead, FlatMapHead, Head, HeadedQuery, MapHead, RangeHead, SingleHead, ZipHead, Joiner, List, ListCollector, Queries, Query, IOError, Path, None, Option, Some, Err, Ok, Result, Tuple2, Tuple2Impl, Type, CompileState, Definition, FunctionHeader, Parameter, FunctionSegment, ImmutableCompileState, Import, DivideState, Placeholder, Whitespace, ArrayType, BooleanType, FunctionType]
import magma.api.{ Type, Tuple2 };
import magma.api.collect.list.{ List };
import magma.api.collect.{ Joiner };
export struct FunctionType implements Type {
	mut args: List<&[I8]>;
	mut returns: &[I8];
	constructor (mut args: List<&[I8]>, mut returns: &[I8]) {
		this.args = args;
		this.returns = returns;
	}
	def generate(): &[I8] {
		let joinedArguments = this/*auto*/.args.queryWithIndices(/*auto*/).map((mut tuple: Tuple2<I32, &[I8]>) => "arg" + tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/) + " : " + tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/)).collect(Joiner(", ")).orElse("");
		return "(" + joinedArguments/*auto*/ + ") => " + this/*auto*/.returns;
	}
	def isFunctional(): Bool {
		return true/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
}
