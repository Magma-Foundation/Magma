/*[
	AccessNode, 
	Actual, 
	Argument, 
	ArrayType, 
	BooleanType, 
	Caller, 
	Characters, 
	Collector, 
	CompileState, 
	Console, 
	ConstructionCaller, 
	ConstructorHeader, 
	Definition, 
	DivideState, 
	EmptyHead, 
	Err, 
	Files, 
	FlatMapHead, 
	FunctionHeader, 
	FunctionSegment, 
	FunctionType, 
	Head, 
	HeadedQuery, 
	IOError, 
	ImmutableCompileState, 
	Import, 
	IncompleteRoot, 
	IncompleteRootSegment, 
	InvokableNode, 
	Joiner, 
	LambdaNode, 
	List, 
	ListCollector, 
	Lists, 
	Location, 
	Main, 
	MapHead, 
	Namespace, 
	None, 
	NotNode, 
	Ok, 
	OperationNode, 
	Option, 
	Parameter, 
	Path, 
	Placeholder, 
	Platform, 
	PrimitiveType, 
	Queries, 
	Query, 
	RangeHead, 
	Result, 
	SingleHead, 
	SliceType, 
	Some, 
	Source, 
	StringNode, 
	Strings, 
	SymbolNode, 
	TemplateType, 
	Tuple2, 
	Tuple2Impl, 
	Type, 
	Value, 
	VariadicType, 
	Whitespace, 
	ZipHead
]*/
import magma.api.collect.list.{ List, ListCollector };
import magma.api.io.{ Path, IOError };
import magma.api.collect.head.{ Head, MapHead, FlatMapHead, EmptyHead, ZipHead, SingleHead, HeadedQuery, RangeHead };
import magma.api.option.{ Option, None, Some };
import magma.api.collect.{ Query, Collector, Joiner, Queries };
import magma.api.{ Tuple2, Tuple2Impl, Type };
import magma.api.result.{ Result, Ok };
import jvm.api.collect.list.{ Lists };
import magma.app.io.{ Platform, Location, Source };
import magma.app.compile.define.{ Definition, FunctionHeader, Parameter };
import magma.app.compile.{ Import, CompileState, ImmutableCompileState, FunctionSegment };
import jvm.api.text.{ Strings, Characters };
import magma.app.{ Main };
import magma.app.compile.value.{ Value, Caller, ConstructorHeader, ConstructionCaller, Argument, InvokableNode, StringNode, NotNode, LambdaNode, SymbolNode, AccessNode, OperationNode };
import magma.app.compile.type.{ PrimitiveType, ArrayType, VariadicType, SliceType, BooleanType, TemplateType, FunctionType };
import jvm.api.io.{ Files, Console };
import magma.app.compile.text.{ DivideState, Whitespace, Placeholder };
export interface ListsInstance {
	static def fromArray<T>(elements: T[]): List<T>;
	static def empty<T>(): List<T>;
	static def of<T>(...elements: T[]): List<T>;
}
export interface ConsoleInstance {
	static def printErrLn(message: &[I8]): void;
}
export interface FilesInstance {
	static def get(first: &[I8], ...more: &[I8][]): Path;
}
export interface CharactersInstance {
	static def isDigit(c: I8): Bool;
	static def isLetter(c: I8): Bool;
}
export interface StringsInstance {
	static def length(stripped: &[I8]): I32;
	static def sliceBetween(input: &[I8], startInclusive: I32, endExclusive: I32): &[I8];
	static def sliceFrom(input: &[I8], startInclusive: I32): &[I8];
	static def isEmpty(cache: &[I8]): Bool;
	static def equalsTo(left: &[I8], right: &[I8]): Bool;
	static def strip(input: &[I8]): &[I8];
	static def isBlank(value: &[I8]): Bool;
	static def charAt(input: &[I8], index: I32): I8;
}
export struct Actual {
}
export struct Namespace {
}
export struct Collector<T, C> {
	def createInitial(): C;
	def fold(mut current: C, mut element: T): C;
}
export struct EmptyHead<T> implements Head<T> {
	def next(): Option<T> {
		return None<T>(/*auto*/);
	}
}
export struct FlatMapHead<T, R> implements Head<R> {
	mapper: (arg0 : T) => Query<R>;
	head: Head<T>;
	mut current: Query<R>;
	constructor (head: Head<T>, initial: Query<R>, mapper: (arg0 : T) => Query<R>) {
		this/*auto*/.head = head/*Head<T>*/;
		this/*auto*/.current = initial/*Query<R>*/;
		this/*auto*/.mapper = mapper/*(arg0 : T) => Query<R>*/;
	}
	def next(): Option<R> {
		while (true/*auto*/) {
			let next = this/*auto*/.current.next(/*auto*/);
			if (next/*(arg0 : T) => R*/(/*auto*/)) {
				return next/*(arg0 : T) => R*/;
			}
			let tuple = this/*auto*/.head.next(/*auto*/).map(this/*auto*/.mapper).toTuple(this/*auto*/.current);
			if (tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/)) {
				this/*auto*/.current = tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/);
			}
			else {
				return None<R>(/*auto*/);
			}
		}
	}
}
export struct Head<T> {
	def next(): Option<T>;
}
export struct HeadedQuery<T> implements Query<T> {
	mut head: Head<T>;
	constructor (mut head: Head<T>) {
		this.head = head;
	}
	def next(): Option<T> {
		return this/*auto*/.head.next(/*auto*/);
	}
	def collect<C>(collector: Collector<T, C>): C {
		return this/*auto*/.foldWithInitial(collector/*Collector<T, C>*/.createInitial(/*auto*/), (mut current: C, mut element: T) => collector/*Collector<T, C>*/.fold(current/*Tuple2<CompileState, List<T>>*/, element/*string*/));
	}
	def map<R>(mapper: (arg0 : T) => R): Query<R> {
		return HeadedQuery<R>(MapHead<T, R>(this/*auto*/.head, mapper/*(arg0 : T) => R*/));
	}
	def foldWithInitial<R>(initial: R, folder: (arg0 : R, arg1 : T) => R): R {
		mut let result = initial/*R*/;
		while (true/*auto*/) {
			let finalResult = result/*Tuple2<CompileState, string>*/;
			let maybeNext = this/*auto*/.head.next(/*auto*/).map((mut inner: T) => folder/*(arg0 : R, arg1 : T) => R*/(finalResult/*auto*/, inner/*auto*/)).toTuple(finalResult/*auto*/);
			if (maybeNext/*auto*/.left(/*auto*/)) {
				result/*Tuple2<CompileState, string>*/ = maybeNext/*auto*/.right(/*auto*/);
			}
			else {
				return result/*Tuple2<CompileState, string>*/;
			}
		}
	}
	def foldWithMapper<R>(next: (arg0 : T) => R, folder: (arg0 : R, arg1 : T) => R): Option<R> {
		return this/*auto*/.head.next(/*auto*/).map(next/*(arg0 : T) => R*/).map((maybeNext: R) => this/*auto*/.foldWithInitial(maybeNext/*auto*/, folder/*(arg0 : R, arg1 : T) => R*/));
	}
	def flatMap<R>(mapper: (arg0 : T) => Query<R>): Query<R> {
		return this/*auto*/.head.next(/*auto*/).map(mapper/*(arg0 : T) => Query<R>*/).map((mut initial: Query<R>) => HeadedQuery<R>(FlatMapHead<T, R>(this/*auto*/.head, initial/*R*/, mapper/*(arg0 : T) => Query<R>*/))).orElseGet(() => HeadedQuery<R>(EmptyHead<R>(/*auto*/)));
	}
	def allMatch(predicate: (arg0 : T) => boolean): Bool {
		return this/*auto*/.foldWithInitial(true/*auto*/, (mut maybeAllTrue: Bool, mut element: T) => maybeAllTrue/*auto*/ && predicate/*(arg0 : T) => boolean*/(element/*string*/));
	}
	def anyMatch(predicate: (arg0 : T) => boolean): Bool {
		return this/*auto*/.foldWithInitial(false/*auto*/, (mut aBoolean: Bool, mut t: T) => aBoolean/*auto*/ || predicate/*(arg0 : T) => boolean*/(t/*auto*/));
	}
	def zip<R>(other: Query<R>): Query<Tuple2<T, R>> {
		return HeadedQuery<Tuple2<T, R>>(ZipHead<T, R>(this/*auto*/.head, other/*Query<R>*/));
	}
	def foldWithInitialToResult<R, X>(initial: R, mapper: (arg0 : R, arg1 : T) => Result<R, X>): Result<R, X> {
		let initialResult: Result<R, X> = Ok<R, X>(initial/*R*/);
		return this/*auto*/.foldWithInitial(initialResult/*auto*/, (mut currentResult: Result<R, X>, mut element: T) => currentResult/*auto*/.flatMapValue((mut current: R) => mapper/*(arg0 : R, arg1 : T) => Result<R, X>*/(current/*Tuple2<CompileState, List<T>>*/, element/*string*/)));
	}
	def filter(predicate: (arg0 : T) => boolean): Query<T> {
		return this/*auto*/.flatMap((element: T) => {
			if (predicate/*(arg0 : T) => boolean*/(element/*T*/)) {
				return HeadedQuery<T>(SingleHead<T>(element/*T*/));
			}
			else {
				return HeadedQuery<T>(EmptyHead<T>(/*auto*/));
			}
		});
	}
}
export struct MapHead<T, R> implements Head<R> {
	mut head: Head<T>;
	mut mapper: (arg0 : T) => R;
	constructor (mut head: Head<T>, mut mapper: (arg0 : T) => R) {
		this.head = head;
		this.mapper = mapper;
	}
	def next(): Option<R> {
		return this/*auto*/.head.next(/*auto*/).map(this/*auto*/.mapper);
	}
}
export struct RangeHead implements Head<I32> {
	length: I32;
	mut counter: I32;
	constructor (length: I32) {
		this/*auto*/.length = length/*I32*/;
		this/*auto*/.counter = 0/*auto*/;
	}
	def next(): Option<I32> {
		if (this/*auto*/.counter >= this/*auto*/.length) {
			return None<I32>(/*auto*/);
		}
		let value = this/*auto*/.counter;
		this/*auto*/.counter++;
		return Some<I32>(value/*string*/);
	}
}
export struct SingleHead<T> implements Head<T> {
	element: T;
	mut retrieved: Bool;
	constructor (element: T) {
		this/*auto*/.element = element/*T*/;
		this/*auto*/.retrieved = false/*auto*/;
	}
	def next(): Option<T> {
		if (this/*auto*/.retrieved) {
			return None<T>(/*auto*/);
		}
		this/*auto*/.retrieved = true/*auto*/;
		return Some<T>(this/*auto*/.element);
	}
}
export struct ZipHead<T, R> implements Head<Tuple2<T, R>> {
	mut head: Head<T>;
	mut other: Query<R>;
	constructor (mut head: Head<T>, mut other: Query<R>) {
		this.head = head;
		this.other = other;
	}
	def next(): Option<Tuple2<T, R>> {
		return this/*auto*/.head.next(/*auto*/).and(() => this/*auto*/.other.next(/*auto*/));
	}
}
export struct Joiner implements Collector<&[I8], Option<&[I8]>> {
	mut delimiter: &[I8];
	constructor (mut delimiter: &[I8]) {
		this.delimiter = delimiter;
	}
	static def empty(): Joiner {
		return Joiner("");
	}
	static def joinOrEmpty(items: List<&[I8]>, delimiter: &[I8], prefix: &[I8], suffix: &[I8]): &[I8] {
		return items/*List<&[I8]>*/.query(/*auto*/).collect(Joiner(delimiter/*&[I8]*/)).map((mut inner: &[I8]) => prefix/*&[I8]*/ + inner/*auto*/ + suffix/*&[I8]*/).orElse("");
	}
	def createInitial(): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def fold(maybe: Option<&[I8]>, element: &[I8]): Option<&[I8]> {
		return Some<&[I8]>(maybe/*Option<&[I8]>*/.map((mut inner: &[I8]) => inner/*auto*/ + this/*auto*/.delimiter + element/*&[I8]*/).orElse(element/*&[I8]*/));
	}
}
export struct List<T> {
	def addLast(mut element: T): List<T>;
	def query(): Query<T>;
	def size(): I32;
	def subList(mut startInclusive: I32, mut endExclusive: I32): Option<List<T>>;
	def findLast(): Option<T>;
	def findFirst(): Option<T>;
	def find(mut index: I32): Option<T>;
	def queryWithIndices(): Query<Tuple2<I32, T>>;
	def addAll(mut others: List<T>): List<T>;
	def contains(mut element: T, mut equator: (arg0 : T, arg1 : T) => Bool): Bool;
	def queryReversed(): Query<T>;
	def addFirst(mut element: T): List<T>;
	def isEmpty(): Bool;
	def equalsTo(mut other: List<T>, mut equator: (arg0 : T, arg1 : T) => Bool): Bool;
	def removeValue(mut element: T, mut equator: (arg0 : T, arg1 : T) => Bool): List<T>;
	def removeLast(): Option<List<T>>;
	def sort(mut sorter: (arg0 : T, arg1 : T) => I32): List<T>;
}
export struct ListCollector<T> implements Collector<T, List<T>> {
	def createInitial(): List<T> {
		return Lists/*auto*/.empty(/*auto*/);
	}
	def fold(current: List<T>, element: T): List<T> {
		return current/*List<T>*/.addLast(element/*T*/);
	}
}
export struct Queries {
	static def fromOption<T>(option: Option<T>): Query<T> {
		return HeadedQuery<T>(option/*Option<T>*/.map((mut element: T) => Queries/*auto*/.getTSingleHead(element/*T*/)).orElseGet(() => EmptyHead<T>(/*auto*/)));
	}
	static def getTSingleHead<T>(element: T): Head<T> {
		return SingleHead<T>(element/*T*/);
	}
	static def fromArray<T>(elements: T[]): Query<T> {
		/*return new HeadedQuery<Integer>(new RangeHead(elements.length)).map((Integer index) -> elements[index])*/;
	}
}
export struct Query<T> {
	def collect<C>(mut collector: Collector<T, C>): C;
	def map<R>(mut mapper: (arg0 : T) => R): Query<R>;
	def foldWithInitial<R>(mut initial: R, mut folder: (arg0 : R, arg1 : T) => R): R;
	def foldWithMapper<R>(mut mapper: (arg0 : T) => R, mut folder: (arg0 : R, arg1 : T) => R): Option<R>;
	def flatMap<R>(mut mapper: (arg0 : T) => Query<R>): Query<R>;
	def next(): Option<T>;
	def allMatch(mut predicate: (arg0 : T) => boolean): Bool;
	def filter(mut predicate: (arg0 : T) => boolean): Query<T>;
	def anyMatch(mut predicate: (arg0 : T) => boolean): Bool;
	def zip<R>(mut other: Query<R>): Query<Tuple2<T, R>>;
	def foldWithInitialToResult<R, X>(mut initial: R, mut mapper: (arg0 : R, arg1 : T) => Result<R, X>): Result<R, X>;
}
export struct IOError {
	def display(): &[I8];
}
export struct Path {
	def asString(): &[I8];
	def writeString(mut output: &[I8]): Option<IOError>;
	def readString(): Result<&[I8], IOError>;
	def walk(): Result<List<Path>, IOError>;
	def findFileName(): &[I8];
	def endsWith(mut suffix: &[I8]): Bool;
	def relativize(mut source: Path): Path;
	def getParent(): Path;
	def query(): Query<&[I8]>;
	def resolveChildSegments(mut children: List<&[I8]>): Path;
	def resolveChild(mut name: &[I8]): Path;
	def exists(): Bool;
	def createDirectories(): Option<IOError>;
}
export struct None<T> implements Option<T> {
	def map<R>(mapper: (arg0 : T) => R): Option<R> {
		return None<R>(/*auto*/);
	}
	def orElse(other: T): T {
		return other/*T*/;
	}
	def orElseGet(supplier: () => T): T {
		return supplier/*() => T*/(/*auto*/);
	}
	def isPresent(): Bool {
		return false/*auto*/;
	}
	def ifPresent(consumer: (arg0 : T) => void): void {
	}
	def or(other: () => Option<T>): Option<T> {
		return other/*() => Option<T>*/(/*auto*/);
	}
	def flatMap<R>(mapper: (arg0 : T) => Option<R>): Option<R> {
		return None<R>(/*auto*/);
	}
	def filter(predicate: (arg0 : T) => boolean): Option<T> {
		return None<T>(/*auto*/);
	}
	def toTuple(other: T): Tuple2<Bool, T> {
		return Tuple2Impl<Bool, T>(false/*auto*/, other/*T*/);
	}
	def and<R>(other: () => Option<R>): Option<Tuple2<T, R>> {
		return None<Tuple2<T, R>>(/*auto*/);
	}
}
export struct Option<T> {
	def map<R>(mut mapper: (arg0 : T) => R): Option<R>;
	def orElse(mut other: T): T;
	def orElseGet(mut supplier: () => T): T;
	def isPresent(): Bool;
	def ifPresent(mut consumer: (arg0 : T) => void): void;
	def or(mut other: () => Option<T>): Option<T>;
	def flatMap<R>(mut mapper: (arg0 : T) => Option<R>): Option<R>;
	def filter(mut predicate: (arg0 : T) => boolean): Option<T>;
	def toTuple(mut other: T): Tuple2<Bool, T>;
	def and<R>(mut other: () => Option<R>): Option<Tuple2<T, R>>;
}
export struct Some<T> implements Option<T> {
	mut value: T;
	constructor (mut value: T) {
		this.value = value;
	}
	def map<R>(mapper: (arg0 : T) => R): Option<R> {
		return Some<R>(mapper/*(arg0 : T) => R*/(this/*auto*/.value));
	}
	def orElse(other: T): T {
		return this/*auto*/.value;
	}
	def orElseGet(supplier: () => T): T {
		return this/*auto*/.value;
	}
	def isPresent(): Bool {
		return true/*auto*/;
	}
	def ifPresent(consumer: (arg0 : T) => void): void {
		consumer/*(arg0 : T) => void*/(this/*auto*/.value);
	}
	def or(other: () => Option<T>): Option<T> {
		return this/*auto*/;
	}
	def flatMap<R>(mapper: (arg0 : T) => Option<R>): Option<R> {
		return mapper/*(arg0 : T) => Option<R>*/(this/*auto*/.value);
	}
	def filter(predicate: (arg0 : T) => boolean): Option<T> {
		if (predicate/*(arg0 : T) => boolean*/(this/*auto*/.value)) {
			return this/*auto*/;
		}
		return None<T>(/*auto*/);
	}
	def toTuple(other: T): Tuple2<Bool, T> {
		return Tuple2Impl<Bool, T>(true/*auto*/, this/*auto*/.value);
	}
	def and<R>(other: () => Option<R>): Option<Tuple2<T, R>> {
		return other/*() => Option<R>*/(/*auto*/).map((mut otherValue: R) => Tuple2Impl<T, R>(this/*auto*/.value, otherValue/*auto*/));
	}
}
export struct Err<T, X> implements Result<T, X> {
	mut error: X;
	constructor (mut error: X) {
		this.error = error;
	}
	def findError(): Option<X> {
		return Some<X>(this/*auto*/.error);
	}
	def findValue(): Option<T> {
		return None<T>(/*auto*/);
	}
	def match<R>(whenOk: (arg0 : T) => R, whenErr: (arg0 : X) => R): R {
		return whenErr/*(arg0 : X) => R*/(this/*auto*/.error);
	}
	def flatMapValue<R>(mapper: (arg0 : T) => Result<R, X>): Result<R, X> {
		return Err<>(this/*auto*/.error);
	}
	def mapValue<R>(mapper: (arg0 : T) => R): Result<R, X> {
		return Err<>(this/*auto*/.error);
	}
}
export struct Ok<T, X> implements Result<T, X> {
	mut value: T;
	constructor (mut value: T) {
		this.value = value;
	}
	def findError(): Option<X> {
		return None<X>(/*auto*/);
	}
	def findValue(): Option<T> {
		return Some<T>(this/*auto*/.value);
	}
	def match<R>(whenOk: (arg0 : T) => R, whenErr: (arg0 : X) => R): R {
		return whenOk/*(arg0 : T) => R*/(this/*auto*/.value);
	}
	def flatMapValue<R>(mapper: (arg0 : T) => Result<R, X>): Result<R, X> {
		return mapper/*(arg0 : T) => Result<R, X>*/(this/*auto*/.value);
	}
	def mapValue<R>(mapper: (arg0 : T) => R): Result<R, X> {
		return Ok<>(mapper/*(arg0 : T) => R*/(this/*auto*/.value));
	}
}
export struct Result<T, X> {
	def findError(): Option<X>;
	def findValue(): Option<T>;
	def match<R>(mut whenOk: (arg0 : T) => R, mut whenErr: (arg0 : X) => R): R;
	def flatMapValue<R>(mut mapper: (arg0 : T) => Result<R, X>): Result<R, X>;
	def mapValue<R>(mut mapper: (arg0 : T) => R): Result<R, X>;
}
export struct Tuple2<A, B> {
	def left(): A;
	def right(): B;
}
export struct Tuple2Impl<A, B> implements Tuple2<A, B> {
	mut leftValue: A;
	mut rightValue: B;
	constructor (mut leftValue: A, mut rightValue: B) {
		this.leftValue = leftValue;
		this.rightValue = rightValue;
	}
	def left(): A {
		return this/*auto*/.leftValue;
	}
	def right(): B {
		return this/*auto*/.rightValue;
	}
}
export struct Type {
	def generate(): &[I8];
	def isFunctional(): Bool;
	def isVar(): Bool;
	def generateBeforeName(): &[I8];
}
export struct CompileState {
	def functionName(): &[I8];
	def findLastStructureName(): Option<&[I8]>;
	def createIndent(): &[I8];
	def isPlatform(mut platform: Platform): Bool;
	def hasLastStructureNameOf(mut name: &[I8]): Bool;
	def addResolvedImportFromCache(mut base: &[I8]): CompileState;
	def addResolvedImportWithNamespace(mut namespace: List<&[I8]>, mut child: &[I8]): CompileState;
	def withLocation(mut namespace: Location): CompileState;
	def append(mut element: &[I8]): CompileState;
	def pushStructureName(mut name: &[I8]): CompileState;
	def enterDepth(): CompileState;
	def exitDepth(): CompileState;
	def defineAll(mut definitions: List<Definition>): CompileState;
	def resolve(mut name: &[I8]): Option<Type>;
	def clearImports(): CompileState;
	def clearGenerated(): CompileState;
	def addSource(mut source: Source): CompileState;
	def findSource(mut name: &[I8]): Option<Source>;
	def popStructureName(): CompileState;
	def mapLocation(mut mapper: (arg0 : Location) => Location): CompileState;
	def withPlatform(mut platform: Platform): CompileState;
	def imports(): List<Import>;
	def join(): &[I8];
	def findCurrentLocation(): Option<Location>;
	def platform(): Platform;
	def addFunction(mut function: &[I8]): CompileState;
	def findDefinedTypes(): List<&[I8]>;
	def defineType(mut name: &[I8]): CompileState;
	def clearDefinedTypes(): CompileState;
}
export struct Definition {
	mut annotations: List<&[I8]>;
	mut modifiers: List<&[I8]>;
	mut typeParams: List<&[I8]>;
	mut type: Type;
	mut name: &[I8];
	constructor (mut annotations: List<&[I8]>, mut modifiers: List<&[I8]>, mut typeParams: List<&[I8]>, mut type: Type, mut name: &[I8]) {
		this.annotations = annotations;
		this.modifiers = modifiers;
		this.typeParams = typeParams;
		this.type = type;
		this.name = name;
	}
	constructor (type: Type, name: &[I8]) {
		this/*auto*/(Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), type/*Type*/, name/*&[I8]*/);
	}
	def generate(platform: Platform): &[I8] {
		return this/*auto*/.generateWithAfterName(platform/*Platform*/, "");
	}
	def asDefinition(): Option<Definition> {
		return Some<Definition>(this/*auto*/);
	}
	def generateWithAfterName(platform: Platform, afterName: &[I8]): &[I8] {
		let joinedTypeParams = this/*auto*/.joinTypeParams(/*auto*/);
		let joinedModifiers = this/*auto*/.joinModifiers(/*auto*/);
		if (Platform/*auto*/.Windows === platform/*Platform*/) {
			return joinedModifiers/*string*/ + this/*auto*/.type.generateBeforeName(/*auto*/) + this/*auto*/.type.generate(/*auto*/) + " " + this/*auto*/.name + afterName/*&[I8]*/;
		}
		return joinedModifiers/*string*/ + this/*auto*/.type.generateBeforeName(/*auto*/) + this/*auto*/.name + joinedTypeParams/*string*/ + afterName/*&[I8]*/ + this/*auto*/.generateType(/*auto*/);
	}
	def joinModifiers(): &[I8] {
		return this/*auto*/.modifiers.query(/*auto*/).map((mut value: &[I8]) => value/*string*/ + " ").collect(Joiner("")).orElse("");
	}
	def generateType(): &[I8] {
		if (this/*auto*/.type.isVar(/*auto*/)) {
			return "";
		}
		return ": " + this/*auto*/.type.generate(/*auto*/);
	}
	def joinTypeParams(): &[I8] {
		return Joiner/*auto*/.joinOrEmpty(this/*auto*/.typeParams, ", ", "<", ">");
	}
	def hasAnnotation(annotation: &[I8]): Bool {
		return this/*auto*/.annotations.contains(annotation/*&[I8]*/, Strings/*auto*/.equalsTo);
	}
	def removeModifier(modifier: &[I8]): Definition {
		return Definition(this/*auto*/.annotations, this/*auto*/.modifiers.removeValue(modifier/*&[I8]*/, Strings/*auto*/.equalsTo), this/*auto*/.typeParams, this/*auto*/.type, this/*auto*/.name);
	}
	def addModifierLast(modifier: &[I8]): Definition {
		return Definition(this/*auto*/.annotations, this/*auto*/.modifiers.addLast(modifier/*&[I8]*/), this/*auto*/.typeParams, this/*auto*/.type, this/*auto*/.name);
	}
	def generateWithDefinitions(platform: Platform, definitions: List<Definition>): &[I8] {
		let joinedDefinitions = definitions/*List<Definition>*/.query(/*auto*/).map((mut definition: Definition) => definition/*Definition*/.generate(platform/*Platform*/)).collect(Joiner(", ")).orElse("");
		return this/*auto*/.generateWithAfterName(platform/*Platform*/, "(" + joinedDefinitions/*auto*/ + ")");
	}
}
export struct FunctionHeader<S extends FunctionHeader<S>> {
	def generateWithDefinitions(mut platform: Platform, mut definitions: List<Definition>): &[I8];
	def hasAnnotation(mut annotation: &[I8]): Bool;
	def removeModifier(mut modifier: &[I8]): S;
	def addModifierLast(mut modifier: &[I8]): S;
}
export struct Parameter {
	def generate(mut platform: Platform): &[I8];
	def asDefinition(): Option<Definition>;
}
export struct FunctionSegment<S extends FunctionHeader<S>> {
	mut header: FunctionHeader<S>;
	mut definitions: List<Definition>;
	mut maybeContent: Option<&[I8]>;
	constructor (mut header: FunctionHeader<S>, mut definitions: List<Definition>, mut maybeContent: Option<&[I8]>) {
		this.header = header;
		this.definitions = definitions;
		this.maybeContent = maybeContent;
	}
	def generate(platform: Platform, indent: &[I8]): &[I8] {
		let content = this/*auto*/.maybeContent(/*auto*/).map((mut inner: &[I8]) => " {" + inner/*auto*/ + indent/*&[I8]*/ + "}").orElse(";");
		return indent/*&[I8]*/ + this/*auto*/.header.generateWithDefinitions(platform/*Platform*/, this/*auto*/.definitions(/*auto*/)) + content/*string*/;
	}
}
export struct ImmutableCompileState implements CompileState {
	mut platform: Platform;
	mut findCurrentLocation: Option<Location>;
	mut sources: List<Source>;
	mut imports: List<Import>;
	mut structureNames: List<&[I8]>;
	mut structures: &[I8];
	mut functions: &[I8];
	mut definitions: List<Definition>;
	mut depth: I32;
	mut definedTypes: List<&[I8]>;
	constructor (mut platform: Platform, mut findCurrentLocation: Option<Location>, mut sources: List<Source>, mut imports: List<Import>, mut structureNames: List<&[I8]>, mut structures: &[I8], mut functions: &[I8], mut definitions: List<Definition>, mut depth: I32, mut definedTypes: List<&[I8]>) {
		this.platform = platform;
		this.findCurrentLocation = findCurrentLocation;
		this.sources = sources;
		this.imports = imports;
		this.structureNames = structureNames;
		this.structures = structures;
		this.functions = functions;
		this.definitions = definitions;
		this.depth = depth;
		this.definedTypes = definedTypes;
	}
	static def createInitial(): CompileState {
		return ImmutableCompileState(Platform/*auto*/.Magma, None<Location>(/*auto*/), Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), "", "", Lists/*auto*/.empty(/*auto*/), 0/*auto*/, Lists/*auto*/.empty(/*auto*/));
	}
	def hasLastStructureNameOf(name: &[I8]): Bool {
		return this/*auto*/.structureNames.findLast(/*auto*/).filter((mut anObject: &[I8]) => Strings/*auto*/.equalsTo(name/*&[I8]*/, anObject/*auto*/)).isPresent(/*auto*/);
	}
	def withLocation(namespace: Location): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, Some<Location>(namespace/*Location*/), this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def append(element: &[I8]): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures + element/*&[I8]*/, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def pushStructureName(name: &[I8]): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames.addLast(name/*&[I8]*/), this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def enterDepth(): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth + 1/*auto*/, this/*auto*/.definedTypes);
	}
	def exitDepth(): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth - 1/*auto*/, this/*auto*/.definedTypes);
	}
	def defineAll(definitions: List<Definition>): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions.addAll(definitions/*List<Definition>*/), this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def resolve(name: &[I8]): Option<Type> {
		return this/*auto*/.definitions.queryReversed(/*auto*/).filter((mut definition: Definition) => Strings/*auto*/.equalsTo(definition/*Definition*/.name(/*auto*/), name/*&[I8]*/)).map((mut definition1: Definition) => definition1/*auto*/.type(/*auto*/)).next(/*auto*/);
	}
	def clearImports(): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, Lists/*auto*/.empty(/*auto*/), this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def clearGenerated(): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, "", "", this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def addSource(source: Source): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources.addLast(source/*Source*/), this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def addResolvedImportFromCache(base: &[I8]): CompileState {
		if (this/*auto*/.structureNames.query(/*auto*/).anyMatch((mut inner: &[I8]) => Strings/*auto*/.equalsTo(inner/*auto*/, base/*&[I8]*/))) {
			return this/*auto*/;
		}
		return this/*auto*/.findSource(base/*&[I8]*/).map((mut source: Source) => this/*auto*/.addResolvedImportWithNamespace(source/*Source*/.computeNamespace(/*auto*/), source/*Source*/.computeName(/*auto*/))).orElse(this/*auto*/);
	}
	def popStructureName(): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames.removeLast(/*auto*/).orElse(this/*auto*/.structureNames), this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def mapLocation(mapper: (arg0 : Location) => Location): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation.map(mapper/*(arg0 : Location) => Location*/), this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def withPlatform(platform: Platform): CompileState {
		return ImmutableCompileState(platform/*Platform*/, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def addFunction(function: &[I8]): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions + function/*&[I8]*/, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def findDefinedTypes(): List<&[I8]> {
		return this/*auto*/.definedTypes;
	}
	def defineType(name: &[I8]): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes.addLast(name/*&[I8]*/));
	}
	def clearDefinedTypes(): CompileState {
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports, this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, Lists/*auto*/.empty(/*auto*/));
	}
	def join(): &[I8] {
		return this/*auto*/.structures + this/*auto*/.functions;
	}
	def addResolvedImportWithNamespace(oldParent: List<&[I8]>, child: &[I8]): CompileState {
		let namespace = this/*auto*/.findCurrentLocation.map((mut location: Location) => location/*Location*/.namespace(/*auto*/)).orElse(Lists/*auto*/.empty(/*auto*/));
		mut let newParent = oldParent/*List<&[I8]>*/;
		if (Platform/*auto*/.TypeScript === this/*auto*/.platform) {
			if (namespace/*Location*/.isEmpty(/*auto*/)) {
				newParent/*auto*/ = newParent/*auto*/.addFirst(".");
			}
			mut let i = 0/*auto*/;
			let size = namespace/*Location*/.size(/*auto*/);
			while (i/*auto*/ < size/*auto*/) {
				newParent/*auto*/ = newParent/*auto*/.addFirst("..");
				i/*auto*/++;
			}
		}
		if (this/*auto*/.imports.query(/*auto*/).filter((mut node: Import) => Strings/*auto*/.equalsTo(node/*auto*/.child(/*auto*/), child/*&[I8]*/)).next(/*auto*/).isPresent(/*auto*/)) {
			return this/*auto*/;
		}
		let importString = Import(newParent/*auto*/, child/*&[I8]*/);
		return ImmutableCompileState(this/*auto*/.platform, this/*auto*/.findCurrentLocation, this/*auto*/.sources, this/*auto*/.imports.addLast(importString/*auto*/), this/*auto*/.structureNames, this/*auto*/.structures, this/*auto*/.functions, this/*auto*/.definitions, this/*auto*/.depth, this/*auto*/.definedTypes);
	}
	def findSource(name: &[I8]): Option<Source> {
		return this/*auto*/.sources.query(/*auto*/).filter((mut source: Source) => Strings/*auto*/.equalsTo(source/*Source*/.computeName(/*auto*/), name/*&[I8]*/)).next(/*auto*/);
	}
	def isPlatform(platform: Platform): Bool {
		return platform/*Platform*/ === this/*auto*/.platform(/*auto*/);
	}
	def createIndent(): &[I8] {
		let indent = this/*auto*/.depth(/*auto*/);
		return "\n" + "\t".repeat(indent/*&[I8]*/);
	}
	def functionName(): &[I8] {
		return "temp";
	}
	def findLastStructureName(): Option<&[I8]> {
		return this/*auto*/.structureNames(/*auto*/).findLast(/*auto*/);
	}
}
export struct Import {
	mut namespace: List<&[I8]>;
	mut child: &[I8];
	constructor (mut namespace: List<&[I8]>, mut child: &[I8]) {
		this.namespace = namespace;
		this.child = child;
	}
	def generate(platform: Platform): &[I8] {
		if (Platform/*auto*/.Magma === platform/*Platform*/) {
			let joinedNamespace = this/*auto*/.namespace.query(/*auto*/).collect(Joiner(".")).orElse("");
			return "import " + joinedNamespace/*auto*/ + "." + this/*auto*/.child + ";\n";
		}
		let joinedNamespace = this/*auto*/.namespace.addLast(this/*auto*/.child).query(/*auto*/).collect(Joiner("/")).orElse("");
		return "import { " + this/*auto*/.child + " } from \"" + joinedNamespace/*auto*/ + "\";\n";
	}
}
export struct DivideState {
	mut segments: List<&[I8]>;
	mut buffer: &[I8];
	mut depth: I32;
	mut input: &[I8];
	mut index: I32;
	constructor (mut segments: List<&[I8]>, mut buffer: &[I8], mut depth: I32, mut input: &[I8], mut index: I32) {
		this.segments = segments;
		this.buffer = buffer;
		this.depth = depth;
		this.input = input;
		this.index = index;
	}
	static def createInitial(input: &[I8]): DivideState {
		return DivideState(Lists/*auto*/.empty(/*auto*/), "", 0/*auto*/, input/*&[I8]*/, 0/*auto*/);
	}
	def advance(): DivideState {
		return DivideState(this/*auto*/.segments.addLast(this/*auto*/.buffer), "", this/*auto*/.depth, this/*auto*/.input, this/*auto*/.index);
	}
	def append(c: I8): DivideState {
		return DivideState(this/*auto*/.segments, this/*auto*/.buffer + c/*I8*/, this/*auto*/.depth, this/*auto*/.input, this/*auto*/.index);
	}
	def isLevel(): Bool {
		return 0/*auto*/ === this/*auto*/.depth;
	}
	def enter(): DivideState {
		return DivideState(this/*auto*/.segments, this/*auto*/.buffer, this/*auto*/.depth + 1/*auto*/, this/*auto*/.input, this/*auto*/.index);
	}
	def exit(): DivideState {
		return DivideState(this/*auto*/.segments, this/*auto*/.buffer, this/*auto*/.depth - 1/*auto*/, this/*auto*/.input, this/*auto*/.index);
	}
	def isShallow(): Bool {
		return 1/*auto*/ === this/*auto*/.depth;
	}
	def pop(): Option<Tuple2<DivideState, I8>> {
		if (this/*auto*/.index >= Strings/*auto*/.length(this/*auto*/.input)) {
			return None<Tuple2<DivideState, I8>>(/*auto*/);
		}
		let c = Strings/*auto*/.charAt(this/*auto*/.input, this/*auto*/.index);
		let nextState = DivideState(this/*auto*/.segments, this/*auto*/.buffer, this/*auto*/.depth, this/*auto*/.input, this/*auto*/.index + 1/*auto*/);
		return Some<Tuple2<DivideState, I8>>(Tuple2Impl<DivideState, I8>(nextState/*auto*/, c/*I8*/));
	}
	def popAndAppendToTuple(): Option<Tuple2<DivideState, I8>> {
		return this/*auto*/.pop(/*auto*/).map((mut inner: Tuple2<DivideState, I8>) => Tuple2Impl<DivideState, I8>(inner/*auto*/.left(/*auto*/).append(inner/*auto*/.right(/*auto*/)), inner/*auto*/.right(/*auto*/)));
	}
	def popAndAppendToOption(): Option<DivideState> {
		return this/*auto*/.popAndAppendToTuple(/*auto*/).map((mut tuple: Tuple2<DivideState, I8>) => tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/));
	}
	def peek(): I8 {
		return Strings/*auto*/.charAt(this/*auto*/.input, this/*auto*/.index);
	}
	def startsWith(slice: &[I8]): Bool {
		return Strings/*auto*/.sliceFrom(this/*auto*/.input, this/*auto*/.index).startsWith(slice/*&[I8]*/);
	}
}
export struct Placeholder {
	mut input: &[I8];
	constructor (mut input: &[I8]) {
		this.input = input;
	}
	def generate(): &[I8] {
		return Main/*auto*/.generatePlaceholder(this/*auto*/.input);
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def generate(platform: Platform): &[I8] {
		return this/*auto*/.generate(/*auto*/);
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def asDefinition(): Option<Definition> {
		return None<Definition>(/*auto*/);
	}
	def toValue(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def type(): Type {
		return PrimitiveType/*auto*/.Auto;
	}
}
export struct Whitespace implements Parameter {
	def generate(mut platform: Platform): &[I8] {
		return "";
	}
	def asDefinition(): Option<Definition> {
		return None<Definition>(/*auto*/);
	}
}
export struct ArrayType implements Type {
	mut child: Type;
	constructor (mut child: Type) {
		this.child = child;
	}
	def generate(): &[I8] {
		return this/*auto*/.child.generate(/*auto*/) + "[]";
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
}
export struct BooleanType implements Type {
	mut platform: Platform;
	constructor (mut platform: Platform) {
		this.platform = platform;
	}
	def generate(): &[I8] {
		if (Platform/*auto*/.TypeScript === this/*auto*/.platform) {
			return "boolean";
		}
		return "Bool";
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
}
export struct FunctionType implements Type {
	mut args: List<&[I8]>;
	mut returns: &[I8];
	constructor (mut args: List<&[I8]>, mut returns: &[I8]) {
		this.args = args;
		this.returns = returns;
	}
	def generate(): &[I8] {
		let joinedArguments = this/*auto*/.args.queryWithIndices(/*auto*/).map((mut tuple: Tuple2<I32, &[I8]>) => "arg" + tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/) + " : " + tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/)).collect(Joiner(", ")).orElse("");
		return "(" + joinedArguments/*auto*/ + ") => " + this/*auto*/.returns;
	}
	def isFunctional(): Bool {
		return true/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
}
export struct PrimitiveType implements Type {
	static String/*auto*/: PrimitiveType = new PrimitiveType("string");
	static Number/*auto*/: PrimitiveType = new PrimitiveType("number");
	static Var/*auto*/: PrimitiveType = new PrimitiveType("var");
	static Void/*auto*/: PrimitiveType = new PrimitiveType("void");
	static Auto/*auto*/: PrimitiveType = new PrimitiveType("auto");
	static I8/*auto*/: PrimitiveType = new PrimitiveType("I8");
	static I32/*auto*/: PrimitiveType = new PrimitiveType("I32");
	value: &[I8];
	constructor (value: &[I8]) {
		this/*auto*/.value = value/*&[I8]*/;
	}
	def generate(): &[I8] {
		return this/*auto*/.value;
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def isVar(): Bool {
		return PrimitiveType/*auto*/.Var === this/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
}
export struct SliceType implements Type {
	mut type: Type;
	constructor (mut type: Type) {
		this.type = type;
	}
	def generate(): &[I8] {
		return "&[" + this/*auto*/.type.generate(/*auto*/) + "]";
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
}
export struct TemplateType implements Type {
	mut base: &[I8];
	mut args: List<&[I8]>;
	constructor (mut base: &[I8], mut args: List<&[I8]>) {
		this.base = base;
		this.args = args;
	}
	static def generateValueStrings(values: List<&[I8]>): &[I8] {
		return Main/*auto*/.generateAll(values/*List<&[I8]>*/, TemplateType/*auto*/.mergeValues);
	}
	static def mergeValues(cache: &[I8], element: &[I8]): &[I8] {
		if (Strings/*auto*/.isEmpty(cache/*&[I8]*/)) {
			return cache/*&[I8]*/ + element/*&[I8]*/;
		}
		return cache/*&[I8]*/ + ", " + element/*&[I8]*/;
	}
	def generate(): &[I8] {
		return this/*auto*/.base + "<" + TemplateType/*auto*/.generateValueStrings(this/*auto*/.args) + ">";
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
}
export struct VariadicType implements Type {
	mut type: Type;
	constructor (mut type: Type) {
		this.type = type;
	}
	def generate(): &[I8] {
		return this/*auto*/.type.generate(/*auto*/) + "[]";
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "...";
	}
}
export struct AccessNode implements Value {
	mut child: Value;
	mut property: &[I8];
	constructor (mut child: Value, mut property: &[I8]) {
		this.child = child;
		this.property = property;
	}
	def generate(mut platform: Platform): &[I8] {
		return this/*auto*/.child.generate(platform/*Platform*/) + "." + this/*auto*/.property;
	}
	def toValue(): Option<Value> {
		return Some<Value>(this/*auto*/);
	}
	def findChild(): Option<Value> {
		return Some<Value>(this/*auto*/.child);
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def type(): Type {
		return PrimitiveType/*auto*/.Auto;
	}
}
export struct Argument {
	def toValue(): Option<Value>;
}
export struct Caller {
	def generate(mut platform: Platform): &[I8];
	def findChild(): Option<Value>;
}
export struct ConstructionCaller implements Caller {
	mut right: &[I8];
	mut platform: Platform;
	constructor (mut right: &[I8], mut platform: Platform) {
		this.right = right;
		this.platform = platform;
	}
	def generate(mut platform: Platform): &[I8] {
		if (Platform/*auto*/.Magma === this/*auto*/.platform) {
			return this/*auto*/.right;
		}
		return "new " + this/*auto*/.right;
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
}
export struct ConstructorHeader implements FunctionHeader<ConstructorHeader> {
	def generateWithAfterName(mut platform: Platform, afterName: &[I8]): &[I8] {
		return "constructor " + afterName/*&[I8]*/;
	}
	def hasAnnotation(annotation: &[I8]): Bool {
		return false/*auto*/;
	}
	def removeModifier(modifier: &[I8]): ConstructorHeader {
		return this/*auto*/;
	}
	def addModifierLast(modifier: &[I8]): ConstructorHeader {
		return this/*auto*/;
	}
	def generateWithDefinitions0(mut platform: Platform, mut definitions: &[I8]): &[I8] {
		return generateWithAfterName/*auto*/(platform/*Platform*/, "(" + definitions/*&[I8]*/ + ")");
	}
	def generateWithDefinitions(platform: Platform, definitions: List<Definition>): &[I8] {
		let joinedDefinitions = definitions/*List<Definition>*/.query(/*auto*/).map((mut definition: Definition) => definition/*Definition*/.generate(platform/*Platform*/)).collect(Joiner(", ")).orElse("");
		return this/*auto*/.generateWithDefinitions0(platform/*Platform*/, joinedDefinitions/*auto*/);
	}
}
export struct InvokableNode implements Value {
	mut caller: Caller;
	mut args: List<Value>;
	constructor (mut caller: Caller, mut args: List<Value>) {
		this.caller = caller;
		this.args = args;
	}
	def generate(platform: Platform): &[I8] {
		let joinedArguments = this/*auto*/.joinArgs(platform/*Platform*/);
		return this/*auto*/.caller.generate(platform/*Platform*/) + "(" + joinedArguments/*auto*/ + ")";
	}
	def joinArgs(platform: Platform): &[I8] {
		return this/*auto*/.args.query(/*auto*/).map((mut value: Value) => value/*&[I8]*/.generate(platform/*Platform*/)).collect(Joiner(", ")).orElse("");
	}
	def toValue(): Option<Value> {
		return Some<Value>(this/*auto*/);
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return Some<&[I8]>("\n\tstatic " + this/*auto*/.caller.generate(platform/*Platform*/) + ": " + structureName/*&[I8]*/ + " = new " + structureName/*&[I8]*/ + "(" + this/*auto*/.joinArgs(platform/*Platform*/) + ");");
	}
	def type(): Type {
		return PrimitiveType/*auto*/.Auto;
	}
}
export struct LambdaNode implements Value {
	mut paramNames: List<Definition>;
	mut content: &[I8];
	constructor (mut paramNames: List<Definition>, mut content: &[I8]) {
		this.paramNames = paramNames;
		this.content = content;
	}
	def generate(mut platform: Platform): &[I8] {
		let joinedParamNames = this/*auto*/.paramNames.query(/*auto*/).map((mut definition: Definition) => definition/*Definition*/.generate(platform/*Platform*/)).collect(Joiner(", ")).orElse("");
		return "(" + joinedParamNames/*auto*/ + ")" + " => " + this/*auto*/.content;
	}
	def toValue(): Option<Value> {
		return Some<Value>(this/*auto*/);
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def type(): Type {
		return PrimitiveType/*auto*/.Auto;
	}
}
export struct NotNode implements Value {
	mut child: &[I8];
	constructor (mut child: &[I8]) {
		this.child = child;
	}
	def generate(mut platform: Platform): &[I8] {
		return this/*auto*/.child;
	}
	def toValue(): Option<Value> {
		return Some<Value>(this/*auto*/);
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def type(): Type {
		return PrimitiveType/*auto*/.Auto;
	}
}
export struct OperationNode implements Value {
	mut left: Value;
	mut targetInfix: &[I8];
	mut right: Value;
	constructor (mut left: Value, mut targetInfix: &[I8], mut right: Value) {
		this.left = left;
		this.targetInfix = targetInfix;
		this.right = right;
	}
	def generate(mut platform: Platform): &[I8] {
		return this/*auto*/.left.generate(platform/*Platform*/) + " " + this/*auto*/.targetInfix + " " + this/*auto*/.right.generate(platform/*Platform*/);
	}
	def toValue(): Option<Value> {
		return Some<Value>(this/*auto*/);
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def type(): Type {
		return PrimitiveType/*auto*/.Auto;
	}
}
export struct StringNode implements Value {
	mut value: &[I8];
	constructor (mut value: &[I8]) {
		this.value = value;
	}
	def generate(mut platform: Platform): &[I8] {
		return "\"" + this/*auto*/.value + "\"";
	}
	def toValue(): Option<Value> {
		return Some<Value>(this/*auto*/);
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
	def type(): Type {
		return PrimitiveType/*auto*/.Auto;
	}
}
export struct SymbolNode {
	mut value: &[I8];
	mut type: Type;
	constructor (mut value: &[I8], mut type: Type) {
		this.value = value;
		this.type = type;
	}
	def generate(platform: Platform): &[I8] {
		return this/*auto*/.value + Main/*auto*/.generatePlaceholder(type/*Type*/.generate(/*auto*/));
	}
	def toValue(): Option<Value> {
		return Some<Value>(this/*auto*/);
	}
	def findChild(): Option<Value> {
		return None<Value>(/*auto*/);
	}
	def generate(): &[I8] {
		return this/*auto*/.value;
	}
	def isFunctional(): Bool {
		return false/*auto*/;
	}
	def isVar(): Bool {
		return false/*auto*/;
	}
	def generateBeforeName(): &[I8] {
		return "";
	}
	def generateAsEnumValue(structureName: &[I8], mut platform: Platform): Option<&[I8]> {
		return None<&[I8]>(/*auto*/);
	}
}
export struct Value extends Argument, Caller  {
	def generateAsEnumValue(mut structureName: &[I8], mut platform: Platform): Option<&[I8]>;
	def type(): Type;
}
export struct Location {
	mut namespace: List<&[I8]>;
	mut name: &[I8];
	constructor (mut namespace: List<&[I8]>, mut name: &[I8]) {
		this.namespace = namespace;
		this.name = name;
	}
}
export struct Platform {
	static TypeScript/*auto*/: Platform = new Platform("node", "ts");
	static Magma/*auto*/: Platform = new Platform("magma", "mgs");
	static Windows/*auto*/: Platform = new Platform("windows", "h", "c");
	root: &[I8];
	extension: &[I8][];
	constructor (root: &[I8], ...extensions: &[I8][]) {
		this/*auto*/.root = root/*&[I8]*/;
		this/*auto*/.extension = extensions/*&[I8][]*/;
	}
}
export struct Source {
	mut sourceDirectory: Path;
	mut source: Path;
	constructor (mut sourceDirectory: Path, mut source: Path) {
		this.sourceDirectory = sourceDirectory;
		this.source = source;
	}
	def read(): Result<&[I8], IOError> {
		return this/*auto*/.source.readString(/*auto*/);
	}
	def computeName(): &[I8] {
		let fileName = this/*auto*/.source.findFileName(/*auto*/);
		let separator = fileName/*auto*/.lastIndexOf(".");
		return fileName/*auto*/.substring(0/*auto*/, separator/*auto*/);
	}
	def computeNamespace(): List<&[I8]> {
		return this/*auto*/.sourceDirectory.relativize(this/*auto*/.source).getParent(/*auto*/).query(/*auto*/).collect(ListCollector<&[I8]>(/*auto*/));
	}
	def computeLocation(): Location {
		return Location(this/*auto*/.computeNamespace(/*auto*/), this/*auto*/.computeName(/*auto*/));
	}
}
struct IncompleteRoot {
	mut location: Location;
	mut outputsByExtensions: List<IncompleteRootSegment>;
	constructor (mut location: Location, mut outputsByExtensions: List<IncompleteRootSegment>) {
		this.location = location;
		this.outputsByExtensions = outputsByExtensions;
	}
}
struct IncompleteRootSegment {
	mut value: &[I8];
	constructor (mut value: &[I8]) {
		this.value = value;
	}
}
export struct Main {
	static def main(): void {
		let sourceDirectory = Files/*auto*/.get(".", "src", "java");
		sourceDirectory/*Path*/.walk(/*auto*/).match((mut children: List<Path>) => Main/*auto*/.runWithSources(Main/*auto*/.findSources(children/*List<Path>*/, sourceDirectory/*Path*/)), (mut value: IOError) => Some<IOError>(value/*&[I8]*/)).map((mut error: IOError) => error/*auto*/.display(/*auto*/)).ifPresent((mut displayed: &[I8]) => Console/*auto*/.printErrLn(displayed/*auto*/));
	}
	static def runWithSources(sources: List<Source>): Option<IOError> {
		return Queries/*auto*/.fromArray(Platform/*auto*/.values(/*auto*/)).foldWithInitialToResult(Main/*auto*/.createInitialState(sources/*List<Source>*/), (mut current1: CompileState, mut platform: Platform) => Main/*auto*/.runWithPlatform(current1/*auto*/, platform/*Platform*/, sources/*List<Source>*/)).findError(/*auto*/);
	}
	static def runWithPlatform(initial: CompileState, platform: Platform, sources: List<Source>): Result<CompileState, IOError> {
		/*final Tuple2<CompileState, List<IncompleteRoot>> compileStateListTuple2*/;
		compileStateListTuple2/*auto*/ = Tuple2Impl<CompileState, List<IncompleteRoot>>(initial/*CompileState*/.clearDefinedTypes(/*auto*/), Lists/*auto*/.empty(/*auto*/));
		return sources/*List<Source>*/.query(/*auto*/).foldWithInitialToResult(compileStateListTuple2/*auto*/, (mut tuple: Tuple2<CompileState, List<IncompleteRoot>>, mut source: Source) => Main/*auto*/.foldWithInput(platform/*Platform*/, tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/), tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/), source/*Source*/)).flatMapValue((mut result: Tuple2<CompileState, List<IncompleteRoot>>) => Main/*auto*/.completeAll(platform/*Platform*/, result/*Tuple2<CompileState, string>*/.left(/*auto*/), result/*Tuple2<CompileState, string>*/.right(/*auto*/)));
	}
	static def completeAll(platform: Platform, state: CompileState, incomplete: List<IncompleteRoot>): Result<CompileState, IOError> {
		return incomplete/*List<IncompleteRoot>*/.query(/*auto*/).foldWithInitialToResult(state/*CompileState*/, (mut current: CompileState, mut incompleteRoot: IncompleteRoot) => Main/*auto*/.complete(current/*List<T>*/, incompleteRoot/*auto*/, platform/*Platform*/));
	}
	static def foldWithInput(platform: Platform, state: CompileState, incomplete: List<IncompleteRoot>, source: Source): Result<Tuple2<CompileState, List<IncompleteRoot>>, IOError> {
		return Main/*auto*/.runWithInput(state/*CompileState*/, platform/*Platform*/, source/*Source*/).mapValue((result: Tuple2<CompileState, IncompleteRoot>) => {
			return Tuple2Impl<>(result/*Tuple2<CompileState, IncompleteRoot>*/.left(/*auto*/), incomplete/*List<IncompleteRoot>*/.addLast(result/*Tuple2<CompileState, IncompleteRoot>*/.right(/*auto*/)));
		});
	}
	static def runWithInput(state: CompileState, platform: Platform, source: Source): Result<Tuple2<CompileState, IncompleteRoot>, IOError> {
		return source/*Source*/.read(/*auto*/).mapValue((input: &[I8]) => {
			return Main/*auto*/.prepareRoot(state/*CompileState*/, source/*Source*/, input/*&[I8]*/, platform/*Platform*/);
		});
	}
	static def createInitialState(sources: List<Source>): CompileState {
		return sources/*List<Source>*/.query(/*auto*/).foldWithInitial(ImmutableCompileState/*auto*/.createInitial(/*auto*/), (mut state: CompileState, mut source: Source) => state/*CompileState*/.addSource(source/*Source*/));
	}
	static def findSources(children: List<Path>, sourceDirectory: Path): List<Source> {
		return children/*List<Path>*/.query(/*auto*/).filter((mut source: Path) => source/*Source*/.endsWith(".java")).map((mut child: Path) => Source(sourceDirectory/*Path*/, child/*&[I8]*/)).collect(ListCollector<Source>(/*auto*/));
	}
	static def prepareRoot(state: CompileState, source: Source, input: &[I8], platform: Platform): Tuple2Impl<CompileState, IncompleteRoot> {
		let location = source/*Source*/.computeLocation(/*auto*/);
		let initialized = state/*CompileState*/.withPlatform(platform/*Platform*/).withLocation(location/*Location*/);
		return Main/*auto*/.getCompileStateIncompleteRootTuple2(input/*&[I8]*/, initialized/*CompileState*/, location/*Location*/);
	}
	static def getCompileStateIncompleteRootTuple2(input: &[I8], initialized: CompileState, location: Location): Tuple2Impl<CompileState, IncompleteRoot> {
		let statementsTuple = Main/*auto*/.parseAll(initialized/*CompileState*/, input/*&[I8]*/, Main/*auto*/.foldStatements, (mut state1: CompileState, mut s: &[I8]) => Some<>(Main/*auto*/.parseRootSegment(state1/*DivideState*/, s/*string*/))).orElse(Tuple2Impl<>(initialized/*CompileState*/, Lists/*auto*/.empty(/*auto*/)));
		let statementsState = statementsTuple/*auto*/.left(/*auto*/);
		let statements = statementsTuple/*auto*/.right(/*auto*/);
		let incomplete = IncompleteRoot(location/*Location*/, statements/*auto*/);
		return Tuple2Impl<CompileState, IncompleteRoot>(statementsState/*CompileState*/, incomplete/*List<IncompleteRoot>*/);
	}
	static def getStringStringHashMap(state: CompileState, segments: List<IncompleteRootSegment>): Tuple2<CompileState, Map<&[I8], &[I8]>> {
		let location = state/*CompileState*/.findCurrentLocation(/*auto*/).orElse(Location(Lists/*auto*/.empty(/*auto*/), ""));
		let entries = HashMap<&[I8], &[I8]>(/*auto*/);
		let namespace = location/*Location*/.namespace(/*auto*/);
		let name = location/*Location*/.name(/*auto*/);
		let joinedDefinedTypes = state/*CompileState*/.findDefinedTypes(/*auto*/).sort(String/*auto*/.compareTo).query(/*auto*/).map((mut value: &[I8]) => "\n\t" + value/*&[I8]*/).collect(Joiner(", ")).orElse("");
		let debug = "/*[" + joinedDefinedTypes/*auto*/ + "\n]*/\n";
		let generatedMain = Main/*auto*/.createMain(name/*&[I8]*/);
		let imports = Main/*auto*/.generateOrFoldImports(state/*CompileState*/);
		let joinedOutput = segments/*List<IncompleteRootSegment>*/.query(/*auto*/).map(IncompleteRootSegment/*auto*/.value).collect(Joiner("")).orElse("");
		if (state/*CompileState*/.isPlatform(Platform/*auto*/.Windows)) {
			let value = /* namespace.query().collect(new Joiner("_")).map((String inner) -> inner + "_").orElse("") + name*/;
			/*entries.put(Platform.Windows.extension[0], debug + Main.generateDirective("ifndef " + value) + Main.generateDirective("define " + value) + imports + Main.generateDirective("endif"))*/;
			/*entries.put(Platform.Windows.extension[1], Main.generateDirective("include \"./" + name + ".h\"") + state.join() + joinedOutput + generatedMain)*/;
		}
		else {
			/*entries.put(state.platform().extension[0], debug + imports + state.join() + joinedOutput + generatedMain)*/;
		}
		return Tuple2Impl<>(state/*CompileState*/.clearImports(/*auto*/).clearGenerated(/*auto*/), entries/*auto*/);
	}
	static def complete(state: CompileState, incomplete: IncompleteRoot, platform: Platform): Result<CompileState, IOError> {
		let entries = Main/*auto*/.getStringStringHashMap(state/*CompileState*/, incomplete/*IncompleteRoot*/.outputsByExtensions(/*auto*/));
		/*return Main.writeOutputEntries(platform, incomplete.location(), entries.right())
                .<Result<CompileState, IOError>>map((IOError error) -> new Err<CompileState, IOError>(error))
                .orElseGet(() -> new Ok<>(entries.left()))*/;
	}
	static def writeOutputEntries(platform: Platform, location: Location, outputsByExtensions: Map<&[I8], &[I8]>): Option<IOError> {
		let initial: Option<IOError> = None<IOError>(/*auto*/);
		let platformRoot = Files/*auto*/.get(".", "src", platform/*Platform*/.root);
		return Queries/*auto*/.fromArray(platform/*Platform*/.extension).foldWithInitial(initial/*CompileState*/, (maybeError0: Option<IOError>, extension: &[I8]) => maybeError0/*auto*/.or(() => Main/*auto*/.writeOutputEntryWithParent(platformRoot/*auto*/, extension/*string*/, location/*Location*/, outputsByExtensions/*Map<&[I8], &[I8]>*/)));
	}
	static def writeOutputEntryWithParent(directory: Path, extension: &[I8], location: Location, outputsByExtensions: Map<&[I8], &[I8]>): Option<IOError> {
		return Main/*auto*/.ensureTargetParent(directory/*Path*/, location/*Location*/.namespace(/*auto*/)).match((targetParent: Path) => Main/*auto*/.writeOutputEntry(targetParent/*Path*/, location/*Location*/, outputsByExtensions/*Map<&[I8], &[I8]>*/, extension/*&[I8]*/), Some/*auto*/.new);
	}
	static def writeOutputEntry(targetParent: Path, location: Location, outputsByExtensions: Map<&[I8], &[I8]>, extension: &[I8]): Option<IOError> {
		let target = targetParent/*Path*/.resolveChild(location/*Location*/.name(/*auto*/) + "." + extension/*&[I8]*/);
		return target/*auto*/.writeString(outputsByExtensions/*Map<&[I8], &[I8]>*/.get(extension/*&[I8]*/));
	}
	static def ensureTargetParent(directory: Path, namespace: List<&[I8]>): Result<Path, IOError> {
		let targetParent = directory/*Path*/.resolveChildSegments(namespace/*List<&[I8]>*/);
		if (targetParent/*Path*/.exists(/*auto*/)) {
			return Ok<>(targetParent/*Path*/);
		}
		/*return targetParent.createDirectories()
                .<Result<Path, IOError>>map((IOError error) -> new Err<>(error))
                .orElseGet(() -> new Ok<>(targetParent))*/;
	}
	static def generateOrFoldImports(state: CompileState): &[I8] {
		if (state/*CompileState*/.isPlatform(Platform/*auto*/.Magma)) {
			return Main/*auto*/.foldImports(state/*CompileState*/);
		}
		return Main/*auto*/.generateImports(state/*CompileState*/);
	}
	static def generateImports(state: CompileState): &[I8] {
		return state/*CompileState*/.imports(/*auto*/).query(/*auto*/).map((mut anImport: Import) => anImport/*Import*/.generate(state/*CompileState*/.platform(/*auto*/))).collect(Joiner("")).orElse("");
	}
	static def foldImports(statementsState: CompileState): &[I8] {
		return statementsState/*CompileState*/.imports(/*auto*/).query(/*auto*/).foldWithInitial(Lists/*auto*/.empty(/*auto*/), Main/*auto*/.foldImport).query(/*auto*/).foldWithInitial("", Main/*auto*/.generateEntry);
	}
	static def generateEntry(current: &[I8], entry: Tuple2<List<&[I8]>, List<&[I8]>>): &[I8] {
		let joinedNamespace = entry/*Tuple2<List<&[I8]>, List<&[I8]>>*/.left(/*auto*/).query(/*auto*/).collect(Joiner(".")).orElse("");
		let joinedChildren = entry/*Tuple2<List<&[I8]>, List<&[I8]>>*/.right(/*auto*/).query(/*auto*/).collect(Joiner(", ")).orElse("");
		return current/*&[I8]*/ + "import " + joinedNamespace/*auto*/ + ".{ " + joinedChildren/*auto*/ + " };\n";
	}
	static def foldImport(current: List<Tuple2<List<&[I8]>, List<&[I8]>>>, anImport: Import): List<Tuple2<List<&[I8]>, List<&[I8]>>> {
		let namespace = anImport/*Import*/.namespace(/*auto*/);
		let child = anImport/*Import*/.child(/*auto*/);
		if (Main/*auto*/.hasNamespace(current/*List<Tuple2<List<&[I8]>, List<&[I8]>>>*/, namespace/*List<&[I8]>*/)) {
			return Main/*auto*/.attachChildToMapEntries(current/*List<Tuple2<List<&[I8]>, List<&[I8]>>>*/, namespace/*List<&[I8]>*/, child/*&[I8]*/);
		}
		else {
			return current/*List<Tuple2<List<&[I8]>, List<&[I8]>>>*/.addLast(Tuple2Impl<>(namespace/*List<&[I8]>*/, Lists/*auto*/.of(child/*&[I8]*/)));
		}
	}
	static def hasNamespace(map: List<Tuple2<List<&[I8]>, List<&[I8]>>>, namespace: List<&[I8]>): Bool {
		return map/*List<Tuple2<List<&[I8]>, List<&[I8]>>>*/.query(/*auto*/).map(Tuple2/*auto*/.left).anyMatch((mut stringList: List<&[I8]>) => namespace/*List<&[I8]>*/.equalsTo(stringList/*auto*/, String/*auto*/.equals));
	}
	static def attachChildToMapEntries(map: List<Tuple2<List<&[I8]>, List<&[I8]>>>, namespace: List<&[I8]>, child: &[I8]): List<Tuple2<List<&[I8]>, List<&[I8]>>> {
		return map/*List<Tuple2<List<&[I8]>, List<&[I8]>>>*/.query(/*auto*/).map((tuple: Tuple2<List<&[I8]>, List<&[I8]>>) => Main/*auto*/.attachChildToMapEntry(namespace/*List<&[I8]>*/, child/*&[I8]*/, tuple/*Tuple2<CompileState, Whitespace>*/)).collect(ListCollector<>(/*auto*/));
	}
	static def attachChildToMapEntry(namespace: List<&[I8]>, child: &[I8], tuple: Tuple2<List<&[I8]>, List<&[I8]>>): Tuple2<List<&[I8]>, List<&[I8]>> {
		let entryNamespace = tuple/*Tuple2<List<&[I8]>, List<&[I8]>>*/.left(/*auto*/);
		let entryValues = tuple/*Tuple2<List<&[I8]>, List<&[I8]>>*/.right(/*auto*/);
		if (entryNamespace/*auto*/.equalsTo(namespace/*List<&[I8]>*/, String/*auto*/.equals)) {
			return Tuple2Impl<>(entryNamespace/*auto*/, entryValues/*auto*/.addLast(child/*&[I8]*/));
		}
		else {
			return tuple/*Tuple2<List<&[I8]>, List<&[I8]>>*/;
		}
	}
	static def generateDirective(content: &[I8]): &[I8] {
		return "#" + content/*&[I8]*/ + "\n";
	}
	static def createMain(name: &[I8]): &[I8] {
		if (Strings/*auto*/.equalsTo(name/*&[I8]*/, "Main")) {
			return "Main.main();";
		}
		return "";
	}
	static def compileStatements(state: CompileState, input: &[I8], mapper: (arg0 : CompileState, arg1 : &[I8]) => Tuple2<CompileState, &[I8]>): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileAll(state/*CompileState*/, input/*&[I8]*/, Main/*auto*/.foldStatements, mapper/*(arg0 : CompileState, arg1 : &[I8]) => Tuple2<CompileState, &[I8]>*/, Main/*auto*/.mergeStatements);
	}
	static def compileAll(state: CompileState, input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState, mapper: (arg0 : CompileState, arg1 : &[I8]) => Tuple2<CompileState, &[I8]>, merger: (arg0 : &[I8], arg1 : &[I8]) => &[I8]): Tuple2<CompileState, &[I8]> {
		let folded = Main/*auto*/.parseAll(state/*CompileState*/, input/*&[I8]*/, folder/*(arg0 : DivideState, arg1 : I8) => DivideState*/, (mut state1: CompileState, mut s: &[I8]) => Some<Tuple2<CompileState, &[I8]>>(mapper/*(arg0 : CompileState, arg1 : &[I8]) => Tuple2<CompileState, &[I8]>*/(state1/*DivideState*/, s/*string*/))).orElse(Tuple2Impl<CompileState, List<&[I8]>>(state/*CompileState*/, Lists/*auto*/.empty(/*auto*/)));
		return Tuple2Impl<CompileState, &[I8]>(folded/*auto*/.left(/*auto*/), Main/*auto*/.generateAll(folded/*auto*/.right(/*auto*/), merger/*(arg0 : &[I8], arg1 : &[I8]) => &[I8]*/));
	}
	static def generateAll(elements: List<&[I8]>, merger: (arg0 : &[I8], arg1 : &[I8]) => &[I8]): &[I8] {
		return elements/*List<&[I8]>*/.query(/*auto*/).foldWithInitial("", merger/*(arg0 : &[I8], arg1 : &[I8]) => &[I8]*/);
	}
	static def parseAll<T>(state: CompileState, input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState, biFunction: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, List<T>>> {
		return Main/*auto*/.divide(input/*&[I8]*/, folder/*(arg0 : DivideState, arg1 : I8) => DivideState*/).query(/*auto*/).foldWithInitial(Some<Tuple2<CompileState, List<T>>>(Tuple2Impl<CompileState, List<T>>(state/*CompileState*/, Lists/*auto*/.empty(/*auto*/))), (maybeCurrent: Option<Tuple2<CompileState, List<T>>>, segment: &[I8]) => maybeCurrent/*auto*/.flatMap((current: Tuple2<CompileState, List<T>>) => {
			let currentState = current/*Tuple2<CompileState, List<T>>*/.left(/*auto*/);
			let currentElement = current/*Tuple2<CompileState, List<T>>*/.right(/*auto*/);
			return biFunction/*(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>*/(currentState/*auto*/, segment/*auto*/).map((mappedTuple: Tuple2<CompileState, T>) => {
				let mappedState = mappedTuple/*Tuple2<CompileState, T>*/.left(/*auto*/);
				let mappedElement = mappedTuple/*Tuple2<CompileState, T>*/.right(/*auto*/);
				return Tuple2Impl<CompileState, List<T>>(mappedState/*auto*/, currentElement/*auto*/.addLast(mappedElement/*auto*/));
			});
		}));
	}
	static def mergeStatements(cache: &[I8], element: &[I8]): &[I8] {
		return cache/*&[I8]*/ + element/*&[I8]*/;
	}
	static def divide(input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState): List<&[I8]> {
		mut let current = DivideState/*auto*/.createInitial(input/*&[I8]*/);
		while (true/*auto*/) {
			let poppedTuple0 = current/*Tuple2<CompileState, List<T>>*/.pop(/*auto*/).toTuple(Tuple2Impl<DivideState, I8>(current/*Tuple2<CompileState, List<T>>*/, "\0"));
			if (!poppedTuple0/*auto*/.left(/*auto*/)) {
				break;
			}
			let poppedTuple = poppedTuple0/*auto*/.right(/*auto*/);
			let poppedState = poppedTuple/*auto*/.left(/*auto*/);
			let popped = poppedTuple/*auto*/.right(/*auto*/);
			current/*Tuple2<CompileState, List<T>>*/ = Main/*auto*/.foldSingleQuotes(poppedState/*auto*/, popped/*auto*/).or(() => Main/*auto*/.foldDoubleQuotes(poppedState/*auto*/, popped/*auto*/)).orElseGet(() => folder/*(arg0 : DivideState, arg1 : I8) => DivideState*/(poppedState/*auto*/, popped/*auto*/));
		}
		return current/*Tuple2<CompileState, List<T>>*/.advance(/*auto*/).segments(/*auto*/);
	}
	static def foldDoubleQuotes(state: DivideState, c: I8): Option<DivideState> {
		if ("\"" !== c/*I8*/) {
			return None<DivideState>(/*auto*/);
		}
		mut let appended = state/*DivideState*/.append(c/*I8*/);
		while (true/*auto*/) {
			let maybeTuple = appended/*auto*/.popAndAppendToTuple(/*auto*/).toTuple(Tuple2Impl<DivideState, I8>(appended/*auto*/, "\0"));
			if (!maybeTuple/*auto*/.left(/*auto*/)) {
				break;
			}
			let tuple = maybeTuple/*auto*/.right(/*auto*/);
			appended/*auto*/ = tuple/*Tuple2<List<&[I8]>, List<&[I8]>>*/.left(/*auto*/);
			if ("\\" === tuple/*Tuple2<List<&[I8]>, List<&[I8]>>*/.right(/*auto*/)) {
				appended/*auto*/ = appended/*auto*/.popAndAppendToOption(/*auto*/).orElse(appended/*auto*/);
			}
			if ("\"" === tuple/*Tuple2<List<&[I8]>, List<&[I8]>>*/.right(/*auto*/)) {
				break;
			}
		}
		return Some<DivideState>(appended/*auto*/);
	}
	static def foldSingleQuotes(state: DivideState, c: I8): Option<DivideState> {
		if ("\'" !== c/*I8*/) {
			return None<DivideState>(/*auto*/);
		}
		return state/*DivideState*/.append(c/*I8*/).popAndAppendToTuple(/*auto*/).flatMap(Main/*auto*/.foldEscaped).flatMap((mut state1: DivideState) => state1/*DivideState*/.popAndAppendToOption(/*auto*/));
	}
	static def foldEscaped(tuple: Tuple2<DivideState, I8>): Option<DivideState> {
		let state = tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/);
		let c = tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/);
		if ("\\" === c/*I8*/) {
			return state/*DivideState*/.popAndAppendToOption(/*auto*/);
		}
		return Some<DivideState>(state/*DivideState*/);
	}
	static def foldStatements(state: DivideState, c: I8): DivideState {
		let appended = state/*DivideState*/.append(c/*I8*/);
		if (";" === c/*I8*/ && appended/*auto*/.isLevel(/*auto*/)) {
			return appended/*auto*/.advance(/*auto*/);
		}
		if ("}" === c/*I8*/ && appended/*auto*/.isShallow(/*auto*/)) {
			return appended/*auto*/.advance(/*auto*/).exit(/*auto*/);
		}
		if ("{" === c/*I8*/ || "(" === c/*I8*/) {
			return appended/*auto*/.enter(/*auto*/);
		}
		if ("}" === c/*I8*/ || ")" === c/*I8*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def parseRootSegment(state: CompileState, input: &[I8]): Tuple2<CompileState, IncompleteRootSegment> {
		return Main/*auto*/.or(state/*CompileState*/, input/*&[I8]*/, Lists/*auto*/.of(Main/*auto*/.typed(Main/*auto*/.compileWhitespace), Main/*auto*/.typed(Main/*auto*/.compileNamespaced), Main/*auto*/.typed(Main/*auto*/.createStructureRule("class ", "class ")), Main/*auto*/.typed(Main/*auto*/.createStructureRule("interface ", "interface ")), Main/*auto*/.typed(Main/*auto*/.createStructureRule("record ", "class ")), Main/*auto*/.typed(Main/*auto*/.createStructureRule("enum ", "class ")))).orElseGet(() => Tuple2Impl<CompileState, IncompleteRootSegment>(state/*CompileState*/, IncompleteRootSegment(Main/*auto*/.generatePlaceholder(input/*&[I8]*/))));
	}
	static def typed(mapper: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, IncompleteRootSegment>> {
		return (state: CompileState, s: &[I8]) => {
			let apply = mapper/*(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>*/(state/*CompileState*/, s/*&[I8]*/);
			return apply/*auto*/.map((result: Tuple2<CompileState, &[I8]>) => {
				return Tuple2Impl<>(result/*Tuple2<CompileState, &[I8]>*/.left(/*auto*/), IncompleteRootSegment(result/*Tuple2<CompileState, &[I8]>*/.right(/*auto*/)));
			});
		};
	}
	static def createStructureRule(sourceInfix: &[I8], targetInfix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>> {
		return (state: CompileState, input1: &[I8]) => Main/*auto*/.compileFirst(input1/*string*/, sourceInfix/*&[I8]*/, (beforeInfix: &[I8], afterInfix: &[I8]) => Main/*auto*/.compileFirst(afterInfix/*auto*/, "{", (beforeContent: &[I8], withEnd: &[I8]) => Main/*auto*/.compileSuffix(Strings/*auto*/.strip(withEnd/*auto*/), "}", (inputContent: &[I8]) => Main/*auto*/.compileLast(beforeInfix/*auto*/, "\n", (s: &[I8], s2: &[I8]) => {
			let annotations = Main/*auto*/.parseAnnotations(s/*&[I8]*/);
			if (annotations/*List<string>*/.contains("Actual", Strings/*auto*/.equalsTo)) {
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/, ""));
			}
			return Main/*auto*/.compileStructureWithImplementing(state/*CompileState*/, annotations/*List<string>*/, Main/*auto*/.parseModifiers(s2/*&[I8]*/), targetInfix/*&[I8]*/, beforeContent/*string*/, inputContent/*string*/);
		}).or(() => {
			let modifiers = Main/*auto*/.parseModifiers(beforeContent/*string*/);
			return Main/*auto*/.compileStructureWithImplementing(state/*CompileState*/, Lists/*auto*/.empty(/*auto*/), modifiers/*List<string>*/, targetInfix/*&[I8]*/, beforeContent/*string*/, inputContent/*string*/);
		}))));
	}
	static def compileStructureWithImplementing(state: CompileState, annotations: List<&[I8]>, modifiers: List<&[I8]>, targetInfix: &[I8], beforeContent: &[I8], content: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileLast(beforeContent/*&[I8]*/, " implements ", (s: &[I8], s2: &[I8]) => Main/*auto*/.parseType(state/*CompileState*/, s2/*&[I8]*/).flatMap((implementingTuple: Tuple2<CompileState, Type>) => Main/*auto*/.compileStructureWithExtends(implementingTuple/*auto*/.left(/*auto*/), annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, targetInfix/*&[I8]*/, s/*&[I8]*/, Some<Type>(implementingTuple/*auto*/.right(/*auto*/)), content/*&[I8]*/))).or(() => Main/*auto*/.compileStructureWithExtends(state/*CompileState*/, annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, targetInfix/*&[I8]*/, beforeContent/*&[I8]*/, None<Type>(/*auto*/), content/*&[I8]*/));
	}
	static def compileStructureWithExtends(state: CompileState, annotations: List<&[I8]>, modifiers: List<&[I8]>, targetInfix: &[I8], beforeContent: &[I8], maybeImplementing: Option<Type>, inputContent: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(beforeContent/*&[I8]*/, " extends ", (mut beforeExtends: &[I8], mut afterExtends: &[I8]) => Main/*auto*/.compileStructureWithParameters(state/*CompileState*/, annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, targetInfix/*&[I8]*/, beforeExtends/*auto*/, Some<&[I8]>(afterExtends/*auto*/), maybeImplementing/*Option<Type>*/, inputContent/*&[I8]*/)).or(() => Main/*auto*/.compileStructureWithParameters(state/*CompileState*/, annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, targetInfix/*&[I8]*/, beforeContent/*&[I8]*/, None<&[I8]>(/*auto*/), maybeImplementing/*Option<Type>*/, inputContent/*&[I8]*/));
	}
	static def compileStructureWithParameters(state: CompileState, annotations: List<&[I8]>, modifiers: List<&[I8]>, targetInfix: &[I8], beforeContent: &[I8], maybeSuperType: Option<&[I8]>, maybeImplementing: Option<Type>, inputContent: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(beforeContent/*&[I8]*/, "(", (rawName: &[I8], withParameters: &[I8]) => Main/*auto*/.compileFirst(withParameters/*auto*/, ")", (parametersString: &[I8], _: &[I8]) => {
			let name = Strings/*auto*/.strip(rawName/*string*/);
			let parametersTuple = Main/*auto*/.parseParameters(state/*CompileState*/, parametersString/*&[I8]*/);
			let parameters = Main/*auto*/.retainDefinitionsFromParameters(parametersTuple/*auto*/.right(/*auto*/));
			return Main/*auto*/.compileStructureWithTypeParams(parametersTuple/*auto*/.left(/*auto*/), targetInfix/*&[I8]*/, inputContent/*&[I8]*/, name/*&[I8]*/, parameters/*List<Definition>*/, maybeImplementing/*Option<Type>*/, annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, maybeSuperType/*Option<&[I8]>*/);
		})).or(() => Main/*auto*/.compileStructureWithTypeParams(state/*CompileState*/, targetInfix/*&[I8]*/, inputContent/*&[I8]*/, beforeContent/*&[I8]*/, Lists/*auto*/.empty(/*auto*/), maybeImplementing/*Option<Type>*/, annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, maybeSuperType/*Option<&[I8]>*/));
	}
	static def retainDefinitionsFromParameters(parameters: List<Parameter>): List<Definition> {
		return parameters/*List<Parameter>*/.query(/*auto*/).map((mut parameter: Parameter) => parameter/*auto*/.asDefinition(/*auto*/)).flatMap(Queries/*auto*/.fromOption).collect(ListCollector<Definition>(/*auto*/));
	}
	static def compileStructureWithTypeParams(state: CompileState, infix: &[I8], content: &[I8], beforeParams: &[I8], parameters: List<Definition>, maybeImplementing: Option<Type>, annotations: List<&[I8]>, modifiers: List<&[I8]>, maybeSuperType: Option<&[I8]>): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(beforeParams/*&[I8]*/), ">", (withoutTypeParamEnd: &[I8]) => Main/*auto*/.compileFirst(withoutTypeParamEnd/*auto*/, "<", (name: &[I8], typeParamsString: &[I8]) => {
			let typeParams = Main/*auto*/.divideValues(typeParamsString/*&[I8]*/);
			return Main/*auto*/.assembleStructure(state/*CompileState*/, annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, infix/*&[I8]*/, name/*&[I8]*/, typeParams/*List<string>*/, parameters/*List<Definition>*/, maybeImplementing/*Option<Type>*/, content/*&[I8]*/, maybeSuperType/*Option<&[I8]>*/);
		})).or(() => Main/*auto*/.assembleStructure(state/*CompileState*/, annotations/*List<&[I8]>*/, modifiers/*List<&[I8]>*/, infix/*&[I8]*/, beforeParams/*&[I8]*/, Lists/*auto*/.empty(/*auto*/), parameters/*List<Definition>*/, maybeImplementing/*Option<Type>*/, content/*&[I8]*/, maybeSuperType/*Option<&[I8]>*/));
	}
	static def assembleStructure(state: CompileState, annotations: List<&[I8]>, oldModifiers: List<&[I8]>, infix: &[I8], rawName: &[I8], typeParams: List<&[I8]>, parameters: List<Definition>, maybeImplementing: Option<Type>, content: &[I8], maybeSuperType: Option<&[I8]>): Option<Tuple2<CompileState, &[I8]>> {
		let name = Strings/*auto*/.strip(rawName/*&[I8]*/);
		if (!Main/*auto*/.isSymbol(name/*&[I8]*/)) {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
		let outputContentTuple = Main/*auto*/.compileStatements(state/*CompileState*/.pushStructureName(name/*&[I8]*/), content/*&[I8]*/, Main/*auto*/.compileClassSegment);
		let outputContentState = outputContentTuple/*auto*/.left(/*auto*/).popStructureName(/*auto*/);
		let outputContent = outputContentTuple/*auto*/.right(/*auto*/);
		let platform = outputContentState/*CompileState*/.platform(/*auto*/);
		let constructorString = Main/*auto*/.generateConstructorFromRecordParameters(parameters/*List<Definition>*/, platform/*Platform*/);
		let joinedTypeParams = Joiner/*auto*/.joinOrEmpty(typeParams/*List<&[I8]>*/, ", ", "<", ">");
		let implementingString = Main/*auto*/.generateImplementing(maybeImplementing/*Option<Type>*/);
		let newModifiers = Main/*auto*/.modifyModifiers0(oldModifiers/*List<&[I8]>*/);
		let joinedModifiers = newModifiers/*auto*/.query(/*auto*/).map((mut value: &[I8]) => value/*&[I8]*/ + " ").collect(Joiner/*auto*/.empty(/*auto*/)).orElse("");
		return Main/*auto*/.getTuple2Some(outputContentState/*CompileState*/.defineType(name/*&[I8]*/), annotations/*List<&[I8]>*/, infix/*&[I8]*/, parameters/*List<Definition>*/, maybeSuperType/*Option<&[I8]>*/, name/*&[I8]*/, joinedModifiers/*string*/, joinedTypeParams/*string*/, implementingString/*string*/, platform/*Platform*/, constructorString/*string*/, outputContent/*string*/);
	}
	static def getTuple2Some(state: CompileState, annotations: List<&[I8]>, infix: &[I8], parameters: List<Definition>, maybeSuperType: Option<&[I8]>, name: &[I8], joinedModifiers: &[I8], joinedTypeParams: &[I8], implementingString: &[I8], platform: Platform, constructorString: &[I8], outputContent: &[I8]): Some<Tuple2<CompileState, &[I8]>> {
		if (annotations/*List<&[I8]>*/.contains("Namespace", Strings/*auto*/.equalsTo)) {
			let actualInfix = "interface ";
			let newName = name/*&[I8]*/ + "Instance";
			let generated = joinedModifiers/*&[I8]*/ + actualInfix/*auto*/ + newName/*auto*/ + joinedTypeParams/*&[I8]*/ + implementingString/*&[I8]*/ + " {" + Main/*auto*/.joinParameters(parameters/*List<Definition>*/, platform/*Platform*/) + constructorString/*&[I8]*/ + outputContent/*&[I8]*/ + "\n}\n";
			let withNewLocation = state/*CompileState*/.append(generated/*auto*/).mapLocation((mut location: Location) => Location(location/*Location*/.namespace(/*auto*/), location/*Location*/.name(/*auto*/) + "Instance"));
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(withNewLocation/*auto*/, ""));
		}
		else {
			let extendsString = maybeSuperType/*Option<&[I8]>*/.map((mut inner: &[I8]) => " extends " + inner/*auto*/).orElse("");
			let infix1 = Main/*auto*/.retainStruct(infix/*&[I8]*/, state/*CompileState*/);
			let generated = joinedModifiers/*&[I8]*/ + infix1/*auto*/ + name/*&[I8]*/ + joinedTypeParams/*&[I8]*/ + extendsString/*auto*/ + implementingString/*&[I8]*/ + " {" + Main/*auto*/.joinParameters(parameters/*List<Definition>*/, platform/*Platform*/) + constructorString/*&[I8]*/ + outputContent/*&[I8]*/ + "\n}\n";
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/.append(generated/*auto*/), ""));
		}
	}
	static def retainStruct(infix: &[I8], outputContentState: CompileState): &[I8] {
		if (outputContentState/*CompileState*/.isPlatform(Platform/*auto*/.Magma)) {
			return "struct ";
		}
		return infix/*&[I8]*/;
	}
	static def modifyModifiers0(oldModifiers: List<&[I8]>): List<&[I8]> {
		if (oldModifiers/*List<&[I8]>*/.contains("public", Strings/*auto*/.equalsTo)) {
			return Lists/*auto*/.of("export");
		}
		return Lists/*auto*/.empty(/*auto*/);
	}
	static def generateImplementing(maybeImplementing: Option<Type>): &[I8] {
		return maybeImplementing/*Option<Type>*/.map((mut type: Type) => type/*Type*/.generate(/*auto*/)).map((mut inner: &[I8]) => " implements " + inner/*auto*/).orElse("");
	}
	static def generateConstructorFromRecordParameters(parameters: List<Definition>, platform: Platform): &[I8] {
		return parameters/*List<Definition>*/.query(/*auto*/).map((mut definition: Definition) => definition/*Definition*/.generate(platform/*Platform*/)).collect(Joiner(", ")).map((mut generatedParameters: &[I8]) => Main/*auto*/.generateConstructorWithParameterString(parameters/*List<Definition>*/, generatedParameters/*auto*/)).orElse("");
	}
	static def generateConstructorWithParameterString(parameters: List<Definition>, parametersString: &[I8]): &[I8] {
		let constructorAssignments = Main/*auto*/.generateConstructorAssignments(parameters/*List<Definition>*/);
		return "\n\tconstructor (" + parametersString/*&[I8]*/ + ") {" + constructorAssignments/*auto*/ + "\n\t}";
	}
	static def generateConstructorAssignments(parameters: List<Definition>): &[I8] {
		return parameters/*List<Definition>*/.query(/*auto*/).map((mut definition: Definition) => "\n\t\tthis." + definition/*Definition*/.name(/*auto*/) + " = " + definition/*Definition*/.name(/*auto*/) + ";").collect(Joiner/*auto*/.empty(/*auto*/)).orElse("");
	}
	static def joinParameters(parameters: List<Definition>, platform: Platform): &[I8] {
		return parameters/*List<Definition>*/.query(/*auto*/).map((mut definition: Definition) => definition/*Definition*/.generate(platform/*Platform*/)).map((mut generated: &[I8]) => "\n\t" + generated/*auto*/ + ";").collect(Joiner/*auto*/.empty(/*auto*/)).orElse("");
	}
	static def compileNamespaced(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		let stripped = Strings/*auto*/.strip(input/*&[I8]*/);
		if (stripped/*auto*/.startsWith("package ") || stripped/*auto*/.startsWith("import ")) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/, ""));
		}
		return None<>(/*auto*/);
	}
	static def compileOrPlaceholder(state: CompileState, input: &[I8], rules: List<(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>>): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.or(state/*CompileState*/, input/*&[I8]*/, rules/*List<(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>>*/).orElseGet(() => Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/, Main/*auto*/.generatePlaceholder(input/*&[I8]*/)));
	}
	static def or<T>(state: CompileState, input: &[I8], rules: List<(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>>): Option<Tuple2<CompileState, T>> {
		return rules/*List<(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>>*/.query(/*auto*/).map((mut rule: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>) => Main/*auto*/.getApply(state/*CompileState*/, input/*&[I8]*/, rule/*(arg0 : CompileState, arg1 : string) => Option<Tuple2<CompileState, T>>*/)).flatMap(Queries/*auto*/.fromOption).next(/*auto*/);
	}
	static def getApply<T>(state: CompileState, input: &[I8], rule: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, T>> {
		return rule/*(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>*/(state/*CompileState*/, input/*&[I8]*/);
	}
	static def compileClassSegment(state1: CompileState, input1: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileOrPlaceholder(state1/*CompileState*/, input1/*&[I8]*/, Lists/*auto*/.of(Main/*auto*/.compileWhitespace, Main/*auto*/.createStructureRule("class ", "class "), Main/*auto*/.createStructureRule("interface ", "interface "), Main/*auto*/.createStructureRule("record ", "class "), Main/*auto*/.createStructureRule("enum ", "class "), Main/*auto*/.compileMethod, Main/*auto*/.compileFieldDefinition));
	}
	static def compileMethod(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(input/*&[I8]*/, "(", (beforeParams: &[I8], withParams: &[I8]) => {
			let strippedBeforeParams = Strings/*auto*/.strip(beforeParams/*&[I8]*/);
			return Main/*auto*/.compileLast(strippedBeforeParams/*auto*/, " ", (_: &[I8], name: &[I8]) => {
				if (state/*CompileState*/.hasLastStructureNameOf(name/*&[I8]*/)) {
					return Main/*auto*/.compileMethodWithBeforeParams(state/*CompileState*/, ConstructorHeader(/*auto*/), withParams/*&[I8]*/);
				}
				return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
			}).or(() => {
				if (state/*CompileState*/.hasLastStructureNameOf(strippedBeforeParams/*auto*/)) {
					return Main/*auto*/.compileMethodWithBeforeParams(state/*CompileState*/, ConstructorHeader(/*auto*/), withParams/*&[I8]*/);
				}
				return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
			}).or(() => Main/*auto*/.parseDefinition(state/*CompileState*/, beforeParams/*&[I8]*/).flatMap((mut tuple: Tuple2<CompileState, Definition>) => Main/*auto*/.compileMethodWithBeforeParams(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/), tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/), withParams/*&[I8]*/)));
		});
	}
	static def compileMethodWithBeforeParams<S extends FunctionHeader<S>>(state: CompileState, header: FunctionHeader<S>, withParams: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(withParams/*&[I8]*/, ")", (params: &[I8], afterParams: &[I8]) => {
			let parametersTuple = Main/*auto*/.parseParameters(state/*CompileState*/, params/*&[I8]*/);
			let parametersState = parametersTuple/*auto*/.left(/*auto*/);
			let parameters = parametersTuple/*auto*/.right(/*auto*/);
			let definitions = Main/*auto*/.retainDefinitionsFromParameters(parameters/*List<Definition>*/);
			let newHeader = Main/*auto*/.retainDef(header/*FunctionHeader<S>*/, parametersState/*CompileState*/);
			if (newHeader/*auto*/.hasAnnotation("Actual")) {
				let sFunctionSegment = FunctionSegment<S>(newHeader/*auto*/, definitions/*List<Definition>*/, None<>(/*auto*/));
				let generate = sFunctionSegment/*auto*/.generate(parametersState/*CompileState*/.platform(/*auto*/), "\n\t");
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(parametersState/*CompileState*/, generate/*auto*/));
			}
			return Main/*auto*/.compilePrefix(Strings/*auto*/.strip(afterParams/*&[I8]*/), "{", (withoutContentStart: &[I8]) => Main/*auto*/.compileSuffix(Strings/*auto*/.strip(withoutContentStart/*auto*/), "}", (withoutContentEnd: &[I8]) => {
				let compileState1 = parametersState/*CompileState*/.enterDepth(/*auto*/);
				let compileState = /* compileState1.isPlatform(Platform.Windows) ? compileState1 : compileState1.enterDepth()*/;
				let statementsTuple = Main/*auto*/.compileFunctionStatements(compileState/*auto*/.defineAll(definitions/*List<Definition>*/), withoutContentEnd/*&[I8]*/);
				let compileState2 = statementsTuple/*auto*/.left(/*auto*/).exitDepth(/*auto*/);
				let indent = compileState2/*auto*/.createIndent(/*auto*/);
				let exited = /* compileState2.isPlatform(Platform.Windows) ? compileState2 : compileState2.exitDepth()*/;
				let sFunctionSegment = FunctionSegment<S>(newHeader/*auto*/, definitions/*List<Definition>*/, Some<>(statementsTuple/*auto*/.right(/*auto*/)));
				let generated = sFunctionSegment/*auto*/.generate(parametersState/*CompileState*/.platform(/*auto*/), indent/*&[I8]*/);
				if (exited/*auto*/.isPlatform(Platform/*auto*/.Windows)) {
					return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(exited/*auto*/.addFunction(generated/*auto*/), ""));
				}
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(exited/*auto*/, generated/*auto*/));
			})).or(() => {
				if (Strings/*auto*/.equalsTo(";", Strings/*auto*/.strip(afterParams/*&[I8]*/))) {
					let sFunctionSegment = FunctionSegment<S>(newHeader/*auto*/, definitions/*List<Definition>*/, None<>(/*auto*/));
					let generate = sFunctionSegment/*auto*/.generate(parametersState/*CompileState*/.platform(/*auto*/), "\n\t");
					return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(parametersState/*CompileState*/, generate/*auto*/));
				}
				return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
			});
		});
	}
	static def retainDef<S extends FunctionHeader<S>>(header: FunctionHeader<S>, parametersState: CompileState): FunctionHeader<S> {
		if (parametersState/*CompileState*/.isPlatform(Platform/*auto*/.Magma)) {
			return header/*FunctionHeader<S>*/.addModifierLast("def").removeModifier("mut");
		}
		return header/*FunctionHeader<S>*/;
	}
	static def parseParameters(state: CompileState, params: &[I8]): Tuple2<CompileState, List<Parameter>> {
		return Main/*auto*/.parseValuesOrEmpty(state/*CompileState*/, params/*&[I8]*/, (mut state1: CompileState, mut s: &[I8]) => Some<Tuple2<CompileState, Parameter>>(Main/*auto*/.parseParameterOrPlaceholder(state1/*CompileState*/, s/*&[I8]*/)));
	}
	static def compileFunctionStatements(state: CompileState, input: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileStatements(state/*CompileState*/, input/*&[I8]*/, Main/*auto*/.compileFunctionSegment);
	}
	static def compileFunctionSegment(state: CompileState, input: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileOrPlaceholder(state/*CompileState*/, input/*&[I8]*/, Lists/*auto*/.of(Main/*auto*/.compileWhitespace, Main/*auto*/.compileEmptySegment, Main/*auto*/.compileBlock, Main/*auto*/.compileFunctionStatement, Main/*auto*/.compileReturnWithoutSuffix));
	}
	static def compileEmptySegment(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		if (Strings/*auto*/.equalsTo(";", Strings/*auto*/.strip(input/*&[I8]*/))) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/, ";"));
		}
		else {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
	}
	static def compileReturnWithoutSuffix(state1: CompileState, input1: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileReturn(input1/*&[I8]*/, (mut withoutPrefix: &[I8]) => Main/*auto*/.compileValue(state1/*CompileState*/, withoutPrefix/*string*/)).map((mut tuple: Tuple2<CompileState, &[I8]>) => Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/), state1/*CompileState*/.createIndent(/*auto*/) + tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/)));
	}
	static def compileBlock(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*&[I8]*/), "}", (withoutEnd: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFoldedLast(withoutEnd/*string*/, "", Main/*auto*/.foldBlockStarts), (beforeContentWithEnd: &[I8], content: &[I8]) => Main/*auto*/.compileSuffix(beforeContentWithEnd/*auto*/, "{", (beforeContent: &[I8]) => Main/*auto*/.compileBlockHeader(state/*CompileState*/, beforeContent/*&[I8]*/).flatMap((headerTuple: Tuple2<CompileState, &[I8]>) => {
			let contentTuple = Main/*auto*/.compileFunctionStatements(headerTuple/*Tuple2<CompileState, &[I8]>*/.left(/*auto*/).enterDepth(/*auto*/), content/*&[I8]*/);
			let indent = state/*CompileState*/.createIndent(/*auto*/);
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(contentTuple/*auto*/.left(/*auto*/).exitDepth(/*auto*/), indent/*&[I8]*/ + headerTuple/*Tuple2<CompileState, &[I8]>*/.right(/*auto*/) + "{" + contentTuple/*auto*/.right(/*auto*/) + indent/*&[I8]*/ + "}"));
		}))));
	}
	static def foldBlockStarts(state: DivideState, c: I8): DivideState {
		let appended = state/*DivideState*/.append(c/*I8*/);
		if ("{" === c/*I8*/) {
			let entered = appended/*auto*/.enter(/*auto*/);
			if (entered/*auto*/.isShallow(/*auto*/)) {
				return entered/*auto*/.advance(/*auto*/);
			}
			else {
				return entered/*auto*/;
			}
		}
		if ("}" === c/*I8*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def compileBlockHeader(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.or(state/*CompileState*/, input/*&[I8]*/, Lists/*auto*/.of(Main/*auto*/.createConditionalRule("if"), Main/*auto*/.createConditionalRule("while"), Main/*auto*/.compileElse));
	}
	static def createConditionalRule(prefix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>> {
		return (mut state1: CompileState, mut input1: &[I8]) => Main/*auto*/.compilePrefix(Strings/*auto*/.strip(input1/*&[I8]*/), prefix/*&[I8]*/, (withoutPrefix: &[I8]) => {
			let strippedCondition = Strings/*auto*/.strip(withoutPrefix/*&[I8]*/);
			return Main/*auto*/.compilePrefix(strippedCondition/*auto*/, "(", (withoutConditionStart: &[I8]) => Main/*auto*/.compileSuffix(withoutConditionStart/*auto*/, ")", (withoutConditionEnd: &[I8]) => {
				let tuple = Main/*auto*/.compileValueOrPlaceholder(state1/*CompileState*/, withoutConditionEnd/*&[I8]*/);
				return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/), prefix/*&[I8]*/ + " (" + tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/) + ") "));
			}));
		});
	}
	static def compileElse(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		if (Strings/*auto*/.equalsTo("else", Strings/*auto*/.strip(input/*&[I8]*/))) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/, "else "));
		}
		else {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
	}
	static def compileFunctionStatement(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*&[I8]*/), ";", (withoutEnd: &[I8]) => {
			let valueTuple = Main/*auto*/.compileFunctionStatementValue(state/*CompileState*/, withoutEnd/*&[I8]*/);
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(valueTuple/*auto*/.left(/*auto*/), state/*CompileState*/.createIndent(/*auto*/) + valueTuple/*auto*/.right(/*auto*/) + ";"));
		});
	}
	static def compileFunctionStatementValue(state: CompileState, withoutEnd: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileOrPlaceholder(state/*CompileState*/, withoutEnd/*&[I8]*/, Lists/*auto*/.of(Main/*auto*/.compileReturnWithValue, Main/*auto*/.compileAssignment, (mut state1: CompileState, mut input: &[I8]) => Main/*auto*/.parseInvokable(state1/*CompileState*/, input/*&[I8]*/).map((mut tuple: Tuple2<CompileState, Value>) => Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/), tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/).generate(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/).platform(/*auto*/)))), Main/*auto*/.createPostRule("++"), Main/*auto*/.createPostRule("--"), Main/*auto*/.compileBreak));
	}
	static def compileBreak(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		if (Strings/*auto*/.equalsTo("break", Strings/*auto*/.strip(input/*&[I8]*/))) {
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/, "break"));
		}
		else {
			return None<Tuple2<CompileState, &[I8]>>(/*auto*/);
		}
	}
	static def createPostRule(suffix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, &[I8]>> {
		return (mut state1: CompileState, mut input: &[I8]) => Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*&[I8]*/), suffix/*&[I8]*/, (child: &[I8]) => {
			let tuple = Main/*auto*/.compileValueOrPlaceholder(state1/*CompileState*/, child/*&[I8]*/);
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/), tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/) + suffix/*&[I8]*/));
		});
	}
	static def compileReturnWithValue(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileReturn(input/*&[I8]*/, (mut value1: &[I8]) => Main/*auto*/.compileValue(state/*CompileState*/, value1/*auto*/));
	}
	static def compileReturn(input: &[I8], mapper: (arg0 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compilePrefix(Strings/*auto*/.strip(input/*&[I8]*/), "return ", (value: &[I8]) => mapper/*(arg0 : &[I8]) => Option<Tuple2<CompileState, &[I8]>>*/(value/*&[I8]*/).flatMap((tuple: Tuple2<CompileState, &[I8]>) => Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/), "return " + tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/)))));
	}
	static def parseInvokable(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*&[I8]*/), ")", (withoutEnd: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFoldedLast(withoutEnd/*&[I8]*/, "", Main/*auto*/.foldInvocationStarts), (callerWithArgStart: &[I8], args: &[I8]) => Main/*auto*/.compileSuffix(callerWithArgStart/*auto*/, "(", (callerString: &[I8]) => Main/*auto*/.compilePrefix(Strings/*auto*/.strip(callerString/*auto*/), "new ", (type: &[I8]) => Main/*auto*/.compileType(state/*CompileState*/, type/*Type*/).flatMap((callerTuple: Tuple2<CompileState, &[I8]>) => {
			let callerState = callerTuple/*Tuple2<CompileState, &[I8]>*/.left(/*auto*/);
			let caller = callerTuple/*Tuple2<CompileState, &[I8]>*/.right(/*auto*/);
			return Main/*auto*/.assembleInvokable(callerState/*auto*/, ConstructionCaller(caller/*auto*/, callerState/*auto*/.platform(/*auto*/)), args/*List<string>*/);
		})).or(() => Main/*auto*/.parseValue(state/*CompileState*/, callerString/*auto*/).flatMap((callerTuple: Tuple2<CompileState, Value>) => Main/*auto*/.assembleInvokable(callerTuple/*Tuple2<CompileState, &[I8]>*/.left(/*auto*/), callerTuple/*Tuple2<CompileState, &[I8]>*/.right(/*auto*/), args/*List<string>*/))))));
	}
	static def splitFoldedLast(input: &[I8], delimiter: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState): Option<Tuple2<&[I8], &[I8]>> {
		return Main/*auto*/.splitFolded(input/*&[I8]*/, folder/*(arg0 : DivideState, arg1 : I8) => DivideState*/, (mut divisions1: List<&[I8]>) => Main/*auto*/.selectLast(divisions1/*auto*/, delimiter/*&[I8]*/));
	}
	static def splitFolded(input: &[I8], folder: (arg0 : DivideState, arg1 : I8) => DivideState, selector: (arg0 : List<&[I8]>) => Option<Tuple2<&[I8], &[I8]>>): Option<Tuple2<&[I8], &[I8]>> {
		let divisions = Main/*auto*/.divide(input/*&[I8]*/, folder/*(arg0 : DivideState, arg1 : I8) => DivideState*/);
		if (2/*auto*/ > divisions/*List<string>*/.size(/*auto*/)) {
			return None<Tuple2<&[I8], &[I8]>>(/*auto*/);
		}
		return selector/*(arg0 : List<&[I8]>) => Option<Tuple2<&[I8], &[I8]>>*/(divisions/*List<string>*/);
	}
	static def selectLast(divisions: List<&[I8]>, delimiter: &[I8]): Option<Tuple2<&[I8], &[I8]>> {
		let beforeLast = divisions/*List<&[I8]>*/.subList(0/*auto*/, divisions/*List<&[I8]>*/.size(/*auto*/) - 1/*auto*/).orElse(divisions/*List<&[I8]>*/);
		let last = divisions/*List<&[I8]>*/.findLast(/*auto*/).orElse("");
		let joined = beforeLast/*auto*/.query(/*auto*/).collect(Joiner(delimiter/*&[I8]*/)).orElse("");
		return Some<Tuple2<&[I8], &[I8]>>(Tuple2Impl<&[I8], &[I8]>(joined/*auto*/, last/*auto*/));
	}
	static def foldInvocationStarts(state: DivideState, c: I8): DivideState {
		let appended = state/*DivideState*/.append(c/*I8*/);
		if ("(" === c/*I8*/) {
			let entered = appended/*auto*/.enter(/*auto*/);
			if (entered/*auto*/.isShallow(/*auto*/)) {
				return entered/*auto*/.advance(/*auto*/);
			}
			else {
				return entered/*auto*/;
			}
		}
		if (")" === c/*I8*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def assembleInvokable(state: CompileState, oldCaller: Caller, argsString: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.parseValues(state/*CompileState*/, argsString/*&[I8]*/, (mut state1: CompileState, mut s: &[I8]) => Main/*auto*/.parseArgument(state1/*CompileState*/, s/*&[I8]*/)).flatMap((argsTuple: Tuple2<CompileState, List<Argument>>) => {
			let argsState = argsTuple/*Tuple2<CompileState, List<Argument>>*/.left(/*auto*/);
			let args = Main/*auto*/.retain(argsTuple/*Tuple2<CompileState, List<Argument>>*/.right(/*auto*/), (mut argument: Argument) => argument/*auto*/.toValue(/*auto*/));
			let newCaller = Main/*auto*/.transformCaller(argsState/*auto*/, oldCaller/*Caller*/);
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(argsState/*auto*/, InvokableNode(newCaller/*auto*/, args/*List<string>*/)));
		});
	}
	static def transformCaller(state: CompileState, oldCaller: Caller): Caller {
		return oldCaller/*Caller*/.findChild(/*auto*/).flatMap((parent: Value) => {
			let parentType = parent/*Value*/.type(/*auto*/);
			if (parentType/*auto*/.isFunctional(/*auto*/)) {
				return Some<Caller>(parent/*Value*/);
			}
			return None<Caller>(/*auto*/);
		}).orElse(oldCaller/*Caller*/);
	}
	static def retain<T, R>(args: List<T>, mapper: (arg0 : T) => Option<R>): List<R> {
		return args/*List<T>*/.query(/*auto*/).map(mapper/*(arg0 : T) => Option<R>*/).flatMap(Queries/*auto*/.fromOption).collect(ListCollector<R>(/*auto*/));
	}
	static def parseArgument(state1: CompileState, input: &[I8]): Option<Tuple2<CompileState, Argument>> {
		return Main/*auto*/.parseValue(state1/*CompileState*/, input/*&[I8]*/).map((mut tuple: Tuple2<CompileState, Value>) => Tuple2Impl<CompileState, Argument>(tuple/*Tuple2<DivideState, I8>*/.left(/*auto*/), tuple/*Tuple2<DivideState, I8>*/.right(/*auto*/)));
	}
	static def compileAssignment(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileFirst(input/*&[I8]*/, "=", (destination: &[I8], source: &[I8]) => {
			let sourceTuple = Main/*auto*/.compileValueOrPlaceholder(state/*CompileState*/, source/*&[I8]*/);
			let destinationTuple = Main/*auto*/.compileValue(sourceTuple/*auto*/.left(/*auto*/), destination/*&[I8]*/).or(() => Main/*auto*/.parseDefinition(sourceTuple/*auto*/.left(/*auto*/), destination/*&[I8]*/).map((definitionTuple: Tuple2<CompileState, Definition>) => {
				let definitionState = definitionTuple/*Tuple2<CompileState, Definition>*/.left(/*auto*/);
				let definition = definitionTuple/*Tuple2<CompileState, Definition>*/.right(/*auto*/);
				let let = Main/*auto*/.attachLet(definitionState/*CompileState*/, definition/*Definition*/);
				let generate = let/*auto*/.generate(definitionState/*CompileState*/.platform(/*auto*/));
				return Tuple2Impl<CompileState, &[I8]>(definitionState/*CompileState*/, generate/*auto*/);
			})).orElseGet(() => Tuple2Impl<CompileState, &[I8]>(sourceTuple/*auto*/.left(/*auto*/), Main/*auto*/.generatePlaceholder(destination/*&[I8]*/)));
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(destinationTuple/*auto*/.left(/*auto*/), destinationTuple/*auto*/.right(/*auto*/) + " = " + sourceTuple/*auto*/.right(/*auto*/)));
		});
	}
	static def attachLet(definitionState: CompileState, definition: Definition): Definition {
		/*final Definition let*/;
		if (definitionState/*CompileState*/.isPlatform(Platform/*auto*/.Windows)) {
			let/*auto*/ = definition/*Definition*/;
		}
		else {
			let/*auto*/ = definition/*Definition*/.addModifierLast("let");
		}
		return let/*auto*/;
	}
	static def compileValueOrPlaceholder(state: CompileState, input: &[I8]): Tuple2<CompileState, &[I8]> {
		return Main/*auto*/.compileValue(state/*CompileState*/, input/*&[I8]*/).orElseGet(() => Tuple2Impl<CompileState, &[I8]>(state/*CompileState*/, Main/*auto*/.generatePlaceholder(input/*&[I8]*/)));
	}
	static def compileValue(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseValue(state/*CompileState*/, input/*&[I8]*/).map((tuple: Tuple2<CompileState, Value>) => {
			let generated = tuple/*Tuple2<CompileState, Value>*/.right(/*auto*/).generate(tuple/*Tuple2<CompileState, Value>*/.left(/*auto*/).platform(/*auto*/));
			return Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<CompileState, Value>*/.left(/*auto*/), generated/*auto*/);
		});
	}
	static def parseValue(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.or(state/*CompileState*/, input/*&[I8]*/, Lists/*auto*/.of(Main/*auto*/.parseLambda, Main/*auto*/.createOperatorRule("+"), Main/*auto*/.createOperatorRule("-"), Main/*auto*/.createOperatorRule("<="), Main/*auto*/.createOperatorRule("<"), Main/*auto*/.createOperatorRule("&&"), Main/*auto*/.createOperatorRule("||"), Main/*auto*/.createOperatorRule(">"), Main/*auto*/.createOperatorRule(">="), Main/*auto*/.parseInvokable, Main/*auto*/.createAccessRule("."), Main/*auto*/.createAccessRule("::"), Main/*auto*/.parseSymbol, Main/*auto*/.parseNot, Main/*auto*/.parseNumber, Main/*auto*/.createOperatorRuleWithDifferentInfix("==", "==="), Main/*auto*/.createOperatorRuleWithDifferentInfix("!=", "!=="), Main/*auto*/.createTextRule("\""), Main/*auto*/.createTextRule("'")));
	}
	static def createTextRule(slice: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return (state1: CompileState, input1: &[I8]) => {
			let stripped = Strings/*auto*/.strip(input1/*&[I8]*/);
			return Main/*auto*/.compilePrefix(stripped/*auto*/, slice/*&[I8]*/, (s: &[I8]) => Main/*auto*/.compileSuffix(s/*&[I8]*/, slice/*&[I8]*/, (mut s1: &[I8]) => Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state1/*CompileState*/, StringNode(s1/*auto*/)))));
		};
	}
	static def parseNot(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.compilePrefix(Strings/*auto*/.strip(input/*&[I8]*/), "!", (withoutPrefix: &[I8]) => {
			let childTuple = Main/*auto*/.compileValueOrPlaceholder(state/*CompileState*/, withoutPrefix/*&[I8]*/);
			let childState = childTuple/*Tuple2<CompileState, Value>*/.left(/*auto*/);
			let child = "!" + childTuple/*Tuple2<CompileState, Value>*/.right(/*auto*/);
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(childState/*auto*/, NotNode(child/*&[I8]*/)));
		});
	}
	static def parseLambda(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.compileFirst(input/*&[I8]*/, "->", (beforeArrow: &[I8], afterArrow: &[I8]) => {
			let strippedBeforeArrow = Strings/*auto*/.strip(beforeArrow/*&[I8]*/);
			return Main/*auto*/.compilePrefix(strippedBeforeArrow/*auto*/, "(", (withoutStart: &[I8]) => Main/*auto*/.compileSuffix(withoutStart/*auto*/, ")", (withoutEnd: &[I8]) => Main/*auto*/.parseValues(state/*CompileState*/, withoutEnd/*&[I8]*/, (mut state1: CompileState, mut s: &[I8]) => Main/*auto*/.parseParameter(state1/*CompileState*/, s/*&[I8]*/)).flatMap((paramNames: Tuple2<CompileState, List<Parameter>>) => Main/*auto*/.compileLambdaWithParameterNames(paramNames/*List<Definition>*/.left(/*auto*/), Main/*auto*/.retainDefinitionsFromParameters(paramNames/*List<Definition>*/.right(/*auto*/)), afterArrow/*&[I8]*/))));
		});
	}
	static def compileLambdaWithParameterNames(state: CompileState, paramNames: List<Definition>, afterArrow: &[I8]): Option<Tuple2<CompileState, Value>> {
		let strippedAfterArrow = Strings/*auto*/.strip(afterArrow/*&[I8]*/);
		return Main/*auto*/.compilePrefix(strippedAfterArrow/*auto*/, "{", (withoutContentStart: &[I8]) => Main/*auto*/.compileSuffix(withoutContentStart/*auto*/, "}", (withoutContentEnd: &[I8]) => {
			let statementsTuple = Main/*auto*/.compileFunctionStatements(state/*CompileState*/.enterDepth(/*auto*/).defineAll(paramNames/*List<Definition>*/), withoutContentEnd/*&[I8]*/);
			let statementsState = statementsTuple/*auto*/.left(/*auto*/);
			let statements = statementsTuple/*auto*/.right(/*auto*/);
			let exited = statementsState/*CompileState*/.exitDepth(/*auto*/);
			let content = "{" + statements/*auto*/ + exited/*auto*/.createIndent(/*auto*/) + "}";
			if (exited/*auto*/.isPlatform(Platform/*auto*/.Windows)) {
				return Main/*auto*/.assembleLambdaWithContent(exited/*auto*/, paramNames/*List<Definition>*/, content/*&[I8]*/);
			}
			return Main/*auto*/.getSome(exited/*auto*/, paramNames/*List<Definition>*/, content/*&[I8]*/);
		})).or(() => Main/*auto*/.compileValue(state/*CompileState*/, strippedAfterArrow/*auto*/).flatMap((tuple: Tuple2<CompileState, &[I8]>) => {
			let state1 = tuple/*Tuple2<CompileState, &[I8]>*/.left(/*auto*/);
			let content = tuple/*Tuple2<CompileState, &[I8]>*/.right(/*auto*/);
			if (state1/*CompileState*/.isPlatform(Platform/*auto*/.Windows)) {
				return Main/*auto*/.assembleLambdaWithContent(state1/*CompileState*/, paramNames/*List<Definition>*/, "\n\treturn " + content/*&[I8]*/ + ";");
			}
			return Main/*auto*/.getSome(state1/*CompileState*/, paramNames/*List<Definition>*/, content/*&[I8]*/);
		}));
	}
	static def getSome(state: CompileState, parameters: List<Definition>, content: &[I8]): Some<Tuple2<CompileState, Value>> {
		return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state/*CompileState*/, LambdaNode(parameters/*List<Definition>*/, content/*&[I8]*/)));
	}
	static def assembleLambdaWithContent(state: CompileState, parameters: List<Definition>, content: &[I8]): Some<Tuple2<CompileState, Value>> {
		let lambdaDefinition = Definition(PrimitiveType/*auto*/.Auto, state/*CompileState*/.functionName(/*auto*/));
		let value = FunctionSegment<Definition>(lambdaDefinition/*auto*/, parameters/*List<Definition>*/, Some<>(content/*&[I8]*/));
		return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state/*CompileState*/.addFunction(value/*&[I8]*/.generate(state/*CompileState*/.platform(/*auto*/), "\n")), SymbolNode("lambdaDefinition", PrimitiveType/*auto*/.Auto)));
	}
	static def createOperatorRule(infix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return Main/*auto*/.createOperatorRuleWithDifferentInfix(infix/*&[I8]*/, infix/*&[I8]*/);
	}
	static def createAccessRule(infix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return (mut state: CompileState, mut input: &[I8]) => Main/*auto*/.compileLast(input/*&[I8]*/, infix/*&[I8]*/, (childString: &[I8], rawProperty: &[I8]) => {
			let property = Strings/*auto*/.strip(rawProperty/*&[I8]*/);
			if (!Main/*auto*/.isSymbol(property/*auto*/)) {
				return None<Tuple2<CompileState, Value>>(/*auto*/);
			}
			return Main/*auto*/.parseValue(state/*CompileState*/, childString/*&[I8]*/).flatMap((childTuple: Tuple2<CompileState, Value>) => {
				let childState = childTuple/*Tuple2<CompileState, Value>*/.left(/*auto*/);
				let child = childTuple/*Tuple2<CompileState, Value>*/.right(/*auto*/);
				return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(childState/*auto*/, AccessNode(child/*&[I8]*/, property/*auto*/)));
			});
		});
	}
	static def createOperatorRuleWithDifferentInfix(sourceInfix: &[I8], targetInfix: &[I8]): (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, Value>> {
		return (state1: CompileState, input1: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFolded(input1/*&[I8]*/, Main/*auto*/.foldOperator(sourceInfix/*&[I8]*/), (mut divisions: List<&[I8]>) => Main/*auto*/.selectFirst(divisions/*List<&[I8]>*/, sourceInfix/*&[I8]*/)), (leftString: &[I8], rightString: &[I8]) => Main/*auto*/.parseValue(state1/*CompileState*/, leftString/*auto*/).flatMap((leftTuple: Tuple2<CompileState, Value>) => Main/*auto*/.parseValue(leftTuple/*auto*/.left(/*auto*/), rightString/*auto*/).flatMap((rightTuple: Tuple2<CompileState, Value>) => {
			let left = leftTuple/*auto*/.right(/*auto*/);
			let right = rightTuple/*Tuple2<CompileState, Value>*/.right(/*auto*/);
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(rightTuple/*Tuple2<CompileState, Value>*/.left(/*auto*/), OperationNode(left/*auto*/, targetInfix/*&[I8]*/, right/*auto*/)));
		})));
	}
	static def selectFirst(divisions: List<&[I8]>, delimiter: &[I8]): Option<Tuple2<&[I8], &[I8]>> {
		let first = divisions/*List<&[I8]>*/.findFirst(/*auto*/).orElse("");
		let afterFirst = divisions/*List<&[I8]>*/.subList(1/*auto*/, divisions/*List<&[I8]>*/.size(/*auto*/)).orElse(divisions/*List<&[I8]>*/).query(/*auto*/).collect(Joiner(delimiter/*&[I8]*/)).orElse("");
		return Some<Tuple2<&[I8], &[I8]>>(Tuple2Impl<&[I8], &[I8]>(first/*auto*/, afterFirst/*auto*/));
	}
	static def foldOperator(infix: &[I8]): (arg0 : DivideState, arg1 : I8) => DivideState {
		return (state: DivideState, c: I8) => {
			if (c/*I8*/ === Strings/*auto*/.charAt(infix/*&[I8]*/, 0/*auto*/) && state/*DivideState*/.startsWith(Strings/*auto*/.sliceFrom(infix/*&[I8]*/, 1/*auto*/))) {
				let length = Strings/*auto*/.length(infix/*&[I8]*/) - 1/*auto*/;
				mut let counter = 0/*auto*/;
				mut let current = state/*DivideState*/;
				while (counter/*auto*/ < length/*I32*/) {
					counter/*auto*/++;
					current/*Tuple2<CompileState, List<T>>*/ = current/*Tuple2<CompileState, List<T>>*/.pop(/*auto*/).map((mut tuple: Tuple2<DivideState, I8>) => tuple/*Tuple2<CompileState, &[I8]>*/.left(/*auto*/)).orElse(current/*Tuple2<CompileState, List<T>>*/);
				}
				return current/*Tuple2<CompileState, List<T>>*/.advance(/*auto*/);
			}
			return state/*DivideState*/.append(c/*I8*/);
		};
	}
	static def parseNumber(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		let stripped = Strings/*auto*/.strip(input/*&[I8]*/);
		if (Main/*auto*/.isNumber(stripped/*auto*/)) {
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(state/*CompileState*/, SymbolNode(stripped/*auto*/, PrimitiveType/*auto*/.Auto)));
		}
		else {
			return None<Tuple2<CompileState, Value>>(/*auto*/);
		}
	}
	static def isNumber(input: &[I8]): Bool {
		let query = HeadedQuery<I32>(RangeHead(Strings/*auto*/.length(input/*&[I8]*/)));
		return query/*auto*/.map((mut index: I32) => input/*&[I8]*/.charAt(index/*number*/)).allMatch((mut c: I8) => Characters/*auto*/.isDigit(c/*I8*/));
	}
	static def parseSymbol(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Value>> {
		let stripped = Strings/*auto*/.strip(input/*&[I8]*/);
		if (Main/*auto*/.isSymbol(stripped/*auto*/)) {
			let withImport = state/*CompileState*/.addResolvedImportFromCache(stripped/*auto*/);
			let symbolNode = SymbolNode(stripped/*auto*/, state/*CompileState*/.resolve(stripped/*auto*/).orElse(PrimitiveType/*auto*/.Auto));
			return Some<Tuple2<CompileState, Value>>(Tuple2Impl<CompileState, Value>(withImport/*auto*/, symbolNode/*auto*/));
		}
		else {
			return None<Tuple2<CompileState, Value>>(/*auto*/);
		}
	}
	static def isSymbol(input: &[I8]): Bool {
		let query = HeadedQuery<I32>(RangeHead(Strings/*auto*/.length(input/*&[I8]*/)));
		return query/*auto*/.allMatch((mut index: I32) => Main/*auto*/.isSymbolChar(index/*number*/, Strings/*auto*/.charAt(input/*&[I8]*/, index/*number*/)));
	}
	static def isSymbolChar(index: I32, c: I8): Bool {
		return "_" === c/*I8*/ || Characters/*auto*/.isLetter(c/*I8*/) || /*auto*/(0/*auto*/ !== index/*I32*/ && Characters/*auto*/.isDigit(c/*I8*/));
	}
	static def compilePrefix<T>(input: &[I8], infix: &[I8], mapper: (arg0 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, T>> {
		if (!input/*&[I8]*/.startsWith(infix/*&[I8]*/)) {
			return None<Tuple2<CompileState, T>>(/*auto*/);
		}
		let slice = Strings/*auto*/.sliceFrom(input/*&[I8]*/, Strings/*auto*/.length(infix/*&[I8]*/));
		return mapper/*(arg0 : &[I8]) => Option<Tuple2<CompileState, T>>*/(slice/*&[I8]*/);
	}
	static def compileWhitespace(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseWhitespace(state/*CompileState*/, input/*&[I8]*/).map((tuple: Tuple2<CompileState, Whitespace>) => {
			let generate = tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/).generate(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/).platform(/*auto*/));
			return Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/), generate/*auto*/);
		});
	}
	static def parseWhitespace(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Whitespace>> {
		if (Strings/*auto*/.isBlank(input/*&[I8]*/)) {
			return Some<Tuple2<CompileState, Whitespace>>(Tuple2Impl<CompileState, Whitespace>(state/*CompileState*/, Whitespace(/*auto*/)));
		}
		return None<Tuple2<CompileState, Whitespace>>(/*auto*/);
	}
	static def compileFieldDefinition(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*&[I8]*/), ";", (withoutEnd: &[I8]) => Main/*auto*/.getTupleOption(state/*CompileState*/, withoutEnd/*&[I8]*/).or(() => Main/*auto*/.compileEnumValues(state/*CompileState*/, withoutEnd/*&[I8]*/)));
	}
	static def getTupleOption(state: CompileState, withoutEnd: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseParameter(state/*CompileState*/, withoutEnd/*&[I8]*/).flatMap((definitionTuple: Tuple2<CompileState, Parameter>) => {
			let generate = "\n\t" + definitionTuple/*Tuple2<CompileState, Parameter>*/.right(/*auto*/).generate(definitionTuple/*Tuple2<CompileState, Parameter>*/.left(/*auto*/).platform(/*auto*/)) + ";";
			return Some<Tuple2<CompileState, &[I8]>>(Tuple2Impl<CompileState, &[I8]>(definitionTuple/*Tuple2<CompileState, Parameter>*/.left(/*auto*/), generate/*auto*/));
		});
	}
	static def compileEnumValues(state: CompileState, withoutEnd: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseValues(state/*CompileState*/, withoutEnd/*&[I8]*/, (state1: CompileState, s: &[I8]) => Main/*auto*/.parseInvokable(state1/*CompileState*/, s/*&[I8]*/).flatMap((tuple: Tuple2<CompileState, Value>) => {
			let structureName = state/*CompileState*/.findLastStructureName(/*auto*/).orElse("");
			return tuple/*Tuple2<CompileState, Value>*/.right(/*auto*/).generateAsEnumValue(structureName/*&[I8]*/, state/*CompileState*/.platform(/*auto*/)).map((stringOption: &[I8]) => Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<CompileState, Value>*/.left(/*auto*/), stringOption/*auto*/));
		})).map((tuple: Tuple2<CompileState, List<&[I8]>>) => Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<CompileState, Value>*/.left(/*auto*/), tuple/*Tuple2<CompileState, Value>*/.right(/*auto*/).query(/*auto*/).collect(Joiner("")).orElse("")));
	}
	static def parseParameterOrPlaceholder(state: CompileState, input: &[I8]): Tuple2<CompileState, Parameter> {
		return Main/*auto*/.parseParameter(state/*CompileState*/, input/*&[I8]*/).orElseGet(() => Tuple2Impl<CompileState, Parameter>(state/*CompileState*/, Placeholder(input/*&[I8]*/)));
	}
	static def parseParameter(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Parameter>> {
		return Main/*auto*/.parseWhitespace(state/*CompileState*/, input/*&[I8]*/).map((mut tuple: Tuple2<CompileState, Whitespace>) => Main/*auto*/.getCompileStateParameterTuple2(tuple/*Tuple2<CompileState, Value>*/)).or(() => Main/*auto*/.parseDefinition(state/*CompileState*/, input/*&[I8]*/).map((mut tuple: Tuple2<CompileState, Definition>) => Tuple2Impl<CompileState, Parameter>(tuple/*Tuple2<CompileState, Value>*/.left(/*auto*/), tuple/*Tuple2<CompileState, Value>*/.right(/*auto*/))));
	}
	static def getCompileStateParameterTuple2(tuple: Tuple2<CompileState, Whitespace>): Tuple2<CompileState, Parameter> {
		return Tuple2Impl<CompileState, Parameter>(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/), tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/));
	}
	static def parseDefinition(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Definition>> {
		return Main/*auto*/.compileLast(Strings/*auto*/.strip(input/*&[I8]*/), " ", (beforeName: &[I8], name: &[I8]) => Main/*auto*/.compileSplit(Main/*auto*/.splitFoldedLast(Strings/*auto*/.strip(beforeName/*auto*/), " ", Main/*auto*/.foldTypeSeparators), (beforeType: &[I8], type: &[I8]) => Main/*auto*/.compileLast(Strings/*auto*/.strip(beforeType/*string*/), "\n", (annotationsString: &[I8], afterAnnotations: &[I8]) => {
			let annotations = Main/*auto*/.parseAnnotations(annotationsString/*&[I8]*/);
			return Main/*auto*/.parseDefinitionWithAnnotations(state/*CompileState*/, annotations/*List<&[I8]>*/, afterAnnotations/*&[I8]*/, type/*Type*/, name/*&[I8]*/);
		}).or(() => Main/*auto*/.parseDefinitionWithAnnotations(state/*CompileState*/, Lists/*auto*/.empty(/*auto*/), beforeType/*string*/, type/*Type*/, name/*&[I8]*/))).or(() => Main/*auto*/.parseDefinitionWithTypeParameters(state/*CompileState*/, Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), Lists/*auto*/.empty(/*auto*/), beforeName/*auto*/, name/*&[I8]*/)));
	}
	static def parseAnnotations(s: &[I8]): List<&[I8]> {
		return Main/*auto*/.divide(s/*&[I8]*/, (mut state1: DivideState, mut c: I8) => Main/*auto*/.foldDelimited(state1/*CompileState*/, c/*I8*/, "\n")).query(/*auto*/).map((mut s2: &[I8]) => Strings/*auto*/.strip(s2/*&[I8]*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*&[I8]*/)).filter((mut value: &[I8]) => 1/*auto*/ <= Strings/*auto*/.length(value/*&[I8]*/)).map((mut value: &[I8]) => Strings/*auto*/.sliceFrom(value/*&[I8]*/, 1/*auto*/)).map((mut s1: &[I8]) => Strings/*auto*/.strip(s1/*auto*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*&[I8]*/)).collect(ListCollector<&[I8]>(/*auto*/));
	}
	static def parseDefinitionWithAnnotations(state: CompileState, annotations: List<&[I8]>, beforeType: &[I8], type: &[I8], name: &[I8]): Option<Tuple2<CompileState, Definition>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(beforeType/*&[I8]*/), ">", (withoutTypeParamEnd: &[I8]) => Main/*auto*/.compileFirst(withoutTypeParamEnd/*auto*/, "<", (beforeTypeParams: &[I8], typeParamsString: &[I8]) => {
			let typeParams = Main/*auto*/.divideValues(typeParamsString/*&[I8]*/);
			return Main/*auto*/.parseDefinitionWithTypeParameters(state/*CompileState*/, annotations/*List<&[I8]>*/, typeParams/*List<&[I8]>*/, Main/*auto*/.parseModifiers(beforeTypeParams/*&[I8]*/), type/*&[I8]*/, name/*&[I8]*/);
		})).or(() => {
			let divided = Main/*auto*/.parseModifiers(beforeType/*&[I8]*/);
			return Main/*auto*/.parseDefinitionWithTypeParameters(state/*CompileState*/, annotations/*List<&[I8]>*/, Lists/*auto*/.empty(/*auto*/), divided/*auto*/, type/*&[I8]*/, name/*&[I8]*/);
		});
	}
	static def parseModifiers(beforeType: &[I8]): List<&[I8]> {
		return Main/*auto*/.divide(Strings/*auto*/.strip(beforeType/*&[I8]*/), (mut state1: DivideState, mut c: I8) => Main/*auto*/.foldDelimited(state1/*CompileState*/, c/*I8*/, " ")).query(/*auto*/).map((mut s: &[I8]) => Strings/*auto*/.strip(s/*&[I8]*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*&[I8]*/)).collect(ListCollector<&[I8]>(/*auto*/));
	}
	static def foldDelimited(state1: DivideState, c: I8, delimiter: I8): DivideState {
		if (delimiter/*I8*/ === c/*I8*/) {
			return state1/*DivideState*/.advance(/*auto*/);
		}
		return state1/*DivideState*/.append(c/*I8*/);
	}
	static def divideValues(input: &[I8]): List<&[I8]> {
		return Main/*auto*/.divide(input/*&[I8]*/, Main/*auto*/.foldValues).query(/*auto*/).map((mut input1: &[I8]) => Strings/*auto*/.strip(input1/*&[I8]*/)).filter((mut value: &[I8]) => !Strings/*auto*/.isEmpty(value/*&[I8]*/)).collect(ListCollector<&[I8]>(/*auto*/));
	}
	static def foldTypeSeparators(state: DivideState, c: I8): DivideState {
		if (" " === c/*I8*/ && state/*DivideState*/.isLevel(/*auto*/)) {
			return state/*DivideState*/.advance(/*auto*/);
		}
		let appended = state/*DivideState*/.append(c/*I8*/);
		if ("<" === c/*I8*/) {
			return appended/*auto*/.enter(/*auto*/);
		}
		if (">" === c/*I8*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def parseDefinitionWithTypeParameters(state: CompileState, annotations: List<&[I8]>, typeParams: List<&[I8]>, oldModifiers: List<&[I8]>, type: &[I8], name: &[I8]): Option<Tuple2<CompileState, Definition>> {
		return Main/*auto*/.parseType(state/*CompileState*/, type/*&[I8]*/).flatMap((typeTuple: Tuple2<CompileState, Type>) => {
			let newModifiers = Main/*auto*/.modifyModifiers(oldModifiers/*List<&[I8]>*/, state/*CompileState*/.platform(/*auto*/));
			let generated = Definition(annotations/*List<&[I8]>*/, newModifiers/*auto*/, typeParams/*List<&[I8]>*/, typeTuple/*Tuple2<CompileState, Type>*/.right(/*auto*/), name/*&[I8]*/);
			return Some<Tuple2<CompileState, Definition>>(Tuple2Impl<CompileState, Definition>(typeTuple/*Tuple2<CompileState, Type>*/.left(/*auto*/), generated/*auto*/));
		});
	}
	static def modifyModifiers(oldModifiers: List<&[I8]>, platform: Platform): List<&[I8]> {
		let list = Main/*auto*/.retainFinal(oldModifiers/*List<&[I8]>*/, platform/*Platform*/);
		if (oldModifiers/*List<&[I8]>*/.contains("static", Strings/*auto*/.equalsTo)) {
			return list/*auto*/.addLast("static");
		}
		return list/*auto*/;
	}
	static def retainFinal(oldModifiers: List<&[I8]>, platform: Platform): List<&[I8]> {
		if (oldModifiers/*List<&[I8]>*/.contains("final", Strings/*auto*/.equalsTo) || Platform/*auto*/.Magma !== platform/*Platform*/) {
			return Lists/*auto*/.empty(/*auto*/);
		}
		return Lists/*auto*/.of("mut");
	}
	static def parseTypeOrPlaceholder(state: CompileState, type: &[I8]): Tuple2<CompileState, Type> {
		return Main/*auto*/.parseType(state/*CompileState*/, type/*&[I8]*/).map((mut tuple: Tuple2<CompileState, Type>) => Tuple2Impl<CompileState, Type>(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/), tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/))).orElseGet(() => Tuple2Impl<CompileState, Type>(state/*CompileState*/, Placeholder(type/*&[I8]*/)));
	}
	static def compileType(state: CompileState, type: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.parseType(state/*CompileState*/, type/*&[I8]*/).map((mut tuple: Tuple2<CompileState, Type>) => Tuple2Impl<CompileState, &[I8]>(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/), tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/).generate(/*auto*/)));
	}
	static def parseType(state: CompileState, type: &[I8]): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.or(state/*CompileState*/, type/*&[I8]*/, Lists/*auto*/.of(Main/*auto*/.parseArrayType, Main/*auto*/.parseVarArgs, Main/*auto*/.parseGeneric, Main/*auto*/.parsePrimitive, Main/*auto*/.parseSymbolType));
	}
	static def parseArrayType(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		let stripped = Strings/*auto*/.strip(input/*&[I8]*/);
		return Main/*auto*/.compileSuffix(stripped/*auto*/, "[]", (s: &[I8]) => {
			let child = Main/*auto*/.parseTypeOrPlaceholder(state/*CompileState*/, s/*&[I8]*/);
			return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(child/*&[I8]*/.left(/*auto*/), ArrayType(child/*&[I8]*/.right(/*auto*/))));
		});
	}
	static def parseVarArgs(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		let stripped = Strings/*auto*/.strip(input/*&[I8]*/);
		return Main/*auto*/.compileSuffix(stripped/*auto*/, "...", (s: &[I8]) => {
			let child = Main/*auto*/.parseTypeOrPlaceholder(state/*CompileState*/, s/*&[I8]*/);
			return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(child/*&[I8]*/.left(/*auto*/), VariadicType(child/*&[I8]*/.right(/*auto*/))));
		});
	}
	static def parseSymbolType(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		let stripped = Strings/*auto*/.strip(input/*&[I8]*/);
		if (Main/*auto*/.isSymbol(stripped/*auto*/)) {
			let symbolNode = SymbolNode(stripped/*auto*/, PrimitiveType/*auto*/.Auto);
			return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(state/*CompileState*/.addResolvedImportFromCache(stripped/*auto*/), symbolNode/*auto*/));
		}
		return None<Tuple2<CompileState, Type>>(/*auto*/);
	}
	static def parsePrimitive(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.findPrimitiveValue(Strings/*auto*/.strip(input/*&[I8]*/), state/*CompileState*/.platform(/*auto*/)).map((mut result: Type) => Tuple2Impl<CompileState, Type>(state/*CompileState*/, result/*Tuple2<CompileState, &[I8]>*/));
	}
	static def findPrimitiveValue(input: &[I8], platform: Platform): Option<Type> {
		let stripped = Strings/*auto*/.strip(input/*&[I8]*/);
		if (Strings/*auto*/.equalsTo("char", stripped/*auto*/) || Strings/*auto*/.equalsTo("Character", stripped/*auto*/)) {
			if (Platform/*auto*/.TypeScript === platform/*Platform*/) {
				return Some<Type>(PrimitiveType/*auto*/.String);
			}
			else {
				return Some<Type>(PrimitiveType/*auto*/.I8);
			}
		}
		if (Strings/*auto*/.equalsTo("String", stripped/*auto*/)) {
			if (Platform/*auto*/.TypeScript === platform/*Platform*/) {
				return Some<Type>(PrimitiveType/*auto*/.String);
			}
			else {
				return Some<Type>(SliceType(PrimitiveType/*auto*/.I8));
			}
		}
		if (Strings/*auto*/.equalsTo("int", stripped/*auto*/) || Strings/*auto*/.equalsTo("Integer", stripped/*auto*/)) {
			if (Platform/*auto*/.Magma === platform/*Platform*/) {
				return Some<Type>(PrimitiveType/*auto*/.I32);
			}
			else {
				return Some<Type>(PrimitiveType/*auto*/.Number);
			}
		}
		if (Strings/*auto*/.equalsTo("boolean", stripped/*auto*/) || Strings/*auto*/.equalsTo("Boolean", stripped/*auto*/)) {
			return Some<Type>(BooleanType(platform/*Platform*/));
		}
		if (Strings/*auto*/.equalsTo("var", stripped/*auto*/)) {
			return Some<Type>(PrimitiveType/*auto*/.Var);
		}
		if (Strings/*auto*/.equalsTo("void", stripped/*auto*/)) {
			return Some<Type>(PrimitiveType/*auto*/.Void);
		}
		return None<Type>(/*auto*/);
	}
	static def parseGeneric(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.compileSuffix(Strings/*auto*/.strip(input/*&[I8]*/), ">", (withoutEnd: &[I8]) => Main/*auto*/.compileFirst(withoutEnd/*&[I8]*/, "<", (baseString: &[I8], argsString: &[I8]) => {
			let argsTuple = Main/*auto*/.parseValuesOrEmpty(state/*CompileState*/, argsString/*&[I8]*/, (mut state1: CompileState, mut s: &[I8]) => Main/*auto*/.compileTypeArgument(state1/*DivideState*/, s/*&[I8]*/));
			let argsState = argsTuple/*Tuple2<CompileState, List<Argument>>*/.left(/*auto*/);
			let args = argsTuple/*Tuple2<CompileState, List<Argument>>*/.right(/*auto*/);
			let base = Strings/*auto*/.strip(baseString/*&[I8]*/);
			return Main/*auto*/.assembleFunctionType(argsState/*auto*/, base/*&[I8]*/, args/*List<T>*/).or(() => {
				let compileState = argsState/*auto*/.addResolvedImportFromCache(base/*&[I8]*/);
				return Some<Tuple2<CompileState, Type>>(Tuple2Impl<CompileState, Type>(compileState/*auto*/, TemplateType(base/*&[I8]*/, args/*List<T>*/)));
			});
		}));
	}
	static def assembleFunctionType(state: CompileState, base: &[I8], args: List<&[I8]>): Option<Tuple2<CompileState, Type>> {
		return Main/*auto*/.mapFunctionType(base/*&[I8]*/, args/*List<&[I8]>*/).map((mut generated: Type) => Tuple2Impl<CompileState, Type>(state/*CompileState*/, generated/*auto*/));
	}
	static def mapFunctionType(base: &[I8], args: List<&[I8]>): Option<Type> {
		if (Strings/*auto*/.equalsTo("Function", base/*&[I8]*/)) {
			return args/*List<&[I8]>*/.findFirst(/*auto*/).and(() => args/*List<&[I8]>*/.find(1/*auto*/)).map((mut tuple: Tuple2<&[I8], &[I8]>) => FunctionType(Lists/*auto*/.of(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/)), tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/)));
		}
		if (Strings/*auto*/.equalsTo("BiFunction", base/*&[I8]*/)) {
			return args/*List<&[I8]>*/.find(0/*auto*/).and(() => args/*List<&[I8]>*/.find(1/*auto*/)).and(() => args/*List<&[I8]>*/.find(2/*auto*/)).map((mut tuple: Tuple2<Tuple2<&[I8], &[I8]>, &[I8]>) => FunctionType(Lists/*auto*/.of(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/).left(/*auto*/), tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/).right(/*auto*/)), tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/)));
		}
		if (Strings/*auto*/.equalsTo("Supplier", base/*&[I8]*/)) {
			return args/*List<&[I8]>*/.findFirst(/*auto*/).map((first: &[I8]) => FunctionType(Lists/*auto*/.empty(/*auto*/), first/*auto*/));
		}
		if (Strings/*auto*/.equalsTo("Consumer", base/*&[I8]*/)) {
			return args/*List<&[I8]>*/.findFirst(/*auto*/).map((first: &[I8]) => FunctionType(Lists/*auto*/.of(first/*auto*/), "void"));
		}
		if (Strings/*auto*/.equalsTo("Predicate", base/*&[I8]*/)) {
			return args/*List<&[I8]>*/.findFirst(/*auto*/).map((first: &[I8]) => FunctionType(Lists/*auto*/.of(first/*auto*/), "boolean"));
		}
		return None<Type>(/*auto*/);
	}
	static def compileTypeArgument(state: CompileState, input: &[I8]): Option<Tuple2<CompileState, &[I8]>> {
		return Main/*auto*/.or(state/*CompileState*/, input/*&[I8]*/, Lists/*auto*/.of((mut state2: CompileState, mut input1: &[I8]) => Main/*auto*/.compileWhitespace(state2/*auto*/, input1/*&[I8]*/), (mut state1: CompileState, mut type: &[I8]) => Main/*auto*/.compileType(state1/*DivideState*/, type/*&[I8]*/)));
	}
	static def parseValuesOrEmpty<T>(state: CompileState, input: &[I8], mapper: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Tuple2<CompileState, List<T>> {
		return Main/*auto*/.parseValues(state/*CompileState*/, input/*&[I8]*/, mapper/*(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>*/).orElse(Tuple2Impl<CompileState, List<T>>(state/*CompileState*/, Lists/*auto*/.empty(/*auto*/)));
	}
	static def parseValues<T>(state: CompileState, input: &[I8], mapper: (arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>): Option<Tuple2<CompileState, List<T>>> {
		return Main/*auto*/.parseAll(state/*CompileState*/, input/*&[I8]*/, Main/*auto*/.foldValues, mapper/*(arg0 : CompileState, arg1 : &[I8]) => Option<Tuple2<CompileState, T>>*/);
	}
	static def foldValues(state: DivideState, c: I8): DivideState {
		if ("," === c/*I8*/ && state/*DivideState*/.isLevel(/*auto*/)) {
			return state/*DivideState*/.advance(/*auto*/);
		}
		let appended = state/*DivideState*/.append(c/*I8*/);
		if ("-" === c/*I8*/) {
			let peeked = appended/*auto*/.peek(/*auto*/);
			if (">" === peeked/*auto*/) {
				return appended/*auto*/.popAndAppendToOption(/*auto*/).orElse(appended/*auto*/);
			}
			else {
				return appended/*auto*/;
			}
		}
		if ("<" === c/*I8*/ || "(" === c/*I8*/) {
			return appended/*auto*/.enter(/*auto*/);
		}
		if (">" === c/*I8*/ || ")" === c/*I8*/) {
			return appended/*auto*/.exit(/*auto*/);
		}
		return appended/*auto*/;
	}
	static def compileLast<T>(input: &[I8], infix: &[I8], mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return Main/*auto*/.compileInfix(input/*&[I8]*/, infix/*&[I8]*/, Main/*auto*/.findLast, mapper/*(arg0 : &[I8], arg1 : &[I8]) => Option<T>*/);
	}
	static def findLast(input: &[I8], infix: &[I8]): I32 {
		return input/*&[I8]*/.lastIndexOf(infix/*&[I8]*/);
	}
	static def compileSuffix<T>(input: &[I8], suffix: &[I8], mapper: (arg0 : &[I8]) => Option<T>): Option<T> {
		if (!input/*&[I8]*/.endsWith(suffix/*&[I8]*/)) {
			return None<T>(/*auto*/);
		}
		let length = Strings/*auto*/.length(input/*&[I8]*/);
		let length1 = Strings/*auto*/.length(suffix/*&[I8]*/);
		let content = Strings/*auto*/.sliceBetween(input/*&[I8]*/, 0/*auto*/, length/*I32*/ - length1/*auto*/);
		return mapper/*(arg0 : &[I8]) => Option<T>*/(content/*&[I8]*/);
	}
	static def compileFirst<T>(input: &[I8], infix: &[I8], mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return Main/*auto*/.compileInfix(input/*&[I8]*/, infix/*&[I8]*/, Main/*auto*/.findFirst, mapper/*(arg0 : &[I8], arg1 : &[I8]) => Option<T>*/);
	}
	static def compileInfix<T>(input: &[I8], infix: &[I8], locator: (arg0 : &[I8], arg1 : &[I8]) => I32, mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return Main/*auto*/.compileSplit(Main/*auto*/.split(input/*&[I8]*/, infix/*&[I8]*/, locator/*(arg0 : &[I8], arg1 : &[I8]) => I32*/), mapper/*(arg0 : &[I8], arg1 : &[I8]) => Option<T>*/);
	}
	static def compileSplit<T>(splitter: Option<Tuple2<&[I8], &[I8]>>, mapper: (arg0 : &[I8], arg1 : &[I8]) => Option<T>): Option<T> {
		return splitter/*Option<Tuple2<&[I8], &[I8]>>*/.flatMap((mut tuple: Tuple2<&[I8], &[I8]>) => mapper/*(arg0 : &[I8], arg1 : &[I8]) => Option<T>*/(tuple/*Tuple2<CompileState, Whitespace>*/.left(/*auto*/), tuple/*Tuple2<CompileState, Whitespace>*/.right(/*auto*/)));
	}
	static def split(input: &[I8], infix: &[I8], locator: (arg0 : &[I8], arg1 : &[I8]) => I32): Option<Tuple2<&[I8], &[I8]>> {
		let index = locator/*(arg0 : &[I8], arg1 : &[I8]) => I32*/(input/*&[I8]*/, infix/*&[I8]*/);
		if (0/*auto*/ > index/*I32*/) {
			return None<Tuple2<&[I8], &[I8]>>(/*auto*/);
		}
		let left = Strings/*auto*/.sliceBetween(input/*&[I8]*/, 0/*auto*/, index/*I32*/);
		let length = Strings/*auto*/.length(infix/*&[I8]*/);
		let right = Strings/*auto*/.sliceFrom(input/*&[I8]*/, index/*I32*/ + length/*I32*/);
		return Some<Tuple2<&[I8], &[I8]>>(Tuple2Impl<&[I8], &[I8]>(left/*auto*/, right/*auto*/));
	}
	static def findFirst(input: &[I8], infix: &[I8]): I32 {
		return input/*&[I8]*/.indexOf(infix/*&[I8]*/);
	}
	static def generatePlaceholder(input: &[I8]): &[I8] {
		let replaced = input/*&[I8]*/.replace("/*", "start").replace("*/", "end");
		return "/*" + replaced/*auto*/ + "*/";
	}
}
Main.main();