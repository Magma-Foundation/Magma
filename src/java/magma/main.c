#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
struct Main {
};
struct Main new(){
}
struct State {
};
int temp;
int temp;
int temp;
int temp;
struct State new(){
}
struct public State_State(){
	temp();
}
struct void State_popAndAppend(){
	temp();
}
struct Character State_pop(){
	return temp;
}
struct boolean State_isEmpty(){
	return temp;
}
struct void State_append(){
	temp();
}
struct State new(){
}
struct State new(){
}
struct State new(){
}
struct boolean State_isShallow(){
	return temp;
}
struct boolean State_isLevel(){
	return temp;
}
struct Temp State_segments(){
	return temp;
}
struct Main new(){
}
struct Main new(){
}
struct record Main_Node(){
}
struct Main new(){
}
struct void __main__(){
	struct Path source = Paths.get();
	temp();
}
struct Temp Main_runWithSource(){
	struct String string = compile();
	struct Path target = source.resolveSibling();
	return temp;
}
struct Main new(){
}
struct Temp Main_compileRootSegment(){
	struct Temp maybeWhitespace = compileWhitespace();
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	struct Temp maybeClass = compileClass();
	if (1) {
	}
	return temp;
}
struct Temp Main_compileClass(){
	struct int classIndex = input.indexOf();
	if (1) {
	}
	struct String afterKeyword = input.substring();
	struct int contentStart = afterKeyword.indexOf();
	if (1) {
	}
	struct String name = afterKeyword.substring();
	if (1) {
	}
	struct String withEnd = afterKeyword.substring();
	if (1) {
	}
	struct String inputContent = withEnd.substring();
	return temp;
}
struct Temp Main_invalidate(){
	temp();
	return temp;
}
struct Temp Main_compileClassSegment(){
	struct Temp maybeWhitespace = compileWhitespace();
	if (1) {
	}
	struct Temp maybeClass = compileClass();
	if (1) {
	}
	struct Temp inputType = compileMethod();
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	return temp;
}
struct Temp Main_compileMethod(){
	struct int paramStart = input.indexOf();
	if (1) {
	}
	struct String header = input.substring();
	return temp;
}
struct Temp Main_compileDefinition(){
	return temp;
}
struct Temp Main_parseDefinition(){
	struct int nameSeparator = header.lastIndexOf();
	if (1) {
	}
	struct String beforeName = header.substring();
	struct String oldName = header.substring();
	struct int typeSeparator = beforeName.lastIndexOf();
	struct String inputType = condition ? whenTrue : whenFalse();
	return temp;
}
struct Node Main_modifyDefinition(){
	struct String newName = condition ? whenTrue : whenFalse;
	return temp;
}
struct Temp Main_compileStatement(){
	struct Temp maybeWhitespace = compileWhitespace();
	if (1) {
	}
	struct String stripped = input.strip();
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	return temp;
}
struct Temp Main_compileValue(){
	if (1) {
	}
	if (1) {
	}
	struct int propertySeparator = value.indexOf();
	if (1) {
	}
	struct String stripped = value.strip();
	if (1) {
	}
	return temp;
}
struct String Main_generateMethod(){
	return temp;
}
struct Temp Main_generateDefinition(){
	return temp;
}
struct Temp Main_compileType(){
	struct String stripped = type.strip();
	if (1) {
	}
	if (1) {
	}
	return temp;
}
struct Temp Main_generateStructType(){
	return temp;
}
struct boolean Main_isSymbol(){
	for(;;){
	}
	return temp;
}
struct Temp Main_compileWhitespace(){
	if (1) {
	}
	return temp;
}
int main(){
	__main__();
	return 0;
}
