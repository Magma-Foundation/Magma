struct Option_struct R {
};
struct Option_struct Type {
};
struct Option_char* {
};
struct Defined extends Assignable {
};
struct Value extends Assignable {
};
struct Node {
};
struct Assignable extends Node {
};
struct Type extends Node {
};
struct Tuple_char_struct State {
};
struct Option_struct Tuple_char_struct State {
};
struct Option_/*  */ {
};
struct None_/*  */ {
};
struct Some_/*  */ {
};
struct Tuple_/*  */ {
};
struct Option_struct State {
};
struct Option_char {
};
struct State {
};
struct Joiner {
};
struct Definition {
};
struct Content {
};
struct Whitespace implements Defined, Value {
};
struct StringValue {
};
struct Symbol {
};
struct Invocation {
};
struct DataAccess {
};
struct Operation {
};
struct Collector_/*  */_struct C {
};
struct Option_struct T {
};
struct EmptyHead_/*  */ {
};
struct Collector_struct T_struct C {
};
struct Iterator_struct T {
};
struct Iterator_/*  */ {
};
struct Iterator_struct R {
};
struct Iterator_char {
};
struct Iterators {
};
struct CharValue {
};
struct Not {
};
struct Collector_struct Definition_struct C {
};
struct Option_struct Definition {
};
struct Iterator_struct Definition {
};
struct Option_int {
};
struct Collector_int_struct C {
};
struct Iterator_int {
};
struct Tuple_int_int {
};
struct Collector_struct Tuple_int_int_struct C {
};
struct Option_struct Tuple_int_int {
};
struct Iterator_struct Tuple_int_int {
};
struct List_int {
};
struct Tuple_int_struct Tuple_int_int {
};
struct Collector_struct Tuple_int_struct Tuple_int_int_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_int {
};
struct Iterator_struct Tuple_int_struct Tuple_int_int {
};
struct List_struct Tuple_int_int {
};
struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_int_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct List_struct Tuple_int_struct Tuple_int_int {
};
struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct List_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int {
};
struct List_struct Definition {
};
struct StructType implements Type {
	char* name;
	struct List_struct Definition properties;
};
struct Ref {
};
struct Functional {
};
struct CompileError {
};
struct Option_struct IOException {
};
struct Result_char*_struct IOException {
};
struct Ok_/*  */ {
};
struct Err_/*  */ {
};
struct Collector_char*_struct C {
};
struct Iterator_char* {
};
struct Tuple_int_char* {
};
struct Collector_struct Tuple_int_char*_struct C {
};
struct Option_struct Tuple_int_char* {
};
struct Iterator_struct Tuple_int_char* {
};
struct List_char* {
};
struct Tuple_int_struct Tuple_int_char* {
};
struct Collector_struct Tuple_int_struct Tuple_int_char*_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_char* {
};
struct Iterator_struct Tuple_int_struct Tuple_int_char* {
};
struct List_struct Tuple_int_char* {
};
struct Tuple_int_struct T {
};
struct Collector_struct Tuple_int_struct T_struct C {
};
struct Option_struct Tuple_int_struct T {
};
struct Iterator_struct Tuple_int_struct T {
};
struct List_struct T {
};
struct Tuple_int_struct Tuple_int_struct T {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct T_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct T {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct T {
};
struct List_struct Tuple_int_struct T {
};
struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct List_struct Tuple_int_struct Tuple_int_struct T {
};
struct ListCollector_/*  */ {
};
struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct List_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct List_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T {
};
struct Option_struct Whitespace {
};
struct Result_struct Whitespace_struct CompileError {
};
struct Option_struct Invocation {
};
struct Some_struct Invocation {
};
struct Collector_struct Type_struct C {
};
struct Iterator_struct Type {
};
struct Tuple_int_struct Type {
};
struct Collector_struct Tuple_int_struct Type_struct C {
};
struct Option_struct Tuple_int_struct Type {
};
struct Iterator_struct Tuple_int_struct Type {
};
struct List_struct Type {
};
struct Tuple_int_struct Tuple_int_struct Type {
};
struct Collector_struct Tuple_int_struct Tuple_int_struct Type_struct C {
};
struct Option_struct Tuple_int_struct Tuple_int_struct Type {
};
struct Iterator_struct Tuple_int_struct Tuple_int_struct Type {
};
struct List_struct Tuple_int_struct Type {
};
struct Main {
	/* private static String functionName = "" */;
	/* private static int functionLocalCounter = 0 */;
};
struct State fromInput(struct State this, char* input){
	return new_State(input, listEmpty(), "", 0, 0);
}
struct Option_struct R map(struct None_/*  */ this, struct R (*)(/*  */) mapper){
	return new_None_/*  */();
}
/*  */ orElse(struct None_/*  */ this, /*  */ other){
	return other;
}
/*  */ orElseGet(struct None_/*  */ this, struct Supplier_/*  */ supplier){
	return supplier.get(supplier);
}
struct Option_struct R flatMap(struct None_/*  */ this, struct Option_struct R (*)(/*  */) mapper){
	return new_None_/*  */();
}
struct Option_/*  */ or(struct None_/*  */ this, struct Supplier_struct Option_/*  */ supplier){
	return supplier.get(supplier);
}
void ifPresent(struct None_/*  */ this, struct Consumer_/*  */ consumer){
}
struct Option_struct R map(struct Some_/*  */ this, struct R (*)(/*  */) mapper){
	return new_Some_/*  */(mapper.apply(mapper, this.value));
}
/*  */ orElse(struct Some_/*  */ this, /*  */ other){
	return this.value;
}
/*  */ orElseGet(struct Some_/*  */ this, struct Supplier_/*  */ supplier){
	return this.value;
}
struct Option_struct R flatMap(struct Some_/*  */ this, struct Option_struct R (*)(/*  */) mapper){
	return mapper.apply(mapper, this.value);
}
struct Option_/*  */ or(struct Some_/*  */ this, struct Supplier_struct Option_/*  */ supplier){
	return this;
}
void ifPresent(struct Some_/*  */ this, struct Consumer_/*  */ consumer){
	consumer.accept(consumer, this.value);
}
struct Option_struct Tuple_char_struct State pop(struct State this){
	if (this.index >= this.input.length(this.index >= this.input)){
		return new_None_/*  */();
	}
	/* this.input.charAt(this.input, this.index) */ escaped = this.input.charAt(this.input, this.index);
	return new_Some_/*  */(new_Tuple_char_struct State(escaped, new_State(this.input, this.segments, this.buffer, this.depth, this.index + 1)));
}
struct State append(struct State this, char c){
	return new_State(this.input, this.segments, this.buffer + c, this.depth, this.index);
}
auto popAndAppendToTuple_local1(Content[input=tuple -> {
                var poppedChar = tuple.left;
                var poppedState = tuple.right;
                var appended = poppedState.append(poppedChar);
                return new Tuple<>(poppedChar, appended);
            }] tuple){
	/* tuple.left */ poppedChar = tuple.left;
	/* tuple.right */ poppedState = tuple.right;
	/* poppedState.append(poppedState, poppedChar) */ appended = poppedState.append(poppedState, poppedChar);
	return new_Tuple_/*  */(poppedChar, appended);
}
struct Option_struct Tuple_char_struct State popAndAppendToTuple(struct State this){
	struct Option_struct Tuple_char_struct State popAndAppendToTuple_local3 = this.pop(this);
	return popAndAppendToTuple_local3.map(popAndAppendToTuple_local3, popAndAppendToTuple_local1);
}
int isLevel(struct State this){
	return this.depth == 0;
}
struct State enter(struct State this){
	return new_State(this.input, this.segments, this.buffer, this.depth + 1, this.index);
}
struct State exit(struct State this){
	return new_State(this.input, this.segments, this.buffer, /* this.depth - 1 */, this.index);
}
struct State advance(struct State this){
	return new_State(this.input, this.segments.addLast(this.segments, this.buffer), "", this.depth, this.index);
}
int isShallow(struct State this){
	return this.depth == 1;
}
struct Option_struct State popAndAppend(struct State this){
	struct Option_struct Tuple_char_struct State popAndAppend_local1 = this.popAndAppendToTuple(this);
	return popAndAppend_local1.map(popAndAppend_local1, /* Tuple::right */);
}
struct Option_char peek(struct State this){
	if (this.index < this.input.length(this.index < this.input)){
		return new_Some_/*  */(this.input.charAt(this.input, this.index));
	}
	else {
		return new_None_/*  */();
	}
}
struct Option_char* createInitial(struct Joiner this){
	return new_None_/*  */();
}
/* inner */ fold_local0(Content[input=inner -> inner + this.delimiter + element] inner){
	return inner + this.delimiter + element;
}
struct Option_char* fold(struct Joiner this, struct Option_char* current, char* element){
	/* current.map(current, fold_local0) */ fold_local2 = current.map(current, fold_local0);
	return new_Some_/*  */(fold_local2.orElse(fold_local2, element));
}
char* generate(struct Definition this){
	/* this.type.generate(this.type) */ generate_local1 = this.type.generate(this.type) + " " + this;
	return generate_local1.name(generate_local1);
}
struct Option_struct Type findType(struct Definition this){
	return new_Some_/*  */(this.type);
}
struct Option_char* findName(struct Definition this){
	return new_Some_/*  */(this.name);
}
char* generate(struct Content this){
	return generatePlaceholder(this.input);
}
struct Option_struct Type findType(struct Content this){
	return new_None_/*  */();
}
struct Option_char* findName(struct Content this){
	return new_None_/*  */();
}
char* stringify(struct Content this){
	return generatePlaceholder(this.input);
}
char* generate(struct Whitespace implements Defined, Value this){
	return "";
}
struct Option_struct Type findType(struct Whitespace implements Defined, Value this){
	return new_None_/*  */();
}
struct Option_char* findName(struct Whitespace implements Defined, Value this){
	return new_None_/*  */();
}
char* generate(struct StringValue this){
	return "\"" + this.value + "\"";
}
char* generate(struct Symbol this){
	return this.value;
}
char* generate(struct Invocation this){
	return this.caller.generate(this.caller) + "(" + generateValueList(this.args) + ")";
}
char* generate(struct DataAccess this){
	return this.parent.generate(this.parent) + "." + this.property;
}
char* generate(struct Operation this){
	return this.left.generate(this.left) + " " + this.operator.representation + " " + this.right.generate(this.left.generate(this.left) + " " + this.operator.representation + " " + this.right);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_/*  */ this, struct R (*)(/*  */) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_/*  */ this, struct Collector_/*  */_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_/*  */ this, struct R initial, struct R (*)(struct R, /*  */) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_/*  */ filter(struct Iterator_/*  */ this, struct Predicate_/*  */ predicate){
	return this.flatMap(this, filter_local0);
}
struct Option_struct T next(struct EmptyHead_/*  */ this){
	return new_None_/*  */();
}
struct Iterator_struct R flatMap(struct Iterator_/*  */ this, struct Iterator_struct R (*)(/*  */) mapper){
	struct Iterator_struct R next_local0 = this.map(this, mapper);
	return next_local0.fold(next_local0, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct T this, struct R (*)(struct T) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct T this, struct Collector_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct T this, struct R initial, struct R (*)(struct R, struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct T filter(struct Iterator_struct T this, struct Predicate_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct T this, struct Iterator_struct R (*)(struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct T concat(struct Iterator_struct T this, struct Iterator_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct T next(struct Iterator_struct T this){
	return this.head.next(this.head);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct T concat(struct Iterator_/*  */ this, struct Iterator_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct T next(struct Iterator_/*  */ this){
	return this.head.next(this.head);
}
/* next_local2.map(next_local2, mapper) */ next_local3(){
	return next_local2.map(next_local2, next_local2, mapper);
}
struct Iterator_struct R map(struct Iterator_struct R this, struct R (*)(struct R) mapper){
	/* this.head.next(this.head) */ next_local2 = this.head.next(this.head);
	return new_Iterator_/*  */(next_local3);
}
struct C collect(struct Iterator_struct R this, struct Collector_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct R this, struct R initial, struct R (*)(struct R, struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct T filter(struct Iterator_struct R this, struct Predicate_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct R this, struct Iterator_struct R (*)(struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct T concat(struct Iterator_struct R this, struct Iterator_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct T next(struct Iterator_struct R this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_char this, struct R (*)(struct T) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_char this, struct Collector_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_char this, struct R initial, struct R (*)(struct R, struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct T filter(struct Iterator_char this, struct Predicate_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_char this, struct Iterator_struct R (*)(struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct T concat(struct Iterator_char this, struct Iterator_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct T next(struct Iterator_char this){
	return this.head.next(this.head);
}
/* array[index] */ fromArray_local0(Content[input=index -> array[index]] index){
	return /* /* array[index] */ */;
}
struct Iterator_char fromArray(struct Iterators this, /* T[] */ array){
	return new_/* Iterator<>(new RangeHead(array.length)).map */(fromArray_local0);
}
/* new EmptyHead */ fromOption_local0(Content[input=switch (option) {
                case None<T> _ -> new EmptyHead<T>();
                case Some<T>(var value) -> new SingleHead<>(value);
            }] _){
	return /* /* new EmptyHead */ */;
}
/* new SingleHead */ fromOption_local1(Content[input=switch (option) {
                case None<T> _ -> new EmptyHead<T>();
                case Some<T>(var value) -> new SingleHead<>(value);
            }] var value){
	return /* /* new SingleHead */ */;
}
struct Iterator_struct T fromOption(struct Iterators this, struct Option_struct T option){
	return new_Iterator_/*  */(/* switch (option) {
                case None */ < T > fromOption_local0 < T > /* ();
                case Some */ < T > fromOption_local1 <  > /* (value);
            } */);
}
char* generate(struct CharValue this){
	return "'" + this.slice + "'";
}
char* generate(struct Not this){
	return "!" + this.value.generate("!" + this.value);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Definition this, struct R (*)(struct Definition) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Definition this, struct Collector_struct Definition_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Definition this, struct R initial, struct R (*)(struct R, struct Definition) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Definition filter(struct Iterator_struct Definition this, struct Predicate_struct Definition predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Definition this, struct Iterator_struct R (*)(struct Definition) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Definition concat(struct Iterator_struct Definition this, struct Iterator_struct Definition other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Definition next(struct Iterator_struct Definition this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_int this, struct R (*)(int) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_int this, struct Collector_int_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_int this, struct R initial, struct R (*)(struct R, int) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_int filter(struct Iterator_int this, struct Predicate_int predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_int this, struct Iterator_struct R (*)(int) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_int concat(struct Iterator_int this, struct Iterator_int other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_int next(struct Iterator_int this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_int this, struct R (*)(struct Tuple_int_int) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_int this, struct Collector_struct Tuple_int_int_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_int this, struct R initial, struct R (*)(struct R, struct Tuple_int_int) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_int filter(struct Iterator_struct Tuple_int_int this, struct Predicate_struct Tuple_int_int predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_int this, struct Iterator_struct R (*)(struct Tuple_int_int) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_int concat(struct Iterator_struct Tuple_int_int this, struct Iterator_struct Tuple_int_int other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_int next(struct Iterator_struct Tuple_int_int this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_int this, struct R (*)(struct Tuple_int_struct Tuple_int_int) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_int this, struct Collector_struct Tuple_int_struct Tuple_int_int_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_int this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_int) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_int filter(struct Iterator_struct Tuple_int_struct Tuple_int_int this, struct Predicate_struct Tuple_int_struct Tuple_int_int predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_int) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_int concat(struct Iterator_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct Tuple_int_struct Tuple_int_int other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_int next(struct Iterator_struct Tuple_int_struct Tuple_int_int this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_int) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_int_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct Tuple_int_int) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Predicate_struct Tuple_int_struct Tuple_int_struct Tuple_int_int predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_int) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_int next(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Predicate_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int next(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Predicate_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this, struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int next(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_int this){
	return this.head.next(this.head);
}
struct private StructType(struct StructType implements Type this, char* name, struct List_struct Definition properties){
	this.name = name;
	this.properties = properties;
}
struct public StructType(struct StructType implements Type this, char* name){
	this(name, listEmpty());
}
char* generate(struct StructType implements Type this){
	return "struct " + this.name;
}
char* stringify(struct StructType implements Type this){
	return this.name;
}
/* definition.name.equals(definition.name, name) */ find_local2(Content[input=definition -> definition.name.equals(name)] definition){
	return definition.name.equals(definition.name, definition.name, name);
}
struct Option_struct Type find(struct StructType implements Type this, char* name){
	/* this.properties.iter(this.properties) */ find_local4 = this.properties.iter(this.properties);
	/* find_local4.filter(find_local4, find_local2) */ find_local5 = find_local4.filter(find_local4, find_local2);
	/* find_local5.map(find_local5, /* Definition::findType */) */ find_local6 = find_local5.map(find_local5, /* Definition::findType */);
	/* find_local6.flatMap(find_local6, /* Iterators::fromOption */) */ find_local7 = find_local6.flatMap(find_local6, /* Iterators::fromOption */);
	return find_local7.next(find_local7);
}
struct StructType define(struct StructType implements Type this, struct Definition definition){
	return new_StructType(this.name, this.properties.addLast(this.properties, definition));
}
int equals(struct StructType implements Type this, struct Object obj){
	int equals_local1 = obj == null || obj.getClass(obj) != this;
	int equals_local3 = Objects.equals(Objects, this.name, that.name) && Objects;
	if (obj == this){
		return 1;
	}
	if (equals_local1.getClass(equals_local1)){
		return 0;
	}
	/* (StructType) obj */ that = /* (StructType) obj */;
	return equals_local3.equals(equals_local3, this.properties, that.properties);
}
int hashCode(struct StructType implements Type this){
	return Objects.hash(Objects, this.name, this.properties);
}
char* stringify(struct Ref this){
	return this.type.stringify(this.type) + "_star";
}
char* generate(struct Ref this){
	return this.type.generate(this.type) + "*";
}
char* generate(struct Functional this){
	/* generateValueList(this.paramTypes(this)) */ generated = generateValueList(this.paramTypes(this));
	return this.returns.generate(this.returns) + " (*)(" + generated + ")";
}
char* stringify(struct Functional this){
	return "_Func_" + generateValueList(this.paramTypes) + "_" + this.returns.stringify() + "_";
}
struct public CompileError(struct CompileError this, char* message, char* context){
	this(message, context, listEmpty());
}
/* new Some */ run_local0(? var error){
	return /* /* new Some */ */;
}
struct Option_struct IOException run(struct Main this){
	/* return switch (readString()) */{
		/* case Err */ < /* String, IOException */ > run_local0 <  > (error);
		/* case Ok<String, IOException>(var input) -> */{
			/* compileRoot(input) */ output = compileRoot(input);
			/* yield writeTarget */(output);
		}
	}
	/* ; */
}
void main(struct Main this){
	/* run() */ main_local0 = run();
	main_local0.ifPresent(main_local0, /* Throwable::printStackTrace */);
}
struct Option_struct IOException writeTarget(struct Main this, char* csq){
	/* try */{
		Files.writeString(Files, Main.TARGET, csq);
		return new_None_/*  */();
	}
	/* catch (IOException e) */{
		return new_Some_/*  */(e);
	}
}
struct Option_/*  */ findValue(struct Ok_/*  */ this){
	return new_Some_/*  */(this.value);
}
struct Option_/*  */ findValue(struct Err_/*  */ this){
	return new_None_/*  */();
}
struct Result_char*_struct IOException readString(struct Main this){
	/* try */{
		return new_Ok_/*  */(Files.readString(Files, Main.SOURCE));
	}
	/* catch (IOException e) */{
		return new_Err_/*  */(e);
	}
}
char* compileRoot(struct Main this, char* input){
	/* compileStatements(input, /* Main::compileRootSegment */) */ compiled = compileStatements(input, /* Main::compileRootSegment */);
	return compiled + join(structs) + join(methods);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_char* this, struct R (*)(char*) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_char* this, struct Collector_char*_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_char* this, struct R initial, struct R (*)(struct R, char*) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_char* filter(struct Iterator_char* this, struct Predicate_char* predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_char* this, struct Iterator_struct R (*)(char*) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_char* concat(struct Iterator_char* this, struct Iterator_char* other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_char* next(struct Iterator_char* this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_char* this, struct R (*)(struct Tuple_int_char*) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_char* this, struct Collector_struct Tuple_int_char*_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_char* this, struct R initial, struct R (*)(struct R, struct Tuple_int_char*) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_char* filter(struct Iterator_struct Tuple_int_char* this, struct Predicate_struct Tuple_int_char* predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_char* this, struct Iterator_struct R (*)(struct Tuple_int_char*) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_char* concat(struct Iterator_struct Tuple_int_char* this, struct Iterator_struct Tuple_int_char* other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_char* next(struct Iterator_struct Tuple_int_char* this){
	return this.head.next(this.head);
}
char* join(struct Main this, struct List_char* list){
	/* list.iter(list) */ iterWithIndices_local1 = list.iter(list);
	/* iterWithIndices_local1.collect(iterWithIndices_local1, new_Joiner("")) */ iterWithIndices_local2 = iterWithIndices_local1.collect(iterWithIndices_local1, new_Joiner(""));
	return iterWithIndices_local2.orElse(iterWithIndices_local2, "");
}
char* compileStatements(struct Main this, char* input, char* (*)(char*) compiler){
	return generateStatements(parseStatements(input, compiler));
}
char* generateStatements(struct Main this, struct List_char* parsed){
	return generateAll(/* Main::mergeStatements */, parsed);
}
struct List_char* parseStatements(struct Main this, char* input, char* (*)(char*) compiler){
	return parseAll(input, /* Main::foldStatementChar */, compiler);
}
char* generateAll(struct Main this, char* (*)(char*, char*) merger, struct List_char* parsed){
	/* parsed.iter(parsed) */ generateAll_local1 = parsed.iter(parsed);
	return generateAll_local1.fold(generateAll_local1, "", merger);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_char* this, struct R (*)(struct Tuple_int_struct Tuple_int_char*) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_char* this, struct Collector_struct Tuple_int_struct Tuple_int_char*_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_char* this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_char*) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_char* filter(struct Iterator_struct Tuple_int_struct Tuple_int_char* this, struct Predicate_struct Tuple_int_struct Tuple_int_char* predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_char* this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_char*) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_char* concat(struct Iterator_struct Tuple_int_struct Tuple_int_char* this, struct Iterator_struct Tuple_int_struct Tuple_int_char* other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_char* next(struct Iterator_struct Tuple_int_struct Tuple_int_char* this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct T this, struct R (*)(struct Tuple_int_struct T) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct T this, struct Collector_struct Tuple_int_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct T this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct T filter(struct Iterator_struct Tuple_int_struct T this, struct Predicate_struct Tuple_int_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct T this, struct Iterator_struct R (*)(struct Tuple_int_struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct T concat(struct Iterator_struct Tuple_int_struct T this, struct Iterator_struct Tuple_int_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct T next(struct Iterator_struct Tuple_int_struct T this){
	return this.head.next(this.head);
}
struct List_struct T createInitial(struct ListCollector_/*  */ this){
	return listEmpty();
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct T this, struct R (*)(struct Tuple_int_struct Tuple_int_struct T) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct T this, struct Collector_struct Tuple_int_struct Tuple_int_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct T this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct T filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct T this, struct Predicate_struct Tuple_int_struct Tuple_int_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct T concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct Tuple_int_struct Tuple_int_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct T next(struct Iterator_struct Tuple_int_struct Tuple_int_struct T this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Predicate_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T next(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this){
	return this.head.next(this.head);
}
struct List_struct Tuple_int_struct T fold(struct ListCollector_/*  */ this, struct List_struct Tuple_int_struct Tuple_int_struct T current, struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T element){
	return current.addLast(current, element);
}
struct List_struct Tuple_int_char* parseAll(struct Main this, char* input, struct State (*)(struct State, char) folder, struct Tuple_int_struct Tuple_int_char* (*)(char*) compiler){
	/* divideAll(input, folder) */ parseAll_local0 = divideAll(input, folder);
	/* parseAll_local0.iter(parseAll_local0) */ parseAll_local1 = parseAll_local0.iter(parseAll_local0);
	/* parseAll_local1.map(parseAll_local1, compiler) */ iterWithIndices_local1 = parseAll_local1.map(parseAll_local1, compiler);
	return iterWithIndices_local1.collect(iterWithIndices_local1, new_ListCollector_/*  */());
}
char* mergeStatements(struct Main this, char* buffer, char* element){
	return buffer + element;
}
/* foldDoubleQuotes(withoutNext, next) */ divideAll_local2(){
	return foldDoubleQuotes(withoutNext, next);
}
/* folder.apply(folder, withoutNext, next) */ divideAll_local5(){
	return folder.apply(folder, folder, withoutNext, next);
}
struct List_char* divideAll(struct Main this, char* input, struct State (*)(struct State, char) folder){
	/* State.fromInput(State, input) */ state = State.fromInput(State, input);
	while (1){
		/* state.pop(state) */ maybeNextTuple = state.pop(state);
		if (/* maybeNextTuple instanceof None */ < Tuple < /* Character, State */ >  > ){
			break;
		}
		if (/* maybeNextTuple instanceof Some */ < Tuple < /* Character, State */ >  > (/* var nextTuple */)){
	/* foldSingleQuotes(withoutNext, next) */ divideAll_local3 = foldSingleQuotes(withoutNext, next);
	/* divideAll_local3.or(divideAll_local3, divideAll_local2) */ divideAll_local7 = divideAll_local3.or(divideAll_local3, divideAll_local2);
			/* nextTuple.left */ next = nextTuple.left;
			/* nextTuple.right */ withoutNext = nextTuple.right;
			state = divideAll_local7.orElseGet(divideAll_local7, divideAll_local5);
		}
	}
	return state.advance(state).segments;
}
struct Option_struct State foldDoubleQuotes(struct Main this, struct State withoutNext, char c){
	if (c != '\"'){
		return new_None_/*  */();
	}
	/* withoutNext.append(withoutNext, c) */ current = withoutNext.append(withoutNext, c);
	while (1){
		/* current.popAndAppendToTuple(current) */ maybeNext = current.popAndAppendToTuple(current);
		if (!(/* maybeNext instanceof Some */(/* var next */))){
			break;
		}
		current = next.right;
		if (next.left == '"'){
			break;
		}
		if (next.left == '\\'){
	/* current.popAndAppend(current) */ foldDoubleQuotes_local3 = current.popAndAppend(current);
			current = foldDoubleQuotes_local3.orElse(foldDoubleQuotes_local3, current);
		}
	}
	return new_Some_/*  */(current);
}
/* maybeSlash.left == /* '\\' ? maybeSlash.right.popAndAppend() : new Some */ <  > (maybeSlash.right) */ foldSingleQuotes_local2(Content[input=maybeSlash -> maybeSlash.left == '\\' ? maybeSlash.right.popAndAppend() : new Some<>(maybeSlash.right)] maybeSlash){
	return maybeSlash.left == /* /* '\\' ? maybeSlash.right.popAndAppend() : new Some */ */ <  > (maybeSlash.right);
}
struct Option_struct State foldSingleQuotes(struct Main this, struct State state, char next){
	/* appended.popAndAppendToTuple(appended) */ foldSingleQuotes_local3 = appended.popAndAppendToTuple(appended);
	/* foldSingleQuotes_local3.flatMap(foldSingleQuotes_local3, foldSingleQuotes_local2) */ foldSingleQuotes_local4 = foldSingleQuotes_local3.flatMap(foldSingleQuotes_local3, foldSingleQuotes_local2);
	if (next != '\''){
		return new_None_/*  */();
	}
	/* state.append(state, next) */ appended = state.append(state, next);
	return foldSingleQuotes_local4.flatMap(foldSingleQuotes_local4, /* State::popAndAppend */);
}
struct State foldStatementChar(struct Main this, struct State state, char c){
	int foldStatementChar_local2 = c == ';' && appended;
	int foldStatementChar_local5 = c == '}' && appended;
	/* state.append(state, c) */ appended = state.append(state, c);
	if (foldStatementChar_local2.isLevel(foldStatementChar_local2)){
		return appended.advance(appended);
	}
	if (foldStatementChar_local5.isShallow(foldStatementChar_local5)){
	/* appended.advance(appended) */ foldStatementChar_local4 = appended.advance(appended);
		return foldStatementChar_local4.exit(foldStatementChar_local4);
	}
	/* if (c == ' */{
		/* = '(') {
            return appended.enter() */ c = /* = '(') {
            return appended.enter() */;
	}
	if (c == '}' || c == ')'){
		return appended.exit(appended);
	}
	return appended;
}
/* generatePlaceholder(stripped) */ compileRootSegment_local4(){
	return generatePlaceholder(stripped);
}
char* compileRootSegment(struct Main this, char* input){
	int compileRootSegment_local3 = stripped.startsWith(stripped, "package ") || stripped;
	/* compileClass(stripped) */ compileRootSegment_local5 = compileClass(stripped);
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.isEmpty(stripped)){
		return "";
	}
	if (compileRootSegment_local3.startsWith(compileRootSegment_local3, "import ")){
		return "";
	}
	return compileRootSegment_local5.orElseGet(compileRootSegment_local5, compileRootSegment_local4);
}
struct Option_char* compileClass(struct Main this, char* stripped){
	return compileStructure(stripped, "class ");
}
struct Option_char* compileStructure(struct Main this, char* input, char* infix){
	/* input.indexOf(input, infix) */ classIndex = input.indexOf(input, infix);
	if (classIndex >= 0){
	/* classIndex */ compileStructure_local1 = classIndex + infix;
		/* input.substring(input, compileStructure_local1.length(compileStructure_local1)) */ afterClass = input.substring(input, compileStructure_local1.length(compileStructure_local1));
		/* afterClass.indexOf(afterClass, "{") */ contentStart = afterClass.indexOf(afterClass, "{");
		if (contentStart >= 0){
	/* afterClass.substring(afterClass, 0, contentStart) */ compileStructure_local5 = afterClass.substring(afterClass, 0, contentStart);
	/* contentStart */ compileStructure_local8 = contentStart + "{";
	/* afterClass.substring(afterClass, compileStructure_local8.length(compileStructure_local8)) */ compileStructure_local10 = afterClass.substring(afterClass, compileStructure_local8.length(compileStructure_local8));
			/* compileStructure_local5.strip(compileStructure_local5) */ beforeContent = compileStructure_local5.strip(compileStructure_local5);
			/* beforeContent.indexOf(beforeContent, " permits") */ permitsIndex = beforeContent.indexOf(beforeContent, " permits");
			int withoutPermits = permitsIndex >= /* 0
                        ? beforeContent.substring(0, permitsIndex).strip()
                        : beforeContent */;
			/* withoutPermits.indexOf(withoutPermits, "(") */ paramStart = withoutPermits.indexOf(withoutPermits, "(");
			/* compileStructure_local10.strip(compileStructure_local10) */ withEnd = compileStructure_local10.strip(compileStructure_local10);
			if (paramStart >= 0){
	/* withoutPermits.substring(withoutPermits, 0, paramStart) */ compileStructure_local12 = withoutPermits.substring(withoutPermits, 0, paramStart);
				/* compileStructure_local12.strip(compileStructure_local12) */ withoutParams = compileStructure_local12.strip(compileStructure_local12);
				return getString(withoutParams, withEnd);
			}
			else {
				return getString(withoutPermits, withEnd);
			}
		}
	}
	return new_None_/*  */();
}
struct Option_char* getString(struct Main this, char* beforeContent, char* withEnd){
	int getString_local0 = !withEnd;
	/* withEnd.length() - "}" */ getString_local1 = /* withEnd.length() - "}" */;
	if (getString_local0.endsWith(getString_local0, "}")){
		return new_None_/*  */();
	}
	/* withEnd.substring(withEnd, 0, getString_local1.length(getString_local1)) */ content = withEnd.substring(withEnd, 0, getString_local1.length(getString_local1));
	/* beforeContent.strip(beforeContent) */ strippedBeforeContent = beforeContent.strip(beforeContent);
	if (strippedBeforeContent.endsWith(strippedBeforeContent, ">")){
	int getString_local4 = /* strippedBeforeContent.length() - " */ > /* " */;
		/* strippedBeforeContent.substring(strippedBeforeContent, 0, getString_local4.length(getString_local4)) */ withoutEnd = strippedBeforeContent.substring(strippedBeforeContent, 0, getString_local4.length(getString_local4));
		/* withoutEnd.indexOf(withoutEnd, "<") */ typeParamStart = withoutEnd.indexOf(withoutEnd, "<");
		if (typeParamStart >= 0){
	/* withoutEnd.substring(withoutEnd, 0, typeParamStart) */ getString_local8 = withoutEnd.substring(withoutEnd, 0, typeParamStart);
	/* typeParamStart */ getString_local9 = typeParamStart + "<";
			/* getString_local8.strip(getString_local8) */ name = getString_local8.strip(getString_local8);
			/* withoutEnd.substring(withoutEnd, getString_local9.length(getString_local9)) */ substring = withoutEnd.substring(withoutEnd, getString_local9.length(getString_local9));
			/* listFromArray(substring.split(substring, Pattern.quote(Pattern, ","))) */ typeParameters = listFromArray(substring.split(substring, Pattern.quote(Pattern, ",")));
			return assembleStructure(typeParameters, name, content);
		}
	}
	return assembleStructure(listEmpty(), strippedBeforeContent, content);
}
struct Option_char* assembleStructure(struct Main this, struct List_char* typeParams, char* name, char* content){
	int assembleStructure_local0 = !typeParams;
	if (assembleStructure_local0.isEmpty(assembleStructure_local0)){
		/* /* typeParams;
                typeArguments = typeArgs;

                var newName = merge(name, typeArgs);
                return generateStructure */(newName, /* content);
            } */) */ typeParameters = /* typeParams;
                typeArguments = typeArgs;

                var newName = merge(name, typeArgs);
                return generateStructure */(newName, /* content);
            } */);
		return new_Some_/*  */("");
	}
	return generateStructure(name, content);
}
struct Option_char* generateStructure(struct Main this, char* name, char* content){
	structStack = structStack.addLast(structStack, new_StructType(name));
	/* compileStatements(content, /* Main::compileClassSegment */) */ compiled = compileStatements(content, /* Main::compileClassSegment */);
	structStack = structStack.removeLast(structStack);
	char* generated = "struct " + name + " {" + compiled + "\n};\n";
	structs.addLast(structs, generated);
	return new_Some_/*  */("");
}
/* compileStructure(stripped, "interface ") */ compileClassSegment_local2(){
	return compileStructure(stripped, "interface ");
}
/* compileClass(stripped) */ compileClassSegment_local4(){
	return compileClass(stripped);
}
/* compileMethod(stripped) */ compileClassSegment_local6(){
	return compileMethod(stripped);
}
/* compileDefinitionStatement(stripped) */ compileClassSegment_local8(){
	return compileDefinitionStatement(stripped);
}
/* generatePlaceholder(stripped) */ compileClassSegment_local10(){
	return generatePlaceholder(stripped);
}
char* compileClassSegment(struct Main this, char* input){
	/* compileStructure(stripped, "record ") */ compileClassSegment_local3 = compileStructure(stripped, "record ");
	/* compileClassSegment_local3.or(compileClassSegment_local3, compileClassSegment_local2) */ compileClassSegment_local5 = compileClassSegment_local3.or(compileClassSegment_local3, compileClassSegment_local2);
	/* compileClassSegment_local5.or(compileClassSegment_local5, compileClassSegment_local4) */ compileClassSegment_local7 = compileClassSegment_local5.or(compileClassSegment_local5, compileClassSegment_local4);
	/* compileClassSegment_local7.or(compileClassSegment_local7, compileClassSegment_local6) */ compileClassSegment_local9 = compileClassSegment_local7.or(compileClassSegment_local7, compileClassSegment_local6);
	/* compileClassSegment_local9.or(compileClassSegment_local9, compileClassSegment_local8) */ compileClassSegment_local11 = compileClassSegment_local9.or(compileClassSegment_local9, compileClassSegment_local8);
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.isEmpty(stripped)){
		return "";
	}
	return compileClassSegment_local11.orElseGet(compileClassSegment_local11, compileClassSegment_local10);
}
struct Option_char* compileDefinitionStatement(struct Main this, char* input){
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.endsWith(stripped, ";")){
	/* stripped.length() - ";" */ compileDefinitionStatement_local1 = /* stripped.length() - ";" */;
		/* stripped.substring(stripped, 0, compileDefinitionStatement_local1.length(compileDefinitionStatement_local1)) */ withoutEnd = stripped.substring(stripped, 0, compileDefinitionStatement_local1.length(compileDefinitionStatement_local1));
		return new_Some_/*  */("\n\t" + compileDefinitionOrPlaceholder(withoutEnd) + ";");
	}
	return new_None_/*  */();
}
/* !(/* parameter instanceof Whitespace */) */ compileMethod_local11(Content[input=parameter -> !(parameter instanceof Whitespace)] parameter){
	return !(/* /* parameter instanceof Whitespace */ */);
}
auto compileMethod_local19(Content[input=last -> {
                var paramTypes = newParams.iter()
                        .map(Defined::findType)
                        .flatMap(Iterators::fromOption)
                        .collect(new ListCollector<>());

                var name = defined.findName().orElse("?");
                var type = defined.findType().orElse(Primitive.Auto);

                return last.define(new Definition(new Functional(paramTypes, type), name));
            }] last){
	/* newParams.iter(newParams) */ compileMethod_local21 = newParams.iter(newParams);
	/* compileMethod_local21.map(compileMethod_local21, /* Defined::findType */) */ compileMethod_local22 = compileMethod_local21.map(compileMethod_local21, /* Defined::findType */);
	/* compileMethod_local22.flatMap(compileMethod_local22, /* Iterators::fromOption */) */ compileMethod_local23 = compileMethod_local22.flatMap(compileMethod_local22, /* Iterators::fromOption */);
	/* defined.findName(defined) */ compileMethod_local25 = defined.findName(defined);
	/* defined.findType(defined) */ compileMethod_local27 = defined.findType(defined);
	/* compileMethod_local23.collect(compileMethod_local23, new_ListCollector_/*  */()) */ paramTypes = compileMethod_local23.collect(compileMethod_local23, new_ListCollector_/*  */());
	/* compileMethod_local25.orElse(compileMethod_local25, "?") */ name = compileMethod_local25.orElse(compileMethod_local25, "?");
	/* compileMethod_local27.orElse(compileMethod_local27, Primitive.Auto) */ type = compileMethod_local27.orElse(compileMethod_local27, Primitive.Auto);
	return last.define(last, new_Definition(new_Functional(paramTypes, type), name));
}
auto compileMethod_local18(Content[input=method -> {
            structStack = structStack.mapLast(last -> {
                var paramTypes = newParams.iter()
                        .map(Defined::findType)
                        .flatMap(Iterators::fromOption)
                        .collect(new ListCollector<>());

                var name = defined.findName().orElse("?");
                var type = defined.findType().orElse(Primitive.Auto);

                return last.define(new Definition(new Functional(paramTypes, type), name));
            });
            return method;
        }] method){
	structStack = structStack.mapLast(structStack, compileMethod_local19);
	return method;
}
struct Option_char* compileMethod(struct Main this, char* stripped){
	/* paramStart */ compileMethod_local2 = paramStart + "(";
	/* paramEnd */ compileMethod_local6 = paramEnd + ")";
	/* parseValues(params, /* Main::parseParameter */) */ compileMethod_local10 = parseValues(params, /* Main::parseParameter */);
	/* compileMethod_local10.iter(compileMethod_local10) */ compileMethod_local12 = compileMethod_local10.iter(compileMethod_local10);
	/* compileMethod_local12.filter(compileMethod_local12, compileMethod_local11) */ compileMethod_local13 = compileMethod_local12.filter(compileMethod_local12, compileMethod_local11);
	/* structStack.findLast(structStack) */ compileMethod_local15 = structStack.findLast(structStack);
	/* /* Lists. */ < Defined > listEmpty() */ compileMethod_local16 = /* Lists. */ < Defined > listEmpty();
	/* compileMethod_local16.addLast(compileMethod_local16, new_Definition(compileMethod_local15.orElse(compileMethod_local15, null), "this")) */ compileMethod_local17 = compileMethod_local16.addLast(compileMethod_local16, new_Definition(compileMethod_local15.orElse(compileMethod_local15, null), "this"));
	/* assembleMethod(defined, outputParams, content) */ compileMethod_local30 = assembleMethod(defined, outputParams, content);
	/* stripped.indexOf(stripped, "(") */ paramStart = stripped.indexOf(stripped, "(");
	if (paramStart < 0){
		return new_None_/*  */();
	}
	/* stripped.substring(stripped, 0, paramStart) */ inputDefinition = stripped.substring(stripped, 0, paramStart);
	/* parseDefinitionOrPlaceholder(inputDefinition) */ defined = parseDefinitionOrPlaceholder(inputDefinition);
	if (/* defined instanceof Definition definition */){
		functionName = definition.name;
		functionLocalCounter = 0;
	}
	/* stripped.substring(stripped, compileMethod_local2.length(compileMethod_local2)) */ afterParams = stripped.substring(stripped, compileMethod_local2.length(compileMethod_local2));
	/* afterParams.indexOf(afterParams, ")") */ paramEnd = afterParams.indexOf(afterParams, ")");
	if (paramEnd < 0){
		return new_None_/*  */();
	}
	/* afterParams.substring(afterParams, 0, paramEnd) */ params = afterParams.substring(afterParams, 0, paramEnd);
	/* afterParams.substring(afterParams, compileMethod_local6.length(compileMethod_local6)) */ withoutParams = afterParams.substring(afterParams, compileMethod_local6.length(compileMethod_local6));
	/* withoutParams.strip(withoutParams) */ withBraces = withoutParams.strip(withoutParams);
	/* if (!withBraces.startsWith(" */{
		/* ") || !withBraces.endsWith("}")) {
            return new Some<>(""); */
	}
	/* withBraces.substring(withBraces, 1, /* withBraces.length() - 1 */) */ content = withBraces.substring(withBraces, 1, /* withBraces.length() - 1 */);
	/* compileMethod_local13.collect(compileMethod_local13, new_ListCollector_/*  */()) */ oldParams = compileMethod_local13.collect(compileMethod_local13, new_ListCollector_/*  */());
	/* compileMethod_local17.addAll(compileMethod_local17, oldParams) */ newParams = compileMethod_local17.addAll(compileMethod_local17, oldParams);
	/* generateValueList(newParams) */ outputParams = generateValueList(newParams);
	return compileMethod_local30.map(compileMethod_local30, compileMethod_local18);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Predicate_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T next(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this){
	return this.head.next(this.head);
}
char* generateValueList(struct Main this, struct List_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T copy){
	return generateValueList(copy, /* Node::generate */);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Collector_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Predicate_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this, struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T next(struct Iterator_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T this){
	return this.head.next(this.head);
}
char* generateValueList(struct Main this, struct List_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T copy, char* (*)(struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct Tuple_int_struct T) generate){
	/* copy.iter(copy) */ iterWithIndices_local1 = copy.iter(copy);
	/* iterWithIndices_local1.map(iterWithIndices_local1, generate) */ iterWithIndices_local2 = iterWithIndices_local1.map(iterWithIndices_local1, generate);
	/* iterWithIndices_local2.collect(iterWithIndices_local2, new_Joiner(", ")) */ iterWithIndices_local3 = iterWithIndices_local2.collect(iterWithIndices_local2, new_Joiner(", "));
	return iterWithIndices_local3.orElse(iterWithIndices_local3, "");
}
/* compileFunctionSegment(input, 1) */ assembleMethod_local0(Content[input= input -> compileFunctionSegment(input, 1)] input){
	return compileFunctionSegment(input, 1);
}
struct Option_char* assembleMethod(struct Main this, struct Defined definition, char* outputParams, char* content){
	/* parseStatementsWithLocals(content, assembleMethod_local0) */ parsed = parseStatementsWithLocals(content, assembleMethod_local0);
	/* definition.generate(definition) */ generated = definition.generate(definition) + "(" + outputParams + "){" + generateStatements(parsed) + "\n}\n";
	methods.addLast(methods, generated);
	return new_Some_/*  */("");
}
struct List_char* parseStatementsWithLocals(struct Main this, char* content, char* (*)(char*) compiler){
	/* /* Lists. */ < String > listEmpty() */ parseStatementsWithLocals_local2 = /* Lists. */ < String > listEmpty();
	/* parseStatementsWithLocals_local2.addAll(parseStatementsWithLocals_local2, elements) */ parseStatementsWithLocals_local3 = parseStatementsWithLocals_local2.addAll(parseStatementsWithLocals_local2, elements);
	statements = statements.addLast(statements, listEmpty());
	/* parseStatements(content, compiler) */ parsed1 = parseStatements(content, compiler);
	/* statements.removeAndGetLast(statements) */ elements = statements.removeAndGetLast(statements);
	return parseStatementsWithLocals_local3.addAll(parseStatementsWithLocals_local3, parsed1);
}
/* value */ parseParameter_local0(Content[input=value -> value] value){
	return value;
}
/* value */ parseParameter_local1(Content[input=value -> value] value){
	return value;
}
/* parseParameter_local2.map(parseParameter_local2, parseParameter_local1) */ parseParameter_local3(){
	return parseParameter_local2.map(parseParameter_local2, parseParameter_local2, parseParameter_local1);
}
/* new_Content(input) */ parseParameter_local6(){
	return new_Content(input);
}
struct Defined parseParameter(struct Main this, char* input){
	/* parseDefinition(input) */ parseParameter_local2 = parseDefinition(input);
	/* /* parseWhitespace(input).findValue(). */ < Defined > map(parseParameter_local0) */ parseParameter_local5 = /* parseWhitespace(input).findValue(). */ < Defined > map(parseParameter_local0);
	/* parseParameter_local5.or(parseParameter_local5, parseParameter_local3) */ parseParameter_local7 = parseParameter_local5.or(parseParameter_local5, parseParameter_local3);
	return parseParameter_local7.orElseGet(parseParameter_local7, parseParameter_local6);
}
struct Result_struct Whitespace_struct CompileError parseWhitespace(struct Main this, char* input){
	if (input.isBlank(input)){
		return new_Ok_/*  */(new_Whitespace());
	}
	else {
		return new_Err_/*  */(new_CompileError("Not blank", input));
	}
}
/* compileFunctionSegment(input1, depth + 1) */ compileFunctionSegment_local13(Content[input= input1 -> compileFunctionSegment(input1, depth + 1)] input1){
	return compileFunctionSegment(input1, depth + 1);
}
char* compileFunctionSegment(struct Main this, char* input, int depth){
	char* compileFunctionSegment_local2 = "\n" + "\t";
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.isEmpty(stripped)){
		return "";
	}
	/* compileFunctionSegment_local2.repeat(compileFunctionSegment_local2, depth) */ indent = compileFunctionSegment_local2.repeat(compileFunctionSegment_local2, depth);
	if (stripped.endsWith(stripped, ";")){
	/* stripped.length() - ";" */ compileFunctionSegment_local3 = /* stripped.length() - ";" */;
	/* stripped.substring(stripped, 0, compileFunctionSegment_local3.length(compileFunctionSegment_local3)) */ compileFunctionSegment_local5 = stripped.substring(stripped, 0, compileFunctionSegment_local3.length(compileFunctionSegment_local3));
		/* compileFunctionSegment_local5.strip(compileFunctionSegment_local5) */ withoutEnd = compileFunctionSegment_local5.strip(compileFunctionSegment_local5);
		/* compileStatementValue(withoutEnd) */ maybeStatementValue = compileStatementValue(withoutEnd);
		if (/* maybeStatementValue instanceof Some */(/* var statementValue */)){
			return indent + statementValue + ";";
		}
	}
	if (stripped.endsWith(stripped, "}")){
	/* stripped.length() - "}" */ compileFunctionSegment_local7 = /* stripped.length() - "}" */;
		/* stripped.substring(stripped, 0, compileFunctionSegment_local7.length(compileFunctionSegment_local7)) */ withoutEnd = stripped.substring(stripped, 0, compileFunctionSegment_local7.length(compileFunctionSegment_local7));
		/* withoutEnd.indexOf(withoutEnd, "{") */ contentStart = withoutEnd.indexOf(withoutEnd, "{");
		if (contentStart >= 0){
	/* contentStart */ compileFunctionSegment_local11 = contentStart + "{";
			/* withoutEnd.substring(withoutEnd, 0, contentStart) */ beforeBlock = withoutEnd.substring(withoutEnd, 0, contentStart);
			/* withoutEnd.substring(withoutEnd, compileFunctionSegment_local11.length(compileFunctionSegment_local11)) */ content = withoutEnd.substring(withoutEnd, compileFunctionSegment_local11.length(compileFunctionSegment_local11));
			/* parseStatementsWithLocals(content, compileFunctionSegment_local13) */ outputContent = parseStatementsWithLocals(content, compileFunctionSegment_local13);
			return indent + compileBeforeBlock(beforeBlock) + "{" + join(outputContent) + indent + "}";
		}
	}
	return indent + generatePlaceholder(stripped);
}
struct Option_char* compileStatementValue(struct Main this, char* input){
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.equals(stripped, "break")){
		return new_Some_/*  */("break");
	}
	if (stripped.startsWith(stripped, "return ")){
	char* compileStatementValue_local2 = "return ";
		/* stripped.substring(stripped, compileStatementValue_local2.length(compileStatementValue_local2)) */ value = stripped.substring(stripped, compileStatementValue_local2.length(compileStatementValue_local2));
		return new_Some_/*  */("return " + compileValue(value));
	}
	/* stripped.indexOf(stripped, "=") */ valueSeparator = stripped.indexOf(stripped, "=");
	if (valueSeparator >= 0){
	/* valueSeparator */ compileStatementValue_local7 = valueSeparator + "=";
	/* newAssignable.generate(newAssignable) */ compileStatementValue_local10 = newAssignable.generate(newAssignable) + " = " + value;
		/* stripped.substring(stripped, 0, valueSeparator) */ assignableString = stripped.substring(stripped, 0, valueSeparator);
		/* stripped.substring(stripped, compileStatementValue_local7.length(compileStatementValue_local7)) */ valueString = stripped.substring(stripped, compileStatementValue_local7.length(compileStatementValue_local7));
		/* parseAssignable(assignableString) */ assignable = parseAssignable(assignableString);
		/* parseValue(valueString) */ value = parseValue(valueString);
		/* resolve(value) */ type = resolve(value);
		/* Assignable newAssignable; */
		if (/* assignable instanceof Definition definition */){
			newAssignable = new_Definition(type, definition.name);
		}
		else {
			newAssignable = assignable;
		}
		return new_Some_/*  */(compileStatementValue_local10.generate(compileStatementValue_local10));
	}
	if (/* compileInvokable(input) instanceof Some */(/* var invokable */)){
		return new_Some_/*  */(invokable.generate(invokable));
	}
	return new_None_/*  */();
}
struct Type resolve(struct Main this, struct Value value){
	/* return switch (value) */{
		/* case BooleanValue _ -> Primitive.Bool; */
		/* case CharValue _ -> Primitive.I8; */
		/* case Content content -> content; */
		/* case DataAccess dataAccess - */ > resolveDataAccess(dataAccess);
		/* case Invocation invocation - */ > resolveInvocation(invocation);
		/* case Not _ -> Primitive.Bool; */
		/* case Operation operation - */ > resolveOperation(operation);
		/* case StringValue _ - */ > /* new Ref */(Primitive.I8);
		/* case Symbol symbol - */ > resolveSymbol(symbol);
		/* case Whitespace _ -> Primitive.Void; */
	}
	/* ; */
}
/* resolve(operation.left) */ resolveOperation_local0(){
	return resolve(operation.left);
}
struct Type resolveOperation(struct Main this, struct Operation operation){
	return operation.operator.type.orElseGet(operation.operator.type, resolveOperation_local0);
}
struct Type resolveSymbol(struct Main this, struct Symbol symbol){
	if (symbol.value.equals(symbol.value, "this")){
	/* structStack.findLast(structStack) */ resolveSymbol_local1 = structStack.findLast(structStack);
		return resolveSymbol_local1.orElse(resolveSymbol_local1, null);
	}
	return new_Content(symbol.value);
}
struct Type resolveInvocation(struct Main this, struct Invocation invocation){
	/* invocation.caller */ caller = invocation.caller;
	/* resolve(caller) */ resolvedCaller = resolve(caller);
	if (/* resolvedCaller instanceof Functional functional */){
		return functional.returns;
	}
	return new_Content(invocation.generate(invocation));
}
struct Type resolveDataAccess(struct Main this, struct DataAccess dataAccess){
	/* dataAccess.parent */ parent = dataAccess.parent;
	/* resolve(parent) */ resolved = resolve(parent);
	if (/* resolved instanceof StructType structType */){
		/* structType.find(structType, dataAccess.property) */ typeOption = structType.find(structType, dataAccess.property);
		if (/* typeOption instanceof Some */ < Type > (/* var propertyType */)){
			return propertyType;
		}
	}
	return new_Content(dataAccess.generate(dataAccess));
}
/* value1 */ parseAssignable_local0(Content[input=value1 -> value1] value1){
	return value1;
}
/* parseValue(definition) */ parseAssignable_local1(){
	return parseValue(definition);
}
struct Assignable parseAssignable(struct Main this, char* definition){
	/* /* parseDefinition(definition)
                . */ < Assignable > map(parseAssignable_local0) */ parseAssignable_local2 = /* parseDefinition(definition)
                . */ < Assignable > map(parseAssignable_local0);
	return parseAssignable_local2.orElseGet(parseAssignable_local2, parseAssignable_local1);
}
/* compileConditional(stripped, "while") */ compileBeforeBlock_local2(){
	return compileConditional(stripped, "while");
}
/* generatePlaceholder(stripped) */ compileBeforeBlock_local4(){
	return generatePlaceholder(stripped);
}
char* compileBeforeBlock(struct Main this, char* input){
	/* compileConditional(stripped, "if") */ compileBeforeBlock_local3 = compileConditional(stripped, "if");
	/* compileBeforeBlock_local3.or(compileBeforeBlock_local3, compileBeforeBlock_local2) */ compileBeforeBlock_local5 = compileBeforeBlock_local3.or(compileBeforeBlock_local3, compileBeforeBlock_local2);
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.equals(stripped, "else")){
		return "else ";
	}
	return compileBeforeBlock_local5.orElseGet(compileBeforeBlock_local5, compileBeforeBlock_local4);
}
struct Option_char* compileConditional(struct Main this, char* stripped, char* prefix){
	if (stripped.startsWith(stripped, prefix)){
	/* stripped.substring(stripped, prefix.length(prefix)) */ compileConditional_local2 = stripped.substring(stripped, prefix.length(prefix));
	int compileConditional_local5 = withoutPrefix.startsWith(withoutPrefix, "(") && withoutPrefix;
		/* compileConditional_local2.strip(compileConditional_local2) */ withoutPrefix = compileConditional_local2.strip(compileConditional_local2);
		if (compileConditional_local5.endsWith(compileConditional_local5, ")")){
			/* withoutPrefix.substring(withoutPrefix, 1, /* withoutPrefix.length() - 1 */) */ condition = withoutPrefix.substring(withoutPrefix, 1, /* withoutPrefix.length() - 1 */);
			return new_Some_/*  */(prefix + " (" + compileValue(condition) + ")");
		}
	}
	return new_None_/*  */();
}
char* compileValue(struct Main this, char* input){
	/* parseValue(input) */ compileValue_local0 = parseValue(input);
	return compileValue_local0.generate(compileValue_local0);
}
/* parseValue_local16.isEmpty(parseValue_local16) */ parseValue_local17(Content[input=value -> !value.isEmpty()] value){
	return parseValue_local16.isEmpty(parseValue_local16, parseValue_local16);
}
struct Value parseValue(struct Main this, char* input){
	int parseValue_local31 = stripped.length(stripped) >= 2 && stripped.startsWith(stripped, "\"") && stripped;
	int parseValue_local35 = stripped.length(stripped) >= 2 && stripped.startsWith(stripped, "'") && stripped;
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.isEmpty(stripped)){
		return new_Whitespace();
	}
	if (stripped.equals(stripped, "false")){
		return BooleanValue.False;
	}
	if (stripped.equals(stripped, "true")){
		return BooleanValue.True;
	}
	/* stripped.indexOf(stripped, "->") */ arrowIndex = stripped.indexOf(stripped, "->");
	if (arrowIndex >= 0){
	/* stripped.substring(stripped, 0, arrowIndex) */ parseValue_local6 = stripped.substring(stripped, 0, arrowIndex);
	/* arrowIndex */ parseValue_local7 = arrowIndex + "->";
	/* stripped.substring(stripped, parseValue_local7.length(parseValue_local7)) */ parseValue_local9 = stripped.substring(stripped, parseValue_local7.length(parseValue_local7));
	int parseValue_local22 = beforeArrow.startsWith(beforeArrow, "(") && beforeArrow;
		/* parseValue_local6.strip(parseValue_local6) */ beforeArrow = parseValue_local6.strip(parseValue_local6);
		/* parseValue_local9.strip(parseValue_local9) */ afterArrow = parseValue_local9.strip(parseValue_local9);
		if (isSymbol(beforeArrow)){
			return assembleLambda(afterArrow, Lists.listFrom(Lists, beforeArrow));
		}
		if (parseValue_local22.endsWith(parseValue_local22, ")")){
	/* beforeArrow.substring(beforeArrow, 1, /* beforeArrow.length() - 1 */) */ parseValue_local13 = beforeArrow.substring(beforeArrow, 1, /* beforeArrow.length() - 1 */);
	/* Iterators.fromArray(Iterators, parseValue_local13.split(parseValue_local13, Pattern.quote(Pattern, ","))) */ parseValue_local15 = Iterators.fromArray(Iterators, parseValue_local13.split(parseValue_local13, Pattern.quote(Pattern, ",")));
	int parseValue_local16 = !value;
	/* parseValue_local15.map(parseValue_local15, /* String::strip */) */ parseValue_local19 = parseValue_local15.map(parseValue_local15, /* String::strip */);
	/* parseValue_local19.filter(parseValue_local19, parseValue_local17) */ parseValue_local20 = parseValue_local19.filter(parseValue_local19, parseValue_local17);
			/* parseValue_local20.collect(parseValue_local20, new_ListCollector_/*  */()) */ args = parseValue_local20.collect(parseValue_local20, new_ListCollector_/*  */());
			return assembleLambda(afterArrow, args);
		}
	}
	if (/* compileInvokable(stripped) instanceof Some */(/* var invokable */)){
		return invokable;
	}
	if (isSymbol(stripped)){
		return new_Symbol(stripped);
	}
	if (isNumber(stripped)){
		return new_Symbol(stripped);
	}
	/* stripped.lastIndexOf(stripped, ".") */ separator = stripped.lastIndexOf(stripped, ".");
	if (separator >= 0){
	/* separator */ parseValue_local25 = separator + ".";
	/* stripped.substring(stripped, parseValue_local25.length(parseValue_local25)) */ parseValue_local27 = stripped.substring(stripped, parseValue_local25.length(parseValue_local25));
		/* stripped.substring(stripped, 0, separator) */ value = stripped.substring(stripped, 0, separator);
		/* parseValue_local27.strip(parseValue_local27) */ property = parseValue_local27.strip(parseValue_local27);
		if (isSymbol(property)){
			return new_DataAccess(parseValue(value), property);
		}
	}
	if (parseValue_local31.endsWith(parseValue_local31, "\"")){
		return new_StringValue(stripped.substring(stripped, 1, /* stripped.length() - 1 */));
	}
	if (parseValue_local35.endsWith(parseValue_local35, "'")){
		return new_CharValue(stripped.substring(stripped, 1, /* stripped.length() - 1 */));
	}
	if (stripped.startsWith(stripped, "!")){
		return new_Not(parseValue(input.substring(input, 1)));
	}
	/* for (var operator : Operator.values()) */{
		/* stripped.indexOf(stripped, operator.representation) */ operatorIndex = stripped.indexOf(stripped, operator.representation);
		if (operatorIndex >= 0){
			/* stripped.substring(stripped, 0, operatorIndex) */ left = stripped.substring(stripped, 0, operatorIndex);
			/* stripped.substring(stripped, operatorIndex + operator.representation.length(operatorIndex + operator.representation)) */ right = stripped.substring(stripped, operatorIndex + operator.representation.length(operatorIndex + operator.representation));
			return new_Operation(parseValue(left), operator, parseValue(right));
		}
	}
	return new_Content(stripped);
}
struct Option_struct Invocation compileInvokable(struct Main this, char* stripped){
	int compileInvokable_local0 = !stripped;
	/* stripped.length() - ")" */ compileInvokable_local1 = /* stripped.length() - ")" */;
	/* stripped.substring(stripped, 0, compileInvokable_local1.length(compileInvokable_local1)) */ compileInvokable_local3 = stripped.substring(stripped, 0, compileInvokable_local1.length(compileInvokable_local1));
	/* joined.length() - ")" */ compileInvokable_local6 = /* joined.length() - ")" */;
	/* divisions.findLast(divisions) */ compileInvokable_local9 = divisions.findLast(divisions);
	if (compileInvokable_local0.endsWith(compileInvokable_local0, ")")){
		return new_None_/*  */();
	}
	/* compileInvokable_local3.strip(compileInvokable_local3) */ withoutEnd = compileInvokable_local3.strip(compileInvokable_local3);
	/* divideAll(withoutEnd, /* Main::foldInvokableStart */) */ divisions = divideAll(withoutEnd, /* Main::foldInvokableStart */);
	if (divisions.size(divisions) < 2){
		return new_None_/*  */();
	}
	/* join(divisions.subList(divisions, 0, /* divisions.size() - 1 */)) */ joined = join(divisions.subList(divisions, 0, /* divisions.size() - 1 */));
	/* joined.substring(joined, 0, compileInvokable_local6.length(compileInvokable_local6)) */ caller = joined.substring(joined, 0, compileInvokable_local6.length(compileInvokable_local6));
	/* compileInvokable_local9.orElse(compileInvokable_local9, null) */ arguments = compileInvokable_local9.orElse(compileInvokable_local9, null);
	if (caller.startsWith(caller, "new ")){
	char* compileInvokable_local10 = "new ";
	char* compileInvokable_local12 = "new_" + type;
		/* parseType(caller.substring(caller, compileInvokable_local10.length(compileInvokable_local10))) */ type = parseType(caller.substring(caller, compileInvokable_local10.length(compileInvokable_local10)));
		/* new_Symbol(compileInvokable_local12.stringify(compileInvokable_local12)) */ parsedCaller = new_Symbol(compileInvokable_local12.stringify(compileInvokable_local12));
		return assembleInvokable(parsedCaller, arguments, listEmpty());
	}
	/* parseValue(caller) */ parsedCaller = parseValue(caller);
	if (/* resolve(parsedCaller) instanceof Functional functional */){
		return assembleInvokable(parsedCaller, arguments, functional.paramTypes);
	}
	else {
		return assembleInvokable(parsedCaller, arguments, listEmpty());
	}
}
struct Option_struct R map(struct Some_struct Invocation this, struct R (*)(struct Invocation) mapper){
	return new_Some_/*  */(mapper.apply(mapper, this.value));
}
struct Invocation orElse(struct Some_struct Invocation this, struct Invocation other){
	return this.value;
}
struct Invocation orElseGet(struct Some_struct Invocation this, struct Supplier_struct Invocation supplier){
	return this.value;
}
struct Option_struct R flatMap(struct Some_struct Invocation this, struct Option_struct R (*)(struct Invocation) mapper){
	return mapper.apply(mapper, this.value);
}
struct Option_struct Invocation or(struct Some_struct Invocation this, struct Supplier_struct Option_struct Invocation supplier){
	return this;
}
void ifPresent(struct Some_struct Invocation this, struct Consumer_struct Invocation consumer){
	consumer.accept(consumer, this.value);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Type this, struct R (*)(struct Type) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Type this, struct Collector_struct Type_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Type this, struct R initial, struct R (*)(struct R, struct Type) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Type filter(struct Iterator_struct Type this, struct Predicate_struct Type predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Type this, struct Iterator_struct R (*)(struct Type) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Type concat(struct Iterator_struct Type this, struct Iterator_struct Type other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Type next(struct Iterator_struct Type this){
	return this.head.next(this.head);
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Type this, struct R (*)(struct Tuple_int_struct Type) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Type this, struct Collector_struct Tuple_int_struct Type_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Type this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Type) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Type filter(struct Iterator_struct Tuple_int_struct Type this, struct Predicate_struct Tuple_int_struct Type predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Type this, struct Iterator_struct R (*)(struct Tuple_int_struct Type) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Type concat(struct Iterator_struct Tuple_int_struct Type this, struct Iterator_struct Tuple_int_struct Type other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Type next(struct Iterator_struct Tuple_int_struct Type this){
	return this.head.next(this.head);
}
auto iterWithIndices_local1(Content[input=(Tuple<Integer, String> input) -> {
                    var index = input.left;
                    var maybeFound = expectedArgumentsType.find(index);

                    Type expectedType;
                    if (maybeFound instanceof Some(var found)) {
                        expectedType = found;
                    }
                    else {
                        expectedType = new Content(input.right);
                    }

                    typeStack = typeStack.addLast(expectedType);
                    Value parsed = parseValue(input.right);
                    typeStack = typeStack.removeLast();
                    return parsed;
                }] Tuple<Integer, Content[input=(Tuple<Integer, String> input) -> {
                    var index = input.left;
                    var maybeFound = expectedArgumentsType.find(index);

                    Type expectedType;
                    if (maybeFound instanceof Some(var found)) {
                        expectedType = found;
                    }
                    else {
                        expectedType = new Content(input.right);
                    }

                    typeStack = typeStack.addLast(expectedType);
                    Value parsed = parseValue(input.right);
                    typeStack = typeStack.removeLast();
                    return parsed;
                }] String> input){
	/* input.left */ index = input.left;
	/* expectedArgumentsType.find(expectedArgumentsType, index) */ maybeFound = expectedArgumentsType.find(expectedArgumentsType, index);
	/* Type expectedType; */
	if (/* maybeFound instanceof Some */(/* var found */)){
		expectedType = found;
	}
	else {
		expectedType = new_Content(input.right);
	}
	typeStack = typeStack.addLast(typeStack, expectedType);
	/* parseValue(input.right) */ parsed = parseValue(input.right);
	typeStack = typeStack.removeLast(typeStack);
	return parsed;
}
/* !(/* value instanceof Whitespace */) */ iterWithIndices_local8(Content[input=value -> !(value instanceof Whitespace)] value){
	return !(/* /* value instanceof Whitespace */ */);
}
struct Some_struct Invocation assembleInvokable(struct Main this, struct Value caller, char* arguments, struct List_struct Type expectedArgumentsType){
	/* divideAll(arguments, /* Main::foldValueChar */) */ iterWithIndices_local0 = divideAll(arguments, /* Main::foldValueChar */);
	/* iterWithIndices_local0.iterWithIndices(iterWithIndices_local0) */ iterWithIndices_local5 = iterWithIndices_local0.iterWithIndices(iterWithIndices_local0);
	/* iterWithIndices_local5.map(iterWithIndices_local5, iterWithIndices_local1) */ iterWithIndices_local6 = iterWithIndices_local5.map(iterWithIndices_local5, iterWithIndices_local1);
	/* iterWithIndices_local6.collect(iterWithIndices_local6, new_ListCollector_/*  */()) */ iterWithIndices_local7 = iterWithIndices_local6.collect(iterWithIndices_local6, new_ListCollector_/*  */());
	/* iterWithIndices_local7.iter(iterWithIndices_local7) */ iterWithIndices_local9 = iterWithIndices_local7.iter(iterWithIndices_local7);
	/* iterWithIndices_local9.filter(iterWithIndices_local9, iterWithIndices_local8) */ iterWithIndices_local10 = iterWithIndices_local9.filter(iterWithIndices_local9, iterWithIndices_local8);
	/* /* Lists. */ < Value > listEmpty() */ iterWithIndices_local14 = /* Lists. */ < Value > listEmpty();
	/* iterWithIndices_local14.addLast(iterWithIndices_local14, symbol) */ iterWithIndices_local15 = iterWithIndices_local14.addLast(iterWithIndices_local14, symbol);
	/* iterWithIndices_local10.collect(iterWithIndices_local10, new_ListCollector_/*  */()) */ parsedArgs = iterWithIndices_local10.collect(iterWithIndices_local10, new_ListCollector_/*  */());
	if (!(/* caller instanceof DataAccess */(/* var parent */, /* var property */))){
		return new_Some_/*  */(new_Invocation(caller, parsedArgs));
	}
	/* generateName() */ name = generateName();
	/* Value symbol; */
	if (/* parent instanceof Symbol */ || /* parent instanceof DataAccess */){
		symbol = parent;
	}
	else {
	/* statements.findLast(statements) */ iterWithIndices_local12 = statements.findLast(statements);
	/* iterWithIndices_local12.orElse(iterWithIndices_local12, null) */ iterWithIndices_local13 = iterWithIndices_local12.orElse(iterWithIndices_local12, null);
		/* resolve(parent) */ type = resolve(parent);
		char* statement = "\n\t" + type.generate() + " " + name + " = " + parent.generate() + ";";
		iterWithIndices_local13.addLast(iterWithIndices_local13, statement);
		symbol = new_Symbol(name);
	}
	/* iterWithIndices_local15.addAll(iterWithIndices_local15, parsedArgs) */ newArgs = iterWithIndices_local15.addAll(iterWithIndices_local15, parsedArgs);
	return new_Some_/*  */(new_Invocation(new_DataAccess(symbol, property), newArgs));
}
/* last */ assembleLambda_local2(Content[input=last -> last + " " + name] last){
	return last + " " + name;
}
/* assembleLambda_local4.orElse(assembleLambda_local4, "? " + name) */ assembleLambda_local5(Content[input=name -> maybeLast.map(last -> last + " " + name).orElse("? " + name)] name){
	return assembleLambda_local4.orElse(assembleLambda_local4, assembleLambda_local4, "? " + name);
}
struct Symbol assembleLambda(struct Main this, char* afterArrow, struct List_char* names){
	/* maybeLast.map(maybeLast, assembleLambda_local2) */ assembleLambda_local4 = maybeLast.map(maybeLast, assembleLambda_local2);
	/* names.iter(names) */ assembleLambda_local7 = names.iter(names);
	/* assembleLambda_local7.map(assembleLambda_local7, assembleLambda_local5) */ assembleLambda_local8 = assembleLambda_local7.map(assembleLambda_local7, assembleLambda_local5);
	/* assembleLambda_local8.collect(assembleLambda_local8, new_Joiner(", ")) */ assembleLambda_local9 = assembleLambda_local8.collect(assembleLambda_local8, new_Joiner(", "));
	/* typeStack.findLast(typeStack) */ maybeLast = typeStack.findLast(typeStack);
	/* assembleLambda_local9.orElse(assembleLambda_local9, "") */ params = assembleLambda_local9.orElse(assembleLambda_local9, "");
	/* if (afterArrow.startsWith(" */{
		/* /* afterArrow.substring(1, afterArrow.length() - 1);
            var name = generateName();
            assembleMethod(new Definition(Primitive.Auto, name), params, content);
            return new Symbol */(name) */ content = /* afterArrow.substring(1, afterArrow.length() - 1);
            var name = generateName();
            assembleMethod(new Definition(Primitive.Auto, name), params, content);
            return new Symbol */(name);
	}
	/* parseValue(afterArrow) */ value = parseValue(afterArrow);
	/* value.generate(value) */ newValue = value.generate(value);
	/* resolve(value) */ resolved = resolve(value);
	/* generateName() */ name = generateName();
	assembleMethod(new_Definition(resolved, name), params, "\n\treturn " + newValue + ";");
	return new_Symbol(name);
}
char* generateName(struct Main this){
	/* functionName */ name = functionName + "_local" + functionLocalCounter;
	/* functionLocalCounter++; */
	return name;
}
struct State foldInvokableStart(struct Main this, struct State state, char c){
	/* state.append(state, c) */ appended = state.append(state, c);
	if (c == '('){
		/* appended.isLevel() ? appended.advance() : appended */ maybeAdvanced = /* appended.isLevel() ? appended.advance() : appended */;
		return maybeAdvanced.enter(maybeAdvanced);
	}
	if (c == ')'){
		return appended.exit(appended);
	}
	return appended;
}
int isNumber(struct Main this, char* input){
	if (input.isEmpty(input)){
		return 0;
	}
	/* for (var i = 0; i < input.length(); i++) */{
		/* input.charAt(input, i) */ c = input.charAt(input, i);
		if (Character.isDigit(Character, c)){
			/* continue; */
		}
		return 0;
	}
	return 1;
}
char* compileDefinitionOrPlaceholder(struct Main this, char* input){
	/* parseDefinitionOrPlaceholder(input) */ compileDefinitionOrPlaceholder_local0 = parseDefinitionOrPlaceholder(input);
	return compileDefinitionOrPlaceholder_local0.generate(compileDefinitionOrPlaceholder_local0);
}
/* value */ parseDefinitionOrPlaceholder_local0(Content[input=value -> value] value){
	return value;
}
/* new_Content(input) */ parseDefinitionOrPlaceholder_local1(){
	return new_Content(input);
}
struct Defined parseDefinitionOrPlaceholder(struct Main this, char* input){
	/* /* parseDefinition(input). */ < Defined > map(parseDefinitionOrPlaceholder_local0) */ parseDefinitionOrPlaceholder_local2 = /* parseDefinition(input). */ < Defined > map(parseDefinitionOrPlaceholder_local0);
	return parseDefinitionOrPlaceholder_local2.orElseGet(parseDefinitionOrPlaceholder_local2, parseDefinitionOrPlaceholder_local1);
}
struct Option_struct Definition parseDefinition(struct Main this, char* input){
	/* nameSeparator */ parseDefinition_local3 = nameSeparator + " ";
	/* divisions.findLast(divisions) */ parseDefinition_local7 = divisions.findLast(divisions);
	/* input.strip(input) */ stripped = input.strip(input);
	/* stripped.lastIndexOf(stripped, " ") */ nameSeparator = stripped.lastIndexOf(stripped, " ");
	if (nameSeparator < 0){
		return new_None_/*  */();
	}
	/* stripped.substring(stripped, 0, nameSeparator) */ beforeName = stripped.substring(stripped, 0, nameSeparator);
	/* stripped.substring(stripped, parseDefinition_local3.length(parseDefinition_local3)) */ name = stripped.substring(stripped, parseDefinition_local3.length(parseDefinition_local3));
	if (!isSymbol(name)){
		return new_None_/*  */();
	}
	/* divideAll(beforeName, /* Main::foldByTypeSeparator */) */ divisions = divideAll(beforeName, /* Main::foldByTypeSeparator */);
	if (divisions.size(divisions) == 1){
		return new_Some_/*  */(new_Definition(parseType(beforeName), name));
	}
	/* parseDefinition_local7.orElse(parseDefinition_local7, null) */ type = parseDefinition_local7.orElse(parseDefinition_local7, null);
	return new_Some_/*  */(new_Definition(parseType(type), name));
}
struct State foldByTypeSeparator(struct Main this, struct State state, char c){
	int foldByTypeSeparator_local1 = c == ' ' && state;
	if (foldByTypeSeparator_local1.isLevel(foldByTypeSeparator_local1)){
		return state.advance(state);
	}
	/* state.append(state, c) */ appended = state.append(state, c);
	if (c == '<'){
		return appended.enter(appended);
	}
	if (c == '>'){
		return appended.exit(appended);
	}
	return appended;
}
struct Type parseType(struct Main this, char* input){
	/* typeParameters.indexOf(typeParameters, stripped) */ parseType_local2 = typeParameters.indexOf(typeParameters, stripped);
	/* input.strip(input) */ stripped = input.strip(input);
	/* parseType_local2.flatMap(parseType_local2, /* typeArguments::find */) */ maybeTypeArgument = parseType_local2.flatMap(parseType_local2, /* typeArguments::find */);
	if (/* maybeTypeArgument instanceof Some */(/* var found */)){
		return found;
	}
	/* switch (stripped) */{
		/* case "int", "Integer", "boolean", "Boolean" -> */{
			return Primitive.I32;
		}
		/* case "char", "Character" -> */{
			return Primitive.I8;
		}
		/* case "void" -> */{
			return Primitive.Void;
		}
		/* case "var" -> */{
			return Primitive.Auto;
		}
	}
	if (stripped.equals(stripped, "String")){
		return new_Ref(Primitive.I8);
	}
	if (stripped.endsWith(stripped, ">")){
	int parseType_local4 = /* stripped.length() - " */ > /* " */;
		/* stripped.substring(stripped, 0, parseType_local4.length(parseType_local4)) */ withoutEnd = stripped.substring(stripped, 0, parseType_local4.length(parseType_local4));
		/* withoutEnd.indexOf(withoutEnd, "<") */ index = withoutEnd.indexOf(withoutEnd, "<");
		if (index >= 0){
	/* withoutEnd.substring(withoutEnd, 0, index) */ parseType_local8 = withoutEnd.substring(withoutEnd, 0, index);
	/* index */ parseType_local9 = index + "<";
	int parseType_local29 = !visitedExpansions.contains(visitedExpansions, generic) && expanding;
			/* parseType_local8.strip(parseType_local8) */ base = parseType_local8.strip(parseType_local8);
			/* withoutEnd.substring(withoutEnd, parseType_local9.length(parseType_local9)) */ substring = withoutEnd.substring(withoutEnd, parseType_local9.length(parseType_local9));
			/* parseValues(substring, /* Main::parseType */) */ parsed = parseValues(substring, /* Main::parseType */);
			if (base.equals(base, "Function")){
	/* parsed.find(parsed, 0) */ parseType_local12 = parsed.find(parsed, 0);
	/* parsed.find(parsed, 1) */ parseType_local14 = parsed.find(parsed, 1);
				/* parseType_local12.orElse(parseType_local12, null) */ arg0 = parseType_local12.orElse(parseType_local12, null);
				/* parseType_local14.orElse(parseType_local14, null) */ returns = parseType_local14.orElse(parseType_local14, null);
				return new_Functional(Lists.listFrom(Lists, arg0), returns);
			}
			if (base.equals(base, "BiFunction")){
	/* parsed.find(parsed, 0) */ parseType_local18 = parsed.find(parsed, 0);
	/* parsed.find(parsed, 1) */ parseType_local20 = parsed.find(parsed, 1);
	/* parsed.find(parsed, 2) */ parseType_local22 = parsed.find(parsed, 2);
				/* parseType_local18.orElse(parseType_local18, null) */ arg0 = parseType_local18.orElse(parseType_local18, null);
				/* parseType_local20.orElse(parseType_local20, null) */ arg1 = parseType_local20.orElse(parseType_local20, null);
				/* parseType_local22.orElse(parseType_local22, null) */ returns = parseType_local22.orElse(parseType_local22, null);
				return new_Functional(Lists.listFrom(Lists, arg0, arg1), returns);
			}
			/* new_Tuple_/*  */(base, parsed) */ generic = new_Tuple_/*  */(base, parsed);
			if (parseType_local29.containsKey(parseType_local29, base)){
	/* expanding.get(expanding, base) */ parseType_local27 = expanding.get(expanding, base);
				visitedExpansions = visitedExpansions.addLast(visitedExpansions, generic);
				parseType_local27.apply(parseType_local27, parsed);
			}
			return new_StructType(merge(base, parsed));
		}
	}
	if (isSymbol(stripped)){
		return new_StructType(stripped);
	}
	return new_Content(stripped);
}
char* merge(struct Main this, char* base, struct List_struct Type parsed){
	/* base */ merge_local0 = base + "_" + parsed;
	/* merge_local0.iter(merge_local0) */ merge_local1 = merge_local0.iter(merge_local0);
	/* merge_local1.map(merge_local1, /* Node::generate */) */ merge_local2 = merge_local1.map(merge_local1, /* Node::generate */);
	/* merge_local2.collect(merge_local2, new_Joiner("_")) */ merge_local3 = merge_local2.collect(merge_local2, new_Joiner("_"));
	return merge_local3.orElse(merge_local3, "");
}
/* map_local1.map(map_local1, mapper) */ map_local2(){
	return map_local1.map(map_local1, map_local1, mapper);
}
struct Iterator_struct R map(struct Iterator_struct Tuple_int_struct Tuple_int_struct Type this, struct R (*)(struct Tuple_int_struct Tuple_int_struct Type) mapper){
	/* this.head.next(this.head) */ map_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(map_local2);
}
struct C collect(struct Iterator_struct Tuple_int_struct Tuple_int_struct Type this, struct Collector_struct Tuple_int_struct Tuple_int_struct Type_struct C collector){
	return this.fold(this, collector.createInitial(collector), /* collector::fold */);
}
/* folder.apply(folder, finalCurrent, next) */ fold_local2(Content[input=next -> folder.apply(finalCurrent, next)] next){
	return folder.apply(folder, folder, finalCurrent, next);
}
struct R fold(struct Iterator_struct Tuple_int_struct Tuple_int_struct Type this, struct R initial, struct R (*)(struct R, struct Tuple_int_struct Tuple_int_struct Type) folder){
	/* initial */ current = initial;
	while (1){
	/* this.head.next(this.head) */ fold_local4 = this.head.next(this.head);
		/* current */ finalCurrent = current;
		/* fold_local4.map(fold_local4, fold_local2) */ optional = fold_local4.map(fold_local4, fold_local2);
		/* switch (optional) */{
			/* case None<R> _ -> */{
				return current;
			}
			/* nextState */ current = nextState;
		}
	}
}
/* new_Iterator_/*  */(/* predicate.test(element) ? new SingleHead */ <  > /* (element) : new EmptyHead */ <  > ()) */ filter_local0(Content[input=element -> new Iterator<>(predicate.test(element) ? new SingleHead<>(element) : new EmptyHead<>())] element){
	return /* new_Iterator_/*  */ */(/* /* predicate.test(element) ? new SingleHead */ */ <  > /* /* (element) : new EmptyHead */ */ <  > ());
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Type filter(struct Iterator_struct Tuple_int_struct Tuple_int_struct Type this, struct Predicate_struct Tuple_int_struct Tuple_int_struct Type predicate){
	return this.flatMap(this, filter_local0);
}
struct Iterator_struct R flatMap(struct Iterator_struct Tuple_int_struct Tuple_int_struct Type this, struct Iterator_struct R (*)(struct Tuple_int_struct Tuple_int_struct Type) mapper){
	struct Iterator_struct R flatMap_local1 = this.map(this, mapper);
	return flatMap_local1.fold(flatMap_local1, new_Iterator_/*  */(new_EmptyHead_/*  */()), /* Iterator::concat */);
}
/* concat_local1.or(concat_local1, /* other::next */) */ concat_local2(){
	return concat_local1.or(concat_local1, concat_local1, /* /* other::next */ */);
}
struct Iterator_struct Tuple_int_struct Tuple_int_struct Type concat(struct Iterator_struct Tuple_int_struct Tuple_int_struct Type this, struct Iterator_struct Tuple_int_struct Tuple_int_struct Type other){
	/* this.head.next(this.head) */ concat_local1 = this.head.next(this.head);
	return new_Iterator_/*  */(concat_local2);
}
struct Option_struct Tuple_int_struct Tuple_int_struct Type next(struct Iterator_struct Tuple_int_struct Tuple_int_struct Type this){
	return this.head.next(this.head);
}
struct List_struct Tuple_int_struct Type parseValues(struct Main this, char* input, struct Tuple_int_struct Tuple_int_struct Type (*)(char*) compiler){
	return parseAll(input, /* Main::foldValueChar */, compiler);
}
struct State foldValueChar(struct Main this, struct State state, char c){
	int foldValueChar_local1 = c == ',' && state;
	if (foldValueChar_local1.isLevel(foldValueChar_local1)){
		return state.advance(state);
	}
	/* state.append(state, c) */ appended = state.append(state, c);
	if (c == '-'){
		if (/* appended.peek() instanceof Some */(/* var maybeArrow */)){
			if (maybeArrow == '>'){
	/* appended.popAndAppend(appended) */ foldValueChar_local4 = appended.popAndAppend(appended);
				return foldValueChar_local4.orElse(foldValueChar_local4, appended);
			}
		}
	}
	if (c == '<' || c == '('){
		return appended.enter(appended);
	}
	if (c == '>' || c == ')'){
		return appended.exit(appended);
	}
	return appended;
}
int isSymbol(struct Main this, char* input){
	/* input.strip(input) */ stripped = input.strip(input);
	if (stripped.isEmpty(stripped)){
		return 0;
	}
	/* for (var i = 0; i < stripped.length(); i++) */{
		/* stripped.charAt(stripped, i) */ c = stripped.charAt(stripped, i);
		if (Character.isLetter(Character, c) || /* (i */ != 0 && Character.isDigit(Character, /* c) */) || c == '_'){
			/* continue; */
		}
		return 0;
	}
	return 1;
}
char* generatePlaceholder(struct Main this, char* input){
	return "/* " + input + " */";
}
