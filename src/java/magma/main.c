#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
struct Main {
};
struct Main new(){
}
struct State {
};
int temp;
int temp;
int temp;
int temp;
struct State new(){
}
struct public State_State(){
	temp();
}
struct void State_popAndAppend(){
	temp();
}
struct Character State_pop(){
	return temp;
}
struct boolean State_isEmpty(){
	return temp;
}
struct void State_append(){
	temp();
}
struct State new(){
}
struct State new(){
}
struct State new(){
}
struct boolean State_isShallow(){
	return temp;
}
struct boolean State_isLevel(){
	return temp;
}
struct Temp State_segments(){
	return temp;
}
struct Main new(){
}
struct Main new(){
}
struct record Main_Node(){
}
struct Main new(){
}
struct void __main__(){
	struct Path source = child.property();
	temp();
}
struct Temp Main_runWithSource(){
	struct String string = compile();
	struct Path target = child.property();
	return temp;
}
struct Main new(){
}
struct Temp Main_compileRootSegment(){
	struct Temp maybeWhitespace = compileWhitespace();
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	struct Temp maybeClass = compileClass();
	if (1) {
	}
	return temp;
}
struct Temp Main_compileClass(){
	struct int classIndex = child.property();
	if (1) {
	}
	struct String afterKeyword = child.property();
	struct int contentStart = child.property();
	if (1) {
	}
	struct String name = child.property();
	if (1) {
	}
	struct String withEnd = child.property();
	if (1) {
	}
	struct String inputContent = child.property();
	return temp;
}
struct Temp Main_invalidate(){
	temp();
	return temp;
}
struct Temp Main_compileClassSegment(){
	struct Temp maybeWhitespace = compileWhitespace();
	if (1) {
	}
	struct Temp maybeClass = compileClass();
	if (1) {
	}
	struct Temp inputType = compileMethod();
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	return temp;
}
struct Temp Main_compileMethod(){
	struct int paramStart = child.property();
	if (1) {
	}
	struct String header = child.property();
	return temp;
}
struct Temp Main_compileDefinition(){
	return temp;
}
struct Temp Main_parseDefinition(){
	struct int nameSeparator = child.property();
	if (1) {
	}
	struct String beforeName = child.property();
	struct String oldName = child.property();
	struct int typeSeparator = child.property();
	struct String inputType = condition ? whenTrue : whenFalse();
	return temp;
}
struct Node Main_modifyDefinition(){
	struct String newName = condition ? whenTrue : whenFalse;
	return temp;
}
struct Temp Main_compileStatement(){
	struct Temp maybeWhitespace = compileWhitespace();
	if (1) {
	}
	struct String stripped = child.property();
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	return temp;
}
struct Temp Main_compileValue(){
	if (1) {
	}
	if (1) {
	}
	if (1) {
	}
	struct String stripped = child.property();
	if (1) {
	}
	return temp;
}
struct String Main_generateMethod(){
	return temp;
}
struct Temp Main_generateDefinition(){
	return temp;
}
struct Temp Main_compileType(){
	struct String stripped = child.property();
	if (1) {
	}
	if (1) {
	}
	return temp;
}
struct Temp Main_generateStructType(){
	return temp;
}
struct boolean Main_isSymbol(){
	for(;;){
	}
	return temp;
}
struct Temp Main_compileWhitespace(){
	if (1) {
	}
	return temp;
}
int main(){
	__main__();
	return 0;
}
