export class TypescriptRules {
	public static createRule() : Rule {return new TypeRule( "root", CommonLang.Statements( "children", new OrRule( Lists.of( JavaRules.createTypedWhitespaceRule( ), TypescriptRules.createImportRule( ), TypescriptRules.createStructureRule( "class"), TypescriptRules.createStructureRule( "interface")))));;}
	private static createStructureMemberRule() : Rule { let definitionRule : var=TypescriptRules.createDefinitionRule( ); let valueLazy : LazyRule=new MutableLazyRule( );return new OrRule( Lists.of( JavaRules.createTypedWhitespaceRule( ), TypescriptRules.createMethodRule( definitionRule, valueLazy), JavaStructureStatement.createStructureStatementRule( definitionRule, valueLazy)));;}
	private static createMethodRule( definition : Rule,  valueLazy : LazyRule) : Rule { let header : Rule=new PrefixRule( "\n\t", new NodeRule( "header", new OrRule( Lists.of( definition, TypescriptRules.createConstructorRule( definition))))); let functionSegmentRule : LazyRule=new MutableLazyRule( ); let value : var=JavaRules.initValueRule( functionSegmentRule, valueLazy, " => ", definition); let children : var=CommonLang.Statements( "children", FunctionSegments.initFunctionSegmentRule( functionSegmentRule, value, definition)); let childRule : Rule=new SuffixRule( LocatingRule.First( header, " {", new StripRule( "", children, "after-children")), "}");return new TypeRule( "method", new OptionNodeListRule( "children", childRule, new SuffixRule( header, ";")));;}
	private static createConstructorRule( definition : Rule) : Rule { let parametersRule : var=JavaRules.createParametersRule( definition);return new TypeRule( "constructor", new PrefixRule( "constructor(", new SuffixRule( parametersRule, ")")));;}
	private static createDefinitionRule() : Rule { let definition : LazyRule=new MutableLazyRule( ); let modifiers : var=Modifier.createModifiersRule( ); let parameters : var=JavaRules.createParametersRule( definition); let name : Rule=new StringRule( "name"); let leftRule : Rule=new OptionNodeListRule( "parameters", new SuffixRule( LocatingRule.First( name, "(", parameters), ")"), name); let first : var=LocatingRule.First( leftRule, " : ", new NodeRule( "type", TypescriptRules.createTypeRule( )));return definition.set( new OptionNodeListRule( "modifiers", LocatingRule.Last( modifiers, " ", first), first));;}
	private static createTypeRule() : Rule { let type : LazyRule=new MutableLazyRule( );return type.set( new OrRule( Lists.of( JavaRules.createTemplateRule( type), TypescriptRules.createArrayRule( type), CommonRules.createSymbolRule( ))));;}
	private static createStructureRule( type : String) : Rule { let children : var=CommonLang.Statements( "members", TypescriptRules.createStructureMemberRule( )); let name : Rule=new StringRule( "name"); let afterKeyword : var=LocatingRule.First( JavaRules.attachTypeParams( name), " {", new SuffixRule( children, "\n}\n"));return new TypeRule( type, new PrefixRule( "export " + type + " ", afterKeyword));;}
	private static createImportRule() : Rule { let segments : Rule=new SuffixRule( NodeListRule.createNodeListRule( "segments", new DelimitedFolder( '/'), new StringRule( "value")), "\";\n"); let leftRule : Rule=new NodeListRule( "values", new StringRule( "value"), new DelimitedDivider( ", ")); let first : var=LocatingRule.First( leftRule, " } from \"", segments);return new TypeRule( "import", new PrefixRule( "import { ", first));;}
	private static createArrayRule( orRule : LazyRule) : TypeRule {return new TypeRule( "array", new SuffixRule( new NodeRule( "child", orRule), "[]"));;}
}
