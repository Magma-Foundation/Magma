import { Option } from "../../../magmac/api/Option";
import { List } from "../../../magmac/api/collect/list/List";
import { Lists } from "../../../magmac/api/collect/list/Lists";
import { Iters } from "../../../magmac/api/iter/Iters";
import { ListCollector } from "../../../magmac/api/iter/collect/ListCollector";
import { CompileResult } from "../../../magmac/app/compile/error/CompileResult";
import { Node } from "../../../magmac/app/compile/node/Node";
import { ContextRule } from "../../../magmac/app/compile/rule/ContextRule";
import { ExactRule } from "../../../magmac/app/compile/rule/ExactRule";
import { FilterRule } from "../../../magmac/app/compile/rule/FilterRule";
import { LocatingRule } from "../../../magmac/app/compile/rule/LocatingRule";
import { NodeListRule } from "../../../magmac/app/compile/rule/NodeListRule";
import { NodeRule } from "../../../magmac/app/compile/rule/NodeRule";
import { OrRule } from "../../../magmac/app/compile/rule/OrRule";
import { PrefixRule } from "../../../magmac/app/compile/rule/PrefixRule";
import { Rule } from "../../../magmac/app/compile/rule/Rule";
import { StringRule } from "../../../magmac/app/compile/rule/StringRule";
import { StripRule } from "../../../magmac/app/compile/rule/StripRule";
import { SuffixRule } from "../../../magmac/app/compile/rule/SuffixRule";
import { TypeRule } from "../../../magmac/app/compile/rule/TypeRule";
import { Divider } from "../../../magmac/app/compile/rule/divide/Divider";
import { FoldingDivider } from "../../../magmac/app/compile/rule/divide/FoldingDivider";
import { DelimitedFolder } from "../../../magmac/app/compile/rule/fold/DelimitedFolder";
import { DividingSplitter } from "../../../magmac/app/compile/rule/split/DividingSplitter";
import { JavaDeserializers } from "../../../magmac/app/lang/java/JavaDeserializers";
import { JavaLang } from "../../../magmac/app/lang/java/JavaLang";
import { JavaNamespacedNode } from "../../../magmac/app/lang/java/JavaNamespacedNode";
import { Modifier } from "../../../magmac/app/lang/node/Modifier";
import { MultipleCaseValue } from "../../../magmac/app/lang/node/MultipleCaseValue";
import { Operator } from "../../../magmac/app/lang/node/Operator";
import { SingleCaseValue } from "../../../magmac/app/lang/node/SingleCaseValue";
import { StructureMembers } from "../../../magmac/app/lang/node/StructureMembers";
export class JavaRules {
	createConstructionRule() : Rule {return new TypeRule( "construction", new StripRule( new PrefixRule( "new ", new NodeRule( "type", JavaRules.createTypeRule( )))));;}
	createInvokableRule(value : Rule) : Rule {childRule : Rule=new OrRule( Lists.of( JavaRules.createConstructionRule( ), value));caller : Rule=new NodeRule( "caller", new SuffixRule( childRule, "("));arguments : var=JavaRules.createArgumentsRule( value);splitter : var=DividingSplitter.Last( new FoldingDivider( new InvocationFolder( )), "");return new TypeRule( "invokable", new StripRule( new SuffixRule( new LocatingRule( caller, splitter, arguments), ")")));;}
	createRootSegmentRule() : Rule {classMemberRule : var=StructureMembers.createClassMemberRule( );return new OrRule( Lists.of( JavaRules.createWhitespaceRule( ), JavaNamespacedNode.createNamespacedRule( "package"), JavaNamespacedNode.createNamespacedRule( "import"), JavaRules.createStructureRule( "record", classMemberRule), JavaRules.createStructureRule( "interface", classMemberRule), JavaRules.createStructureRule( "class", classMemberRule), JavaRules.createStructureRule( "enum", classMemberRule)));;}
	createRule() : Rule {return new TypeRule( "root", CommonLang.Statements( "children", JavaRules.createRootSegmentRule( )));;}
	createStructureRule(keyword : String, structureMember : Rule) : Rule {name : Rule=new StripRule( FilterRule.Symbol( new StringRule( "name")));beforeContent : var=JavaRules.attachTypeParams( name);withParameters : Rule=new OrRule( Lists.of( new StripRule( new SuffixRule( LocatingRule.First( beforeContent, "(", JavaRules.createParametersRule( JavaRules.createDefinitionRule( ))), ")")), beforeContent));type : var=JavaRules.createTypeRule( );extended : var=NodeListRule.createNodeListRule( "extended", new ValueFolder( ), type);withEnds : Rule=new OrRule( Lists.of( LocatingRule.First( withParameters, " extends ", extended), withParameters));implemented : var=NodeListRule.createNodeListRule( "implemented", new ValueFolder( ), type);withImplements : Rule=new OrRule( Lists.of( new ContextRule( "With implements", LocatingRule.First( withEnds, "implements", implemented)), new ContextRule( "Without implements", withEnds)));withPermits : Rule=new OrRule( Lists.of( LocatingRule.Last( withImplements, " permits ", NodeListRule.Values( "variants", type)), withImplements));afterKeyword : var=LocatingRule.First( withPermits, "{", new StripRule( new SuffixRule( CommonLang.Statements( "children", structureMember), "}")));return new TypeRule( keyword, LocatingRule.First( Modifier.createModifiersRule( ), keyword+" ", afterKeyword));;}
	createAccessRule(type : String, infix : String, value : LazyRule) : Rule {property : var=CommonRules.createSymbolRule( "property");return new TypeRule( type, LocatingRule.Last( new NodeRule( "receiver", value), infix, property));;}
	deserializeLambdaValueContent(node : Node) : Option<CompileResult<JavaLang.JavaLambdaValueContent>> {return Destructors.destructWithType( "value", node).map( 0);;}
	createYieldRule(value : Rule) : Rule {return new TypeRule( "yield", new StripRule( new PrefixRule( "yield ", new NodeRule( "value", value))));;}
	createLambdaRule(value : LazyRule, functionSegment : Rule, infix : String, definition : Rule) : Rule {afterInfix : Rule=new OrRule( Lists.of( new TypeRule( "block", new StripRule( new PrefixRule( "{", new SuffixRule( CommonLang.Statements( "children", functionSegment), "}")))), new TypeRule( "value", new NodeRule( "value", value))));parameters : var=JavaRules.createLambdaParameterRule( definition);withParentheses : Rule=new TypeRule( "multiple", new StripRule( new PrefixRule( "(", new SuffixRule( parameters, ")"))));withoutParentheses : var=CommonRules.createSymbolRule( );header : Rule=new NodeRule( "header", new OrRule( Lists.of( withParentheses, withoutParentheses)));return new TypeRule( "lambda", LocatingRule.First( header, infix, new NodeRule( "content", afterInfix)));;}
	createStatementRule(rule : Rule) : Rule {child : var=new NodeRule( "child", rule);return new TypeRule( "statement", new StripRule( new SuffixRule( child, ";")));;}
	createLambdaParameterRule(definition : Rule) : Rule {return NodeListRule.createNodeListRule( "parameters", new ValueFolder( ), new OrRule( Lists.of( definition, CommonRules.createSymbolRule( ))));;}
	createBlockHeaderRule(value : Rule, definition : Rule) : Rule {return new OrRule( Lists.of( new TypeRule( "else", new StripRule( new ExactRule( "else"))), new TypeRule( "try", new StripRule( new ExactRule( "try"))), JavaRules.createConditionalRule( "if", value), JavaRules.createConditionalRule( "while", value), new TypeRule( "catch", new StripRule( new PrefixRule( "catch", new StripRule( new PrefixRule( "(", new SuffixRule( new NodeRule( "definition", definition), ")"))))))));;}
	createBlockRule(functionSegmentRule : LazyRule, value : Rule, definition : Rule) : Rule {header : Rule=new NodeRule( "header", JavaRules.createBlockHeaderRule( value, definition));return JavaRules.createBlockRule0( header, functionSegmentRule);;}
	createBlockRule0(header : Rule, functionSegmentRule : Rule) : TypeRule {children : var=CommonLang.Statements( "children", functionSegmentRule);first : var=DividingSplitter.First( new FoldingDivider( new BlockFolder( )), "");childRule : Rule=new LocatingRule( new SuffixRule( header, "{"), first, children);return new TypeRule( "block", new StripRule( new SuffixRule( childRule, "}")));;}
	createConditionalRule(type : String, value : Rule) : Rule {condition : Rule=new NodeRule( "condition", value);childRule : Rule=new StripRule( new PrefixRule( "(", new SuffixRule( condition, ")")));return new TypeRule( type, new StripRule( new PrefixRule( type, childRule)));;}
	createReturnRule(value : Rule) : Rule {return new TypeRule( "return", new StripRule( new PrefixRule( "return ", new NodeRule( "child", value))));;}
	createWhitespaceRule() : Rule {return new TypeRule( "whitespace", new StripRule( new ExactRule( "")));;}
	createStringRule() : Rule {return new TypeRule( "string", new StripRule( new PrefixRule( "\"", new SuffixRule( new StringRule( "value"), "\""))));;}
	createOperationRule(operator : Operator, value : LazyRule) : Rule {return new TypeRule( operator.type( ), LocatingRule.First( new NodeRule( "left", value), operator.text( ), new NodeRule( "right", value)));;}
	createCharRule() : Rule {return new TypeRule( "char", new StripRule( new PrefixRule( "'", new SuffixRule( new StringRule( "value"), "'"))));;}
	createNumberRule() : Rule {return new TypeRule( "number", new StripRule( FilterRule.Number( new StringRule( "value"))));;}
	createNotRule(value : LazyRule) : TypeRule {return new TypeRule( "not", new StripRule( new PrefixRule( "!", new NodeRule( "child", value))));;}
	createIndexRule(value : LazyRule) : Rule {parent : var=new NodeRule( "parent", value);argument : var=new NodeRule( "argument", value);return new TypeRule( "index", new StripRule( new SuffixRule( LocatingRule.First( parent, "[", argument), "]")));;}
	initValueRule(segment : Rule, value : LazyRule, lambdaInfix : String, definition : Rule) : LazyRule {return value.set( new OrRule( JavaRules.createValuesRules( segment, value, lambdaInfix, definition)));;}
	createValuesRules(functionSegment : Rule, value : LazyRule, lambdaInfix : String, definition : Rule) : List<Rule> {ruleList : var=Lists.of( JavaRules.createSwitchRule( functionSegment, value), JavaRules.createLambdaRule( value, functionSegment, lambdaInfix, definition), JavaRules.createNotRule( value), JavaRules.createCharRule( ), JavaRules.createStringRule( ), JavaRules.createInvokableRule( value), JavaRules.createIndexRule( value), JavaRules.createNumberRule( ), CommonRules.createSymbolRule( ), JavaRules.createAccessRule( "data-access", ".", value), JavaRules.createAccessRule( "method-access", "::", value), JavaRules.createInstanceOfRule( value));operatorLists : var=Iters.fromValues( Operator.values( )).map( 0).collect( new ListCollector<>( ));return ruleList.addAllLast( operatorLists);;}
	createInstanceOfRule(value : LazyRule) : Rule {base : var=new NodeRule( "base", JavaRules.createBaseRule( ));parameters : var=JavaRules.createParametersRule( JavaRules.createDefinitionRule( ));withParameters : var=new TypeRule( "with-parameters", new StripRule( new SuffixRule( LocatingRule.First( base, "(", parameters), ")")));withoutParameters : var=new TypeRule( "with-name", new StripRule( LocatingRule.Last( base, " ", new StringRule( "name"))));rightRule : var=new OrRule( Lists.of( withParameters, withoutParameters));return new TypeRule( "instance-of", LocatingRule.Last( new NodeRule( "child", value), " instanceof ", new NodeRule( "definition", rightRule)));;}
	createSwitchRule(functionSegmentRule : Rule, value : Rule) : TypeRule {value1 : var=new NodeRule( "value", value);header : var=new PrefixRule( "switch", new StripRule( new PrefixRule( "(", new SuffixRule( value1, ")"))));return new TypeRule( "switch", JavaRules.createBlockRule0( new StripRule( header), functionSegmentRule));;}
	createDefinitionRule() : Rule {modifiers : var=Modifier.createModifiersRule( );annotations : var=NodeListRule.createNodeListRule( "annotations", new DelimitedFolder( '\n'), new StripRule( new PrefixRule( "@", new StringRule( "value"))));beforeTypeParams : Rule=new OrRule( Lists.of( LocatingRule.Last( annotations, "\n", modifiers), modifiers));leftRule1 : var=JavaRules.attachTypeParams( beforeTypeParams);rightRule : Rule=new NodeRule( "type", JavaRules.createTypeRule( ));divider : Divider=new FoldingDivider( new TypeSeparatorFolder( ));splitter : var=DividingSplitter.Last( divider, " ");leftRule : Rule=new LocatingRule( leftRule1, splitter, rightRule);stripRule : Rule=new StripRule( LocatingRule.Last( leftRule, " ", new StripRule( FilterRule.Symbol( new StringRule( "name")))));return new TypeRule( "definition", stripRule);;}
	attachTypeParams(beforeTypeParams : Rule) : Rule {typeParams : var=NodeListRule.createNodeListRule( "type-parameters", new ValueFolder( ), new StringRule( "value"));return new OptionNodeListRule( "type-parameters", new StripRule( new SuffixRule( LocatingRule.First( beforeTypeParams, "<", typeParams), ">")), beforeTypeParams);;}
	createCaseRule(value : Rule, segment : Rule) : Rule {typeRule : var=JavaRules.createTypeRule( );name : Rule=new StripRule( new StringRule( "name"));last : var=LocatingRule.Last( new NodeRule( "type", typeRule), " ", name);definitions : Rule=new TypeRule( "case-definition", new OrRule( Lists.of( new StripRule( last), name)));beforeArrow : var=NodeListRule.Values( "definitions", definitions);children : var=new OrRule( Lists.of( SingleCaseValue.createRule( value), MultipleCaseValue.createRule( segment)));childRule : var=LocatingRule.First( beforeArrow, "->", new NodeRule( "value", children));return new TypeRule( "case", new StripRule( new PrefixRule( "case", childRule)));;}
	createAssignmentRule(definition : Rule, value : Rule) : Rule {before : Rule=new NodeRule( "destination", new OrRule( Lists.of( definition, value)));source : Rule=new NodeRule( "source", value);return new TypeRule( "assignment", LocatingRule.First( before, "=", source));;}
	createTypeRule() : Rule {type : LazyRule=new MutableLazyRule( );return type.set( new OrRule( Lists.of( JavaLang.JavaVariadicType.createVariadicRule( type), JavaLang.JavaArrayType.createArrayRule( type), JavaRules.createTemplateRule( type), CommonRules.createSymbolRule( ), JavaLang.Qualified.createQualifiedRule( ))));;}
	createBaseRule() : OrRule {return new OrRule( Lists.of( CommonRules.createSymbolRule( ), JavaLang.Qualified.createQualifiedRule( )));;}
	createTemplateRule(type : Rule) : Rule {base : Rule=new NodeRule( "base", JavaRules.createBaseRule( ));arguments : var=NodeListRule.Values( "arguments", type);return new TypeRule( "template", new StripRule( new SuffixRule( LocatingRule.First( base, "<", arguments), ">")));;}
	createArgumentsRule(value : Rule) : Rule {return NodeListRule.Values( "arguments", new OrRule( Lists.of( JavaRules.createWhitespaceRule( ), value)));;}
	createParametersRule(definition : Rule) : Rule {return NodeListRule.createNodeListRule( "parameters", new ValueFolder( ), new OrRule( Lists.of( JavaRules.createWhitespaceRule( ), definition)));;}
}
