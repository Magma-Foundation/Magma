export class JavaRules {
	private static createConstructionRule() : Rule {return new TypeRule( "construction", new StripRule( new PrefixRule( "new ", new NodeRule( "type", JavaRules.createTypeRule( )))));;}
	public static createInvokableRule( value : Rule) : Rule { let childRule : Rule=new OrRule( Lists.of( JavaRules.createConstructionRule( ), value)); let caller : Rule=new NodeRule( "caller", new SuffixRule( childRule, "(")); let arguments : var=JavaRules.createArgumentsRule( value); let splitter : var=DividingSplitter.Last( new FoldingDivider( new InvocationFolder( )), "");return new TypeRule( "invokable", new StripRule( new SuffixRule( new LocatingRule( caller, splitter, arguments), ")")));;}
	private static createRootSegmentRule() : Rule { let classMemberRule : var=StructureMembers.createClassMemberRule( );return new OrRule( Lists.of( JavaRules.createTypedWhitespaceRule( ), JavaNamespacedNode.createNamespacedRule( "package"), JavaNamespacedNode.createNamespacedRule( "import"), JavaRules.createStructureRule( "record", classMemberRule), JavaRules.createStructureRule( "interface", classMemberRule), JavaRules.createStructureRule( "class", classMemberRule), JavaRules.createStructureRule( "enum", classMemberRule)));;}
	public static createRule() : Rule {return new TypeRule( "root", CommonLang.Statements( "children", JavaRules.createRootSegmentRule( )));;}
	public static createStructureRule( keyword : String,  structureMember : Rule) : Rule { let name : Rule=new StripRule( FilterRule.Symbol( new StringRule( "name"))); let beforeContent : var=JavaRules.attachTypeParams( name); let withParameters : Rule=new OrRule( Lists.of( new StripRule( new SuffixRule( LocatingRule.First( beforeContent, "(", JavaRules.createParametersRule( JavaRules.createDefinitionRule( ))), ")")), beforeContent)); let type : var=JavaRules.createTypeRule( ); let extended : var=NodeListRule.createNodeListRule( "extended", new ValueFolder( ), type); let withEnds : Rule=new OrRule( Lists.of( LocatingRule.First( withParameters, " extends ", extended), withParameters)); let implemented : var=NodeListRule.createNodeListRule( "implemented", new ValueFolder( ), type); let withImplements : Rule=new OrRule( Lists.of( new ContextRule( "With implements", LocatingRule.First( withEnds, "implements", implemented)), new ContextRule( "Without implements", withEnds))); let withPermits : Rule=new OrRule( Lists.of( LocatingRule.Last( withImplements, " permits ", Values( "variants", type)), withImplements)); let afterKeyword : var=LocatingRule.First( withPermits, "{", new StripRule( new SuffixRule( CommonLang.Statements( "children", structureMember), "}")));return new TypeRule( keyword, LocatingRule.First( Modifier.createModifiersRule( ), keyword+" ", afterKeyword));;}
	private static createAccessRule( type : String,  infix : String,  value : LazyRule) : Rule { let property : var=CommonRules.createSymbolRule( "property"); let typeArguments : var=Values( "type-arguments", JavaRules.createTypeRule( ));return new TypeRule( type, LocatingRule.Last( new NodeRule( "receiver", value), infix, new OrRule( Lists.of( new StripRule( new PrefixRule( "<", LocatingRule.Last( typeArguments, ">", property))), property))));;}
	public static deserializeLambdaValueContent( node : Node) : Option<CompileResult<JavaLang.JavaLambdaValueContent>> {return Destructors.destructWithType( "value", node).map( 0);;}
	public static createYieldRule( value : Rule) : Rule {return new TypeRule( "yield", new StripRule( new PrefixRule( "yield ", new NodeRule( "value", value))));;}
	private static createLambdaRule( value : LazyRule,  functionSegment : Rule,  infix : String,  definition : Rule) : Rule { let afterInfix : Rule=new OrRule( Lists.of( new TypeRule( "block", new StripRule( new PrefixRule( "{", new SuffixRule( CommonLang.Statements( "children", functionSegment), "}")))), new TypeRule( "value", new NodeRule( "value", value)))); let parameters : var=JavaRules.createLambdaParameterRule( definition); let withParentheses : Rule=new TypeRule( "multiple", new StripRule( new PrefixRule( "(", new SuffixRule( parameters, ")")))); let withoutParentheses : var=CommonRules.createSymbolRule( ); let header : Rule=new NodeRule( "header", new OrRule( Lists.of( withParentheses, withoutParentheses)));return new TypeRule( "lambda", LocatingRule.First( header, infix, new NodeRule( "content", afterInfix)));;}
	public static createStatementRule( rule : Rule) : Rule { let child : var=new NodeRule( "child", rule);return new TypeRule( "statement", new StripRule( new SuffixRule( child, ";")));;}
	private static createLambdaParameterRule( definition : Rule) : Rule {return NodeListRule.createNodeListRule( "parameters", new ValueFolder( ), new OrRule( Lists.of( definition, CommonRules.createSymbolRule( ))));;}
	private static createBlockHeaderRule( value : Rule,  definition : Rule) : Rule {return new OrRule( Lists.of( new TypeRule( "else", new StripRule( new ExactRule( "else"))), new TypeRule( "try", new StripRule( new ExactRule( "try"))), JavaRules.createConditionalRule( "if", value), JavaRules.createConditionalRule( "while", value), new TypeRule( "catch", new StripRule( new PrefixRule( "catch", new StripRule( new PrefixRule( "(", new SuffixRule( new NodeRule( "definition", definition), ")"))))))));;}
	public static createBlockRule( functionSegmentRule : LazyRule,  value : Rule,  definition : Rule) : Rule { let header : Rule=new NodeRule( "header", JavaRules.createBlockHeaderRule( value, definition));return JavaRules.createBlockRule0( header, functionSegmentRule);;}
	private static createBlockRule0( header : Rule,  functionSegmentRule : Rule) : TypeRule { let children : var=CommonLang.Statements( "children", functionSegmentRule); let first : var=DividingSplitter.First( new FoldingDivider( new BlockFolder( )), ""); let childRule : Rule=new LocatingRule( new SuffixRule( header, "{"), first, children);return new TypeRule( "block", new StripRule( new SuffixRule( childRule, "}")));;}
	private static createConditionalRule( type : String,  value : Rule) : Rule { let condition : Rule=new NodeRule( "condition", value); let childRule : Rule=new StripRule( new PrefixRule( "(", new SuffixRule( condition, ")")));return new TypeRule( type, new StripRule( new PrefixRule( type, childRule)));;}
	public static createReturnRule( value : Rule) : Rule {return new TypeRule( "return", new StripRule( new PrefixRule( "return ", new NodeRule( "child", value))));;}
	public static createTypedWhitespaceRule() : Rule {return new TypeRule( "whitespace", JavaRules.createWhitespaceRule( ));;}
	private static createWhitespaceRule() : StripRule {return new StripRule( new ExactRule( ""));;}
	private static createStringRule() : Rule {return new TypeRule( "string", new StripRule( new PrefixRule( "\"", new SuffixRule( new StringRule( "value"), "\""))));;}
	private static createOperationRule( operator : Operator,  value : LazyRule) : Rule {return new TypeRule( operator.type( ), LocatingRule.First( new NodeRule( "left", value), operator.text( ), new NodeRule( "right", value)));;}
	private static createCharRule() : Rule {return new TypeRule( "char", new StripRule( new PrefixRule( "'", new SuffixRule( new StringRule( "value"), "'"))));;}
	private static createNumberRule() : Rule {return new TypeRule( "number", new StripRule( FilterRule.Number( new StringRule( "value"))));;}
	private static createNotRule( value : LazyRule) : TypeRule {return new TypeRule( "not", new StripRule( new PrefixRule( "!", new NodeRule( "child", value))));;}
	private static createIndexRule( value : LazyRule) : Rule { let parent : var=new NodeRule( "parent", value); let argument : var=new NodeRule( "argument", value);return new TypeRule( "index", new StripRule( new SuffixRule( LocatingRule.First( parent, "[", argument), "]")));;}
	public static initValueRule( segment : Rule,  value : LazyRule,  lambdaInfix : String,  definition : Rule) : LazyRule {return value.set( new OrRule( JavaRules.createValuesRules( segment, value, lambdaInfix, definition)));;}
	private static createValuesRules( functionSegment : Rule,  value : LazyRule,  lambdaInfix : String,  definition : Rule) : List<Rule> { let ruleList : var=Lists.of( JavaRules.createSwitchRule( functionSegment, value), JavaRules.createLambdaRule( value, functionSegment, lambdaInfix, definition), JavaRules.createNotRule( value), JavaRules.createCharRule( ), JavaRules.createStringRule( ), JavaRules.createInvokableRule( value), JavaRules.createIndexRule( value), JavaRules.createNumberRule( ), CommonRules.createSymbolRule( ), JavaRules.createAccessRule( "data-access", ".", value), JavaRules.createAccessRule( "method-access", "::", value), JavaRules.createInstanceOfRule( value)); let operatorLists : var=Iters.fromValues( Operator.values( )).map( 0).collect( new ListCollector<>( ));return ruleList.addAllLast( operatorLists);;}
	private static createInstanceOfRule( value : LazyRule) : Rule { let base : var=new NodeRule( "base", JavaRules.createBaseRule( )); let parameters : var=JavaRules.createParametersRule( JavaRules.createDefinitionRule( )); let withParameters : var=new TypeRule( "with-parameters", new StripRule( new SuffixRule( LocatingRule.First( base, "(", parameters), ")"))); let withoutParameters : var=new TypeRule( "with-name", new StripRule( LocatingRule.Last( base, " ", new StringRule( "name")))); let rightRule : var=new OrRule( Lists.of( withParameters, withoutParameters));return new TypeRule( "instance-of", LocatingRule.Last( new NodeRule( "child", value), " instanceof ", new NodeRule( "definition", rightRule)));;}
	private static createSwitchRule( functionSegmentRule : Rule,  value : Rule) : TypeRule { let value1 : var=new NodeRule( "value", value); let header : var=new PrefixRule( "switch", new StripRule( new PrefixRule( "(", new SuffixRule( value1, ")"))));return new TypeRule( "switch", JavaRules.createBlockRule0( new StripRule( header), functionSegmentRule));;}
	public static createDefinitionRule() : Rule { let modifiers : var=Modifier.createModifiersRule( ); let annotations : var=NodeListRule.createNodeListRule( "annotations", new DelimitedFolder( '\n'), new StripRule( new PrefixRule( "@", new StringRule( "value")))); let beforeTypeParams : Rule=new OrRule( Lists.of( LocatingRule.Last( annotations, "\n", modifiers), modifiers)); let leftRule1 : var=JavaRules.attachTypeParams( beforeTypeParams); let rightRule : Rule=new NodeRule( "type", JavaRules.createTypeRule( )); let divider : Divider=new FoldingDivider( new TypeSeparatorFolder( )); let splitter : var=DividingSplitter.Last( divider, " "); let leftRule : Rule=new LocatingRule( leftRule1, splitter, rightRule); let stripRule : Rule=new StripRule( LocatingRule.Last( leftRule, " ", new StripRule( FilterRule.Symbol( new StringRule( "name")))));return new TypeRule( "definition", stripRule);;}
	public static attachTypeParams( beforeTypeParams : Rule) : Rule { let typeParams : var=NodeListRule.createNodeListRule( "type-parameters", new ValueFolder( ), new StringRule( "value"));return new OptionNodeListRule( "type-parameters", new StripRule( new SuffixRule( LocatingRule.First( beforeTypeParams, "<", typeParams), ">")), beforeTypeParams);;}
	public static createCaseRule( value : Rule,  segment : Rule) : Rule { let typeRule : var=JavaRules.createTypeRule( ); let name : Rule=new StripRule( new StringRule( "name")); let last : var=LocatingRule.Last( new NodeRule( "type", typeRule), " ", name); let definitions : Rule=new TypeRule( "case-definition", new OrRule( Lists.of( new StripRule( last), name))); let beforeArrow : var=Values( "definitions", definitions); let children : var=new OrRule( Lists.of( SingleCaseValue.createRule( value), MultipleCaseValue.createRule( segment))); let childRule : var=LocatingRule.First( beforeArrow, "->", new NodeRule( "value", children));return new TypeRule( "case", new StripRule( new PrefixRule( "case", childRule)));;}
	public static createAssignmentRule( definition : Rule,  value : Rule) : Rule { let before : Rule=new NodeRule( "destination", new OrRule( Lists.of( definition, value))); let source : Rule=new NodeRule( "source", value);return new TypeRule( "assignment", LocatingRule.First( before, "=", source));;}
	private static createTypeRule() : Rule { let type : LazyRule=new MutableLazyRule( );return type.set( new OrRule( Lists.of( JavaLang.JavaVariadicType.createVariadicRule( type), JavaLang.JavaArrayType.createArrayRule( type), JavaRules.createTemplateRule( type), CommonRules.createSymbolRule( ), JavaLang.Qualified.createQualifiedRule( ))));;}
	private static createBaseRule() : OrRule {return new OrRule( Lists.of( CommonRules.createSymbolRule( ), JavaLang.Qualified.createQualifiedRule( )));;}
	public static createTemplateRule( type : Rule) : Rule { let base : Rule=new NodeRule( "base", JavaRules.createBaseRule( )); let arguments : var=Values( "arguments", type);return new TypeRule( "template", new StripRule( new SuffixRule( LocatingRule.First( base, "<", new OrRule( Lists.of( arguments, JavaRules.createWhitespaceRule( )))), ">")));;}
	public static createArgumentsRule( value : Rule) : Rule {return new OptionNodeListRule( "arguments", Values( "arguments", new OrRule( Lists.of( JavaRules.createTypedWhitespaceRule( ), value))), JavaRules.createWhitespaceRule( ));;}
	public static createParametersRule( definition : Rule) : Rule {return NodeListRule.createNodeListRule( "parameters", new ValueFolder( ), new OrRule( Lists.of( JavaRules.createTypedWhitespaceRule( ), definition)));;}
}
