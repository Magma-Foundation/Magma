export class JavaTypescriptParser {
	private static parseUnit( unit : Unit<JavaLang.Root>) : CompileResult<Unit<TypescriptLang.TypescriptRoot>> {return unit.destruct( JavaTypescriptParser.parseRoot);;}
	private static parseRoot( location : Location,  root : JavaLang.Root) : CompileResult<Unit<TypescriptLang.TypescriptRoot>> { let rootSegments : var=root.children( ).iter( ).map( 0).flatMap( List.iter).collect( new ListCollector<>( ));return CompileResults.Ok( new SimpleUnit<>( location, new TypescriptLang.TypescriptRoot( rootSegments)));;}
	private static parseRootSegment( location : Location,  rootSegment : JavaRootSegment) : List<TypescriptLang.TypeScriptRootSegment> {return 0;;}
	private static getCollect( structure : JavaLang.Structure) : List<TypescriptLang.TypeScriptRootSegment> {return JavaTypescriptParser.parseStructure( structure).iter( ).map( JavaTypescriptParser.wrap).collect( new ListCollector<>( ));;}
	private static wrap( value : TypescriptLang.StructureNode) : TypescriptLang.TypeScriptRootSegment {return value;;}
	private static parseStructure( structure : JavaLang.Structure) : List<TypescriptLang.StructureNode> {return 0;;}
	private static parseStructureWithType( type : TypescriptLang.StructureType,  structure : JavaLang.Structure) : List<TypescriptLang.StructureNode> { let value : var=structure.value; let membersTuple : var=value.members( ).iter( ).map( JavaTypescriptParser.parseStructureMember).collect( new TupleCollector<>( new ListCollector<>( ), new ListCollector<>( ))); let members : var=membersTuple.left( ).iter( ).flatMap( List.iter).collect( new ListCollector<>( )); let structures : var=membersTuple.right( ).iter( ).flatMap( List.iter).collect( new ListCollector<>( )); let structureNode1 : var=new StructureValue<TypescriptLang.Type, TypescriptLang.TypescriptStructureMember>( value.name( ), value.modifiers( ), members, value.maybeTypeParams( ), value.maybeExtended( ).map( JavaTypescriptParser.parseTypeList), value.maybeImplemented( ).map( JavaTypescriptParser.parseTypeList));return structures.addLast( new TypescriptLang.StructureNode( type, structureNode1));;}
	private static parseTypeList( list : List<JavaLang.JavaType>) : List<TypescriptLang.Type> {return list.iter( ).map( JavaTypescriptParser.parseType).collect( new ListCollector<>( ));;}
	private static parseStructureMember( structureNode : JavaStructureMember) : Tuple2<List<TypescriptLang.TypescriptStructureMember>, List<TypescriptLang.StructureNode>> {return 0;;}
	private static getListListTuple2( typescriptStructureMember : TypescriptLang.TypescriptStructureMember) : Tuple2<List<TypescriptLang.TypescriptStructureMember>, List<TypescriptLang.StructureNode>> {return new Tuple2<>( Lists.of( typescriptStructureMember), Lists.empty( ));;}
	private static getList() : Tuple2<List<TypescriptLang.TypescriptStructureMember>, List<TypescriptLang.StructureNode>> {return JavaTypescriptParser.getListListTuple2( new TypescriptLang.Whitespace( ));;}
	private static parseMethod( methodNode : JavaMethod) : TypescriptLang.TypescriptStructureMember { let parameters : var=methodNode.parameters( ).iter( ).map( JavaTypescriptParser.parseParameter).collect( new ListCollector<>( )); let header : var=JavaTypescriptParser.parseMethodHeader( methodNode.header( )); let parameterizedHeader : var=new ParameterizedMethodHeader<TypescriptLang.TypeScriptParameter>( header, parameters);return new TypescriptLang.TypescriptMethod( parameterizedHeader, methodNode.maybeChildren( ).map( JavaTypescriptParser.parseFunctionSegments));;}
	private static parseFunctionSegments( segments : List<JavaFunctionSegment>) : List<TypescriptLang.FunctionSegment> {return segments.iter( ).map( JavaTypescriptParser.parseFunctionSegment).collect( new ListCollector<>( ));;}
	private static parseFunctionSegment( segment : JavaFunctionSegment) : TypescriptLang.FunctionSegment {return 0;;}
	private static parseFunctionStatement( functionStatement : JavaLang.FunctionStatement) : TypescriptLang.FunctionSegment { let oldValue : var=JavaTypescriptParser.parseFunctionStatementValue( functionStatement.child( )); let newValue : var=JavaTypescriptParser.getOldValue( oldValue);return new FunctionStatement( newValue);;}
	private static getOldValue( oldValue : TypescriptLang.FunctionSegment.Value) : TypescriptLang.FunctionSegment.Value {if(true){ if(true){  let newDefinition : var=oldDefinition.withModifier( new Modifier( "let"));return new TypescriptLang.Assignment( newDefinition, value);;};}return oldValue;;}
	private static parseFunctionStatementValue( child : JavaFunctionSegmentValue) : TypescriptLang.FunctionSegment.Value {return 0;;}
	private static parseAssignable( assignable : JavaLang.Assignable) : TypescriptLang.Assignable {return 0;;}
	private static parseInvokable( invokable : JavaLang.Invokable) : TypescriptLang.Invokable {return new TypescriptLang.Invokable( JavaTypescriptParser.parseCaller( invokable.caller( )), JavaTypescriptParser.parseArguments( invokable.arguments( )));;}
	private static parseCaller( caller : JavaLang.JavaCaller) : Caller {return 0;;}
	private static parseArguments( arguments : List<JavaLang.JavaArgument>) : List<TypescriptLang.Argument> {return arguments.iter( ).map( JavaTypescriptParser.parseArgument).collect( new ListCollector<>( ));;}
	private static parseArgument( argument : JavaLang.JavaArgument) : TypescriptLang.Argument {return 0;;}
	private static parseValue( child : JavaLang.Value) : TypescriptLang.Value {return 0;;}
	private static parseAccess( access : JavaLang.Access) : TypescriptLang.Access {return new TypescriptLang.Access( JavaTypescriptParser.parseValue( access.receiver( )), access.property( ));;}
	private static parseIndex( index : JavaLang.Index) : TypescriptLang.Index {return new TypescriptLang.Index( JavaTypescriptParser.parseValue( index.parent( )), JavaTypescriptParser.parseValue( index.argument( )));;}
	private static parseOperation( operation : JavaLang.operation) : TypescriptLang.Operation {return new TypescriptLang.Operation( JavaTypescriptParser.parseValue( operation.left( )), operation.operator( ), JavaTypescriptParser.parseValue( operation.right( )));;}
	private static parseBlock( block : JavaLang.Block) : TypescriptLang.Block {return new TypescriptLang.Block( JavaTypescriptParser.parseHeader( block.header( )), JavaTypescriptParser.parseFunctionSegments( block.segments( )));;}
	private static parseHeader( header : JavaLang.BlockHeader) : TypescriptLang.TypescriptBlockHeader {return new TypescriptLang.TypescriptConditional( ConditionalType.If, new Symbol( "true"));;}
	private static parseParameter( parameter : JavaParameter) : TypescriptLang.TypeScriptParameter {return 0;;}
	private static parseMethodHeader( header : JavaMethodHeader) : TypescriptLang.TypeScriptMethodHeader {return 0;;}
	private static parseDefinition( definition : JavaLang.Definition) : TypescriptLang.Definition { let maybeAnnotations : var=definition.maybeAnnotations( ); let maybeModifiers : var=definition.modifiers( ); let maybeTypeParameters : var=definition.maybeTypeParams( ); let type : var=definition.type( ); let oldName : var=definition.name( );if(true){  let newType : var=new TypescriptLang.ArrayType( JavaTypescriptParser.parseType( child)); let name : var="..."+oldName;return new TypescriptLang.Definition( maybeAnnotations, maybeModifiers, name, maybeTypeParameters, newType);;}if(true){ return new TypescriptLang.Definition( maybeAnnotations, maybeModifiers, oldName, maybeTypeParameters, JavaTypescriptParser.parseType( definition.type( )));;};}
	private static parseSymbol( symbol : JavaLang.Symbol) : Symbol {return new Symbol( symbol.value( ));;}
	private static parseQualifiedType( qualified : JavaLang.Qualified) : Symbol { let joined : var=qualified.segments( ).iter( ).map( Segment.value).collect( new Joiner( ".")).orElse( "");return new Symbol( joined);;}
	private static parseArrayType( type : JavaLang.JavaArrayType) : TypescriptLang.Type {return new TypescriptLang.ArrayType( JavaTypescriptParser.parseType( type.inner));;}
	private static parseType( variadicType : JavaLang.JavaType) : TypescriptLang.Type {return 0;;}
	private static parseTemplateType( type : JavaLang.JavaTemplateType) : TypescriptLang.TemplateType { let base : var=JavaTypescriptParser.parseBaseType( type.base( )); let listOption : var=type.typeArguments( ).map( JavaTypescriptParser.parseTypeList);return new TypescriptLang.TemplateType( base, listOption);;}
	private static parseBaseType( base : JavaLang.Base) : JavaLang.Symbol {return 0;;}
	private static parseNamespaced( location : Location,  namespaced : JavaNamespacedNode) : TypescriptLang.TypeScriptRootSegment {return new TypescriptLang.Whitespace( );;}
	private static parseImport( location : Location,  segments : List<Segment>) : TypescriptLang.TypeScriptImport { let segmentValues : var=segments.iter( ).map( Segment.value).collect( new ListCollector<>( )); let before : var=location.namespace( ).iter( ).map( 0).map( Segment.new).collect( new ListCollector<>( )); let last : var=new Segment( segmentValues.findLast( ).orElse( ""));return new TypescriptLang.TypeScriptImport( Lists.of( last), before.addAllLast( segments));;}
	private static attachNamespace( location : Location,  tuple : Tuple2<List<String>, String>) : Tuple2<List<String>, String> { let namespace : var=location.namespace( ).addAllLast( tuple.left( ));return new Tuple2<>( namespace, tuple.right( ));;}
	private static findStructuresInRootSegment( child : JavaRootSegment) : List<Tuple2<List<String>, String>> {if(true){ return JavaTypescriptParser.findStructuresInNode( Lists.empty( ), structure);;}return Lists.empty( );;}
	private static findStructuresWithLocation( location : Location,  root : JavaLang.Root) : Iter<Tuple2<List<String>, String>> {return root.children( ).iter( ).map( JavaTypescriptParser.findStructuresInRootSegment).flatMap( List.iter).map( 0);;}
	private static findStructuresInMember( namespace : List<String>,  member : JavaStructureMember) : List<Tuple2<List<String>, String>> {if(true){ return JavaTypescriptParser.findStructuresInNode( namespace, structure);;}return Lists.empty( );;}
	private static findStructuresInNode( namespace : List<String>,  structure : JavaLang.Structure) : List<Tuple2<List<String>, String>> { let name : var=structure.name( ); let collect : var=structure.value.members( ).iter( ).map( 0).flatMap( List.iter).collect( new ListCollector<>( )); let entry : var=new Tuple2<List<String>, String>( namespace, name);return collect.addLast( entry);;}
	public apply( set : UnitSet<JavaLang.Root>) : CompileResult<UnitSet<TypescriptLang.TypescriptRoot>> { let collect : var=set.iter( ).flatMap( 0).collect( new ListCollector<>( ));return set.iter( ).map( JavaTypescriptParser.parseUnit).collect( new CompileResultCollector<>( new UnitSetCollector<>( )));;}
}
