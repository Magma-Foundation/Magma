import magma.compile.Error_;
import magma.compile.lang.ClassSplitter;
import magma.compile.lang.Generator;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaNormalizer;
import magma.compile.lang.MagmaFormatter;
import magma.compile.lang.MagmaGenerator;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.PackageRemover;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
export def Main() => {
	export def main() => {
		try {
			let source = Paths.get(".", "magmac", "src", "magma", "Main.java");
			let input = Files.readString(source);
			let target = source.resolveSibling("Main.mgs");
			let parseResult = JavaLang.createRootRule().toNode(input);
			let parseError = parseResult.findError();
			parseError.ifPresent();
			let root = parseResult.create().orElseThrow();
			Files.writeString(source.resolveSibling("Main.input.ast"), root.toString());
			let generated = generate(root);
			Files.writeString(source.resolveSibling("Main.output.ast"), generated.toString());
			let rule = MagmaLang.createRootRule();
			let generateResult = rule.fromNode(generated);
			let generateError = generateResult.findErr();
			generateError.ifPresent();
			Files.writeString(target, generateResult.findValue().orElseThrow());
		}
		catch (let e){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
	}
	def print() => {
		let actualContext = e.findContext().orElse("");
		let index = actualContext.indexOf();
		let context = ? == ??actualContext:actualContext.substring();
		let message = e.findMessage();
		message.ifPresent();
		let causes = e.findCauses().orElse(Collections.emptyList());
		if (?){
			return 
		}
		if (?){
			for (?){
				print(cause, depth);
			}
		}
		else {
			print();
		}
	}
	def generate() => {
		let list = Arrays.asList();
		let acc = root;
		for (?){
			? = ?
		}
		return 
	}
}