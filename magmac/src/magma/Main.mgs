
import magma.compile.Error_;
import magma.compile.lang.ClassSplitter;
import magma.compile.lang.Generator;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaNormalizer;
import magma.compile.lang.MagmaFormatter;
import magma.compile.lang.MagmaGenerator;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.PackageRemover;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
export class def Main() => {
	public def main(args : String[]) : void => {
		try 
		{
			let source=Paths.get(".", "magmac", "src", "magma", "Main.java");
			let input=Files.readString(source);
			let target=source.resolveSibling("Main.mgs");
			let parseResult=JavaLang.createRootRule().toNode(input);
			let parseError=parseResult.findError();
			parseError.ifPresent();
			let root=parseResult.create().orElseThrow();
			Files.writeString(source.resolveSibling("Main.input.ast"), root.toString());
			let generated=generate(root);
			Files.writeString(source.resolveSibling("Main.output.ast"), generated.toString());
			let rule : Rule=MagmaLang.createRootRule();
			let generateResult=rule.fromNode(generated);
			let generateError=generateResult.findErr();
			generateError.ifPresent();
			Files.writeString(target, generateResult.findValue().orElseThrow());}
		catch (let e : IOException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();}}
	def print(e : Error_, depth : int) : void => {
		let actualContext=e.findContext().orElse("");
		let index=actualContext.indexOf();
		let context=index==-1?actualContext:actualContext.substring(0, index);
		let message=e.findMessage();
		message.ifPresent();
		let causes=e.findCauses().orElse(Collections.emptyList());
		if
		(causes.isEmpty()){
			return
			;}
		if
		(causes.size()>1){
			for
			(
			cause : Error_ in 
			causes){
				print(cause, depth);}}
		else
		{
			print(causes.get(0), depth+1);}}
	def generate(root : Node) : Node => {
		let list=Arrays.asList();
		let acc : Node=root;
		for
		(
		generator : Generator in 
		list){
			
			acc=
			generator.generate(acc, -1);}
		return
		;}}