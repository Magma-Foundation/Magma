
import magma.compile.Error_;
import magma.compile.lang.ClassSplitter;
import magma.compile.lang.Generator;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaNormalizer;
import magma.compile.lang.MagmaFormatter;
import magma.compile.lang.MagmaGenerator;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.PackageRemover;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
export class def Main() => {
	public static main(args : String[]) : void => {
		try 
		{
			
			
			let source=Paths.get();
			
			
			let input=Files.readString();
			
			
			let target=source.resolveSibling();
			
			
			let parseResult=JavaLang.createRootRule().toNode();
			
			
			let parseError=parseResult.findError();
			parseError.ifPresent()
			
			
			let root=parseResult.create().orElseThrow();
			Files.writeString()
			
			
			let generated=generate();
			Files.writeString()
			
			
			let rule : Rule=MagmaLang.createRootRule();
			
			
			let generateResult=rule.fromNode();
			
			
			let generateError=generateResult.findErr();
			generateError.ifPresent()
			Files.writeString()}
		catch (let e : IOException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace()}}
	private static print(e : Error_, depth : int) : void => {
		
		
		let actualContext=e.findContext().orElse();
		
		
		let index=actualContext.indexOf();
		
		
		let context=index==-1?actualContext:actualContext.substring();
		
		
		let message=e.findMessage();
		message.ifPresent()
		
		
		let causes=e.findCauses().orElse();
		if
		(causes.isEmpty()){
			return
			;}
		if
		(causes.size()>1){
			for
			(
			cause : Error_ in 
			causes){
				print()}}
		else
		{
			print()}}
	private static generate(root : Node) : Node => {
		
		
		let list=Arrays.asList();
		
		
		let acc : Node=root;
		for
		(
		generator : Generator in 
		list){
			
			acc=
			generator.generate();}
		return
		;}}