import magma.compile.Error_;
import magma.compile.lang.ClassSplitter;
import magma.compile.lang.Generator;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaNormalizer;
import magma.compile.lang.MagmaFormatter;
import magma.compile.lang.MagmaGenerator;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.PackageRemover;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
export def Main() => {
	export def main() => {
		try {
			let source : var = Paths.get(".", "magmac", "src", "magma", "Main.java");
			let input : var = Files.readString(source);
			let target : var = source.resolveSibling("Main.mgs");
			let parseResult : var = JavaLang.createRootRule().toNode(input);
			let parseError : var = parseResult.findError();
			parseError.ifPresent();
			let root : var = parseResult.create().orElseThrow();
			Files.writeString(source.resolveSibling("Main.input.ast"), root.toString());
			let generated : var = generate(root);
			Files.writeString(source.resolveSibling("Main.output.ast"), generated.toString());
			let rule : Rule = MagmaLang.createRootRule();
			let generateResult : var = rule.fromNode(generated);
			let generateError : var = generateResult.findErr();
			generateError.ifPresent();
			Files.writeString(target, generateResult.findValue().orElseThrow());
		}
		catch (let e : IOException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
	}
	def print() => {
		let actualContext : var = e.findContext().orElse("");
		let index : var = actualContext.indexOf();
		let context : var = ? == ??actualContext:actualContext.substring();
		let message : var = e.findMessage();
		message.ifPresent();
		let causes : var = e.findCauses().orElse(Collections.emptyList());
		if (?){
			return 
		}
		if (?){
			for (?){
				print(cause, depth);
			}
		}
		else {
			print();
		}
	}
	def generate() => {
		let list : var = Arrays.asList();
		let acc : Node = root;
		for (?){
			? = ?
		}
		return 
	}
}