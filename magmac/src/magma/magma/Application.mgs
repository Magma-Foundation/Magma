import magma.api.Tuple;import magma.api.collect.Map;import magma.api.collect.stream.Collectors;import magma.api.collect.stream.Streams;import magma.api.option.None;import magma.api.option.Option;import magma.api.option.Some;import magma.api.result.Err;import magma.api.result.Ok;import magma.api.result.Result;import magma.compile.CompileException;import magma.compile.Error_;import magma.compile.annotate.State;import magma.compile.lang.Generator;import magma.compile.lang.JavaLang;import magma.compile.lang.MagmaLang;import magma.compile.lang.VisitingGenerator;import magma.compile.lang.Visitor;import magma.compile.lang.java.ClassNormalizer;import magma.compile.lang.java.ConstructorNormalizer;import magma.compile.lang.java.FilteringVisitor;import magma.compile.lang.java.InterfaceNormalizer;import magma.compile.lang.java.LambdaNormalizer;import magma.compile.lang.java.MethodNormalizer;import magma.compile.lang.java.MethodReferenceNormalizer;import magma.compile.lang.java.PackageRemover;import magma.compile.lang.java.RecordNormalizer;import magma.compile.rule.Node;import magma.compile.rule.Rule;import magma.java.JavaList;import magma.java.JavaMap;import magma.java.JavaSet;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.stream.Stream;import static magma.java.JavaResults.$;import static magma.java.JavaResults.$Option;import static magma.java.JavaResults.$Result;import static magma.java.JavaResults.$Void;() => {static createDirectory : Option<CompileException> => {try {Files.createDirectories(targetParent);return None();}catch (e : IOException){return Some(CompileException("Failed to make parent.", e));}}static print : String => {context : var=formatContext(error, depth);anyMessage : var=error.findMessage();anyMessage.ifPresent(() => System.err.println(" ".repeat(depth)+depth+" = "+s+" "+context));message : var=error.findMessage().orElse("");replaced : var=escape(message);messageAttribute : var=message.isEmpty()?"":" message=\"" + replaced + "\"";causes : var=error.findCauses().orElse(Collections.emptyList());escapedContext : var=escape(error.findContext().orElse(""));formattedContext : var="\n"+"\t".repeat(depth)+escapedContext;if(causes.isEmpty()){return "\n" + "\t".repeat(depth) + "<child" + messageAttribute + ">" + formattedContext + "</child>";}contextAttribute : var=escapedContext.isEmpty()?"":" context=\"" + escapedContext + "\"";if(causes.size()==1){return "\n" + "\t".repeat(depth) + "<parent" + messageAttribute + contextAttribute + ">" + print(causes.get(0), depth + 1) + "</parent>";}list : var=causes.stream().sorted(Comparator.comparingInt(Error_.calculateDepth)).toList();builder : var=StringBuilder();for(cause : var in list){result : var=print(cause, depth+1);builder.append(result);}return "\n" + "\t".repeat(depth) + "<collection" + messageAttribute + contextAttribute + ">" + builder + "</collection>";}private static escape : String => {return value.replace("&", "&amp;").replace("\"", "&quot;").replace("<", "&lt;").replace(">", "&gt;").replace("'", "&apos;").replace("\\", "\\\\").replace("\n", "\\n").replace("\t", "\\t").replace("\r", "\\r");}private static formatContext : String => {actualContext : var=e.findContext().orElse("");if(e.findCauses().isPresent())return actualContext;spacing : var=" ".repeat(depth+1);formatted : var=actualContext.replace("\n", "\n" + " ".repeat(depth==0?0:depth-1));return "\n" + spacing + "---\n" + spacing + formatted + "\n" + spacing + "---";}static writeSafely : Option<CompileException> => {try {Files.writeString(target, csq);return None();}catch (e : IOException){return Some(CompileException("Cannot write.", e));}}private static streamVisitors : Stream<Visitor> => {return Stream.of(FilteringVisitor("block", PackageRemover()), FilteringVisitor("record", RecordNormalizer()), FilteringVisitor("interface", InterfaceNormalizer()), FilteringVisitor("class", ClassNormalizer()), FilteringVisitor("method", MethodNormalizer()), FilteringVisitor("constructor", ConstructorNormalizer()), FilteringVisitor("lambda", LambdaNormalizer()), FilteringVisitor("method-reference", MethodReferenceNormalizer()));}private static findRootRule : Result<Rule, CompileException> => {if(platform.equals("java")){return Ok(JavaLang.createRootRule());}if(platform.equals("mgs")){return Ok(MagmaLang.createRootRule());}return Err(CompileException("Unknown platform: "+platform));}run : Option<CompileException> => {return config.streamBuilds().map(this.compile).flatMap(Streams.fromOption).head();}private compile : Option<CompileException> => {return $Void(() => {sources : var=$Result(findSources(build.sourceDirectory()).mapErr(CompileException.new));sourceTrees : var=$Result(parseSources(build, sources));targetTrees : var=$Result(generateTargets(build, sourceTrees));$Option(writeTargets(build, targetTrees));});}findSources : Result<List<Path>, IOException> => {return $(() => {//noinspection resourcereturn Files.walk(buildSet.location()).filter(() => value.toString().endsWith("."+buildSet.platform())).filter(Files.isRegularFile).toList();});}generateTargets : Result<Map<Unit, Node>, CompileException> => {return sourceTrees.streamEntries().map(() => generateTarget(build, sourceTrees, entry)).collect(Collectors.exceptionally(JavaMap.collecting()));}generateTarget : Result<Tuple<Unit, Node>, CompileException> => {return $(() => {source : var=entry.left();right : var=entry.right();namespace : var=source.computeNamespace();name : var=source.computeName();System.out.println("Generating target: "+String.join(".", namespace)+"."+name);generated : var=$Result(CompoundGenerator(streamVisitors().map(VisitingGenerator.new).toList()).generate(right, State(sourceTrees.keyStream().collect(JavaSet.collecting()), JavaList())).mapValue(Tuple.left).mapErr(() => writeError(build, error, source)));debug : var=$Result(createDebugDirectory(build, namespace));debugTarget : var=debug.resolve(name+".output.ast");$Option(writeSafely(debugTarget, generated.toString()));return Tuple(source, generated);});}writeTargets : Option<CompileException> => {return targetTrees.streamEntries().map(() => writeTarget(build, entry.left(), entry.right())).flatMap(Streams.fromOption).head();}writeTarget : Option<CompileException> => {namespace : var=source.computeNamespace();name : var=source.computeName();System.out.println("Writing target: "+String.join(".", namespace)+"."+name);targetSet : var=build.targetDirectory();targetParent : var=targetSet.location();for(segment : String in namespace){targetParent=targetParent.resolve(segment);}if(!Files.exists(targetParent)){result : var=createDirectory(targetParent);if(result.isPresent()){return result;}}target : var=targetParent.resolve(name+"."+targetSet.platform());return findRootRule(targetSet.platform()).mapValue(() => rootRule.fromNode(root).match(() => writeSafely(target, value), () => {print(err, 0);return Some(writeError(build, err, source));})).match(() => inner, Some.new);}parseSources : Result<Map<Unit, Node>, CompileException> => {return JavaList(Collectors.exceptionally(JavaMap.collecting()));}parseSource : Option<Result<Tuple<Unit, Node>, CompileException>> => {namespace : var=source.computeNamespace();if(namespace.size()>=2){slice : var=namespace.subList(0, 2);// Essentially, we want to skip this package.if(slice.equals(List.of("magma", "java"))){return None();}}System.out.println("Parsing source: "+source);return Some(source.read().mapValue(() => parseWithInput(build, source, input)).match(() => result, Err.new).mapValue(() => Tuple(source, value)));}private parseWithInput : Result<Node, CompileException> => {return $(() => {s : var=$Result(findRootRule(build.sourceDirectory().platform()));return $Result(s.toNode(input).create().match(() => parse(build, source, root), () => Err(writeError(build, err, source))));});}parse : Result<Node, CompileException> => {return createDebugDirectory(build, unit.computeNamespace()).flatMapValue(() => writeSafely(relativizedDebug.resolve(unit.computeName()+".input.ast"), root.toString()).map(Err.new).orElseGet(() => Ok(root)));}writeError : CompileException => {result : var=print(err, 0);return $Void(() => {debugDirectory : var=$Result(createDebugDirectory(build, Collections.emptyList()));errorPath : var=debugDirectory.resolve("error.xml");$Option(writeSafely(errorPath, result));}).orElseGet(() => CompileException(location.toString()));}createDebugDirectory : Result<Path, CompileException> => {relativizedDebug : var=build.debugDirectory();for(s : String in namespace){relativizedDebug=relativizedDebug.resolve(s);}if(!Files.exists(relativizedDebug)){directoryError : var=createDirectory(relativizedDebug);if(directoryError.isPresent()){return Err(directoryError.orElsePanic());}}return Ok(relativizedDebug);}}