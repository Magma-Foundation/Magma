import magma.api.Tuple;
import magma.api.collect.Map;
import magma.api.collect.stream.ExceptionalCollector;
import magma.api.collect.stream.Stream;
import magma.api.collect.stream.Streams;
import magma.api.option.None;
import magma.api.option.Option;
import magma.api.option.Some;
import magma.api.result.Err;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.CompileException;
import magma.compile.Error_;
import magma.compile.annotate.ImmutableState;
import magma.compile.lang.CompoundVisitor;
import magma.compile.lang.JavaLang;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.VisitingGenerator;
import magma.compile.lang.Visitor;
import magma.compile.lang.java.ClassNormalizer;
import magma.compile.lang.java.ConstructorNormalizer;
import magma.compile.lang.java.FilteringVisitor;
import magma.compile.lang.java.InterfaceNormalizer;
import magma.compile.lang.java.LambdaNormalizer;
import magma.compile.lang.java.MethodNormalizer;
import magma.compile.lang.java.MethodReferenceNormalizer;
import magma.compile.lang.java.PackageRemover;
import magma.compile.lang.java.RecordNormalizer;
import magma.compile.lang.magma.BlockFormatter;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import magma.java.JavaList;
import magma.java.JavaMap;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import static magma.java.JavaResults.$;
import static magma.java.JavaResults.$Option;
import static magma.java.JavaResults.$Result;
import static magma.java.JavaResults.$Void;
() => {
	static createDirectory(targetParent : Path) : Option<CompileException> => {
		try 
		{
			Files.createDirectories(targetParent);
			return None.None();
		}
		catch (e : IOException){
			return Some(CompileException("Failed to make parent.", e));
		}
	}
	static print(error : Error_, depth : int) : String => {
		
		context : var=
		
		formatContext(error, depth);
		
		anyMessage : var=
		
		error.findMessage();
		anyMessage.ifPresent(() => System.err.println(" ".repeat(depth)+depth+" = "+s+" "+context));
		
		message : var=
		
		error.findMessage().orElse("");
		
		replaced : var=
		
		escape(message);
		
		messageAttribute : var=
		
		message.isEmpty()?"":" message=\"" + replaced + "\"";
		
		causes : var=
		
		error.findCauses().orElse(Collections.emptyList());
		
		escapedContext : var=
		
		escape(error.findContext().orElse(""));
		
		formattedContext : var=
		
		"\n"+"\t".repeat(depth)+escapedContext;
		if
		(causes.isEmpty())
		{
			return "\n" + "\t".repeat(depth) + "<child" + messageAttribute + ">" + formattedContext + "</child>";
		}
		
		contextAttribute : var=
		
		escapedContext.isEmpty()?"":" context=\"" + escapedContext + "\"";
		if
		(causes.size()==1)
		{
			return "\n" + "\t".repeat(depth) + "<parent" + messageAttribute + contextAttribute + ">" + print(causes.get(0), depth + 1) + "</parent>";
		}
		
		list : var=
		
		causes.stream().sorted(Comparator.comparingInt(Error_.calculateDepth)).toList();
		
		builder : var=
		
		StringBuilder();
		for(cause : var in list){
			
			result : var=
			
			print(cause, depth+1);
			builder.append(result);
		}
		return "\n" + "\t".repeat(depth) + "<collection" + messageAttribute + contextAttribute + ">" + builder + "</collection>";
	}
	private static escape(value : String) : String => {
		return value.replace("&", "&amp;").replace("\"", "&quot;").replace("<", "&lt;").replace(">", "&gt;").replace("'", "&apos;").replace("\\", "\\\\").replace("\n", "\\n").replace("\t", "\\t").replace("\r", "\\r");
	}
	private static formatContext(e : Error_, depth : int) : String => {
		
		actualContext : var=
		
		e.findContext().orElse("");
		if
		(e.findCauses().isPresent())
		return actualContext;
		
		spacing : var=
		
		" ".repeat(depth+1);
		
		formatted : var=
		
		actualContext.replace("\n", "\n" + " ".repeat(depth==0?0:depth-1));
		return "\n" + spacing + "---\n" + spacing + formatted + "\n" + spacing + "---";
	}
	static writeSafely(target : Path, csq : String) : Option<CompileException> => {
		try 
		{
			Files.writeString(target, csq);
			return None.None();
		}
		catch (e : IOException){
			return Some(CompileException("Cannot write.", e));
		}
	}
	private static streamVisitors0() : Stream<Visitor> => {
		return Streams.fromNativeList(List.of(FilteringVisitor("block", PackageRemover()), FilteringVisitor("record", RecordNormalizer()), FilteringVisitor("interface", InterfaceNormalizer()), FilteringVisitor("class", ClassNormalizer()), FilteringVisitor("method", MethodNormalizer()), FilteringVisitor("constructor", ConstructorNormalizer()), FilteringVisitor("lambda", LambdaNormalizer()), FilteringVisitor("method-reference", MethodReferenceNormalizer())));
	}
	private static findRootRule(platform : String) : Result<Rule, CompileException> => {
		if
		(platform.equals("java"))
		{
			return Ok(JavaLang.createRootRule());
		}
		if
		(platform.equals("mgs"))
		{
			return Ok(MagmaLang.createRootRule());
		}
		return Err(CompileException("Unknown platform: "+platform));
	}
	run() : Option<CompileException> => {
		return config.streamBuilds().map(this.compile).flatMap(Streams.fromOption).head();
	}
	private compile(build : Build) : Option<CompileException> => {
		return $Void(() => {
			
			sources : var=
			
			$Result(findSources(build.sourceDirectory()).mapErr(CompileException.new));
			
			sourceTrees : var=
			
			$Result(parseSources(build, sources));
			
			targetTrees : var=
			
			$Result(generateTargets(build, sourceTrees));
			$Option(writeTargets(build, targetTrees));
		});
	}
	findSources(buildSet : BuildSet) : Result<List<Path>, IOException> => {
		return $(() => {
			//noinspection resource
			return Files.walk(buildSet.location()).filter(() => value.toString().endsWith("."+buildSet.platform())).filter(Files.isRegularFile).toList();
		});
	}
	generateTargets(build : Build, sourceTrees : Map<Unit, Node>) : Result<Map<Unit, Node>, CompileException> => {
		return sourceTrees.streamEntries().map(() => generateTarget(build, sourceTrees, entry)).collect(ExceptionalCollector(JavaMap.collecting()));
	}
	generateTarget(build : Build, sourceTrees : Map<Unit, Node>, entry : Tuple<Unit, Node>) : Result<Tuple<Unit, Node>, CompileException> => {
		return $(() => {
			
			source : var=
			
			entry.left();
			
			right : var=
			
			entry.right();
			
			namespace : var=
			
			source.computeNamespace();
			
			name : var=
			
			source.computeName();
			System.out.println("Generating target: "+String.join(".", namespace)+"."+name);
			
			rootGenerator : var=
			
			CompoundGenerator(List.of(VisitingGenerator(CompoundVisitor(streamVisitors0().collect(JavaList.collecting()))), VisitingGenerator(CompoundVisitor(streamVisitors1().collect(JavaList.collecting())))));
			
			generated : var=
			
			$Result(rootGenerator.generate(right, ImmutableState()).mapValue(Tuple.left).mapErr(() => writeError(build, error, source)));
			
			debug : var=
			
			$Result(createDebugDirectory(build, namespace));
			
			debugTarget : var=
			
			debug.resolve(name+".output.ast");
			$Option(writeSafely(debugTarget, generated.toString()));
			return Tuple(source, generated);
		});
	}
	private streamVisitors1() : Stream<Visitor> => {
		return Streams.of(FilteringVisitor("block", BlockFormatter()));
	}
	writeTargets(build : Build, targetTrees : Map<Unit, Node>) : Option<CompileException> => {
		return targetTrees.streamEntries().map(() => writeTarget(build, entry.left(), entry.right())).flatMap(Streams.fromOption).head();
	}
	writeTarget(build : Build, source : Unit, root : Node) : Option<CompileException> => {
		
		namespace : var=
		
		source.computeNamespace();
		
		name : var=
		
		source.computeName();
		System.out.println("Writing target: "+String.join(".", namespace)+"."+name);
		
		targetSet : var=
		
		build.targetDirectory();
		
		targetParent : var=
		
		targetSet.location();
		for(segment : String in namespace){
			targetParent=targetParent.resolve(segment);
		}
		if
		(!Files.exists(targetParent))
		{
			
			result : var=
			
			createDirectory(targetParent);
			if
			(result.isPresent())
			{
				return result;
			}
		}
		
		target : var=
		
		targetParent.resolve(name+"."+targetSet.platform());
		return findRootRule(targetSet.platform()).mapValue(() => rootRule.fromNode(root).match(() => writeSafely(target, value), () => {
			print(err, 0);
			return Some(writeError(build, err, source));
		})).match(() => inner, Some.new);
	}
	parseSources(build : Build, sources : List<Path>) : Result<Map<Unit, Node>, CompileException> => {
		return JavaList(ExceptionalCollector(JavaMap.collecting()));
	}
	parseSource(build : Build, source : Unit) : Option<Result<Tuple<Unit, Node>, CompileException>> => {
		
		namespace : var=
		
		source.computeNamespace();
		if
		(namespace.size()>=2)
		{
			
			slice : var=
			
			namespace.subList(0, 2);
			// Essentially, we want to skip this package.
			if
			(slice.equals(List.of("magma", "java"))||slice.equals(List.of("magma", "lang")))
			{
				return None.None();
			}
		}
		System.out.println("Parsing source: "+source);
		return Some(source.read().mapValue(() => parseWithInput(build, source, input)).match(() => result, Err.new).mapValue(() => Tuple(source, value)));
	}
	private parseWithInput(build : Build, source : Unit, input : String) : Result<Node, CompileException> => {
		return $(() => {
			
			s : var=
			
			$Result(findRootRule(build.sourceDirectory().platform()));
			return $Result(s.toNode(input).create().match(() => parse(build, source, root), () => Err(writeError(build, err, source))));
		});
	}
	parse(build : Build, unit : Unit, root : Node) : Result<Node, CompileException> => {
		return createDebugDirectory(build, unit.computeNamespace()).flatMapValue(() => writeSafely(relativizedDebug.resolve(unit.computeName()+".input.ast"), root.toString()).map(Err.new).orElseGet(() => Ok(root)));
	}
	writeError(build : Build, err : Error_, location : Unit) : CompileException => {
		
		result : var=
		
		print(err, 0);
		return $Void(() => {
			
			debugDirectory : var=
			
			$Result(createDebugDirectory(build, Collections.emptyList()));
			
			errorPath : var=
			
			debugDirectory.resolve("error.xml");
			$Option(writeSafely(errorPath, result));
		}).orElseGet(() => CompileException(location.toString()));
	}
	createDebugDirectory(build : Build, namespace : List<String>) : Result<Path, CompileException> => {
		
		relativizedDebug : var=
		
		build.debugDirectory();
		for(s : String in namespace){
			relativizedDebug=relativizedDebug.resolve(s);
		}
		if
		(!Files.exists(relativizedDebug))
		{
			
			directoryError : var=
			
			createDirectory(relativizedDebug);
			if
			(directoryError.isPresent())
			{
				return Err(directoryError.orElsePanic());
			}
		}
		return Ok(relativizedDebug);
	}
}