
			import magma.api.option.Option;
			import magma.api.option.Some;
			import magma.api.result.Ok;
			import magma.api.result.Result;
			import java.util.Optional;
			export class def Collectors() => {
				public static def joining(this) : Collector<String, Optional<String>> => {
					return joining("");
				}
				public static def joining(this, final delimiter : String) : Collector<String, Optional<String>> => {
					return Collector((() => {
						return {
							public def createInitial(this) : Optional<String> => {
								return Optional.empty();
							}
							public def fold(this, current : Optional<String>, next : String) : Optional<String> => {
								return current.isEmpty()?Optional.of(next):current.map(() => inner+delimiter+next);
							}
						};
					})())();
					
					;
				}
				public static def exceptionally<T, C, E>(this, collector : Collector<T, C>) : Collector<Result<T, E>, Result<C, E>> => {
					return Collector((() => {
						return {
							public def createInitial(this) : Result<C, E> => {
								return Ok(collector.createInitial());
							}
							public def fold(this, current : Result<C, E>, next : Result<T, E>) : Result<C, E> => {
								return current.flatMapValue(() => next.mapValue(() => collector.fold(inner, inner0)));
							}
						};
					})())();
					
					;
				}
				public static def required<T, C>(this, collector : Collector<T, C>) : Collector<Option<T>, Option<C>> => {
					return Collector((() => {
						return {
							public def createInitial(this) : Option<C> => {
								return Some(collector.createInitial());
							}
							public def fold(this, current : Option<C>, next : Option<T>) : Option<C> => {
								return current.and(next).map(() => collector.fold(inner.left(), inner.right()));
							}
						};
					})())();
					
					;
				}
			}
		