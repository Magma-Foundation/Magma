import magma.api.Tuple;
import magma.api.option.None;
import magma.api.option.Option;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.java.JavaOptionals;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
export default class def HeadedStream<T>(provider : Head<T>) => {
	public def foldLeftToResult<R, E>(initial : R, mapper : BiFunction<R, T, Result<R, E>>) => this.foldLeft(Ok.from(initial), () => reResult.flatMapValue(() => mapper.apply(inner, t)));
	public def anyMatch(predicate : Predicate<T>) => foldLeft(false, () => aBoolean||predicate.test(t));
	public def filter(filter : Predicate<T>) => flatMap(() => HeadedStream(filter.test(value)?SingleHead(value):EmptyHead.EmptyHead()));
	public def flatMap<R>(mapper : Function<T, Head<R>>) => HeadedStream(head().map(mapper).map(() => FlatMapHead(initial, this, mapper)).orElse(EmptyHead.EmptyHead()));
	public def extend<R>(mapper : Function<T, R>) => map(() => Tuple(value, mapper.apply(value)));
	public def map<R>(mapper : Function<T, R>) => HeadedStream(() => this.provider.head().map(mapper));
	public def collect<C>(collector : Collector<T, C>) => {
		
		current : var=
		
		collector.createInitial();
		return foldLeft(current, collector.fold);
	}
	public def foldLeft<C>(current : C, folder : BiFunction<C, T, C>) => while(true){
		
		finalCurrent : C=
		
		current;
		
		tuple : var=
		
		JavaOptionals.toTuple(JavaOptionals.toNative(head()).map(() => folder.apply(finalCurrent, head)), current);
		if
		(tuple.left())
		{
			current=tuple.right();
		}
		else
		{
			return current;
		}
	}
	public def head() => provider.head();
	default object FlatMapHead {
		private final outer : Head<T>;
		private final mapper : Function<T, Head<R>>;
		private current : Head<R>;
		public def head() => while(true){
			
			currentHead : var=
			
			current.head();
			if
			(currentHead.isPresent())
			return currentHead;
			
			tuple : var=
			
			outer.head().map(mapper).toTuple(current);
			if
			(tuple.left())
			{
				current=tuple.right();
			}
			else
			{
				return None.None();
			}
		}
		implements Head<R>;
	}
	implements Stream<T>;
}