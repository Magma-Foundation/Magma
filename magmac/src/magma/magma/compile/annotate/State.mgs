import magma.Unit;import magma.api.Tuple;import magma.api.collect.List;import magma.api.result.Err;import magma.api.result.Ok;import magma.api.result.Result;import magma.compile.CompileError;import magma.compile.Error_;import magma.java.JavaList;import magma.java.Set;() => {private final sources : Set<Unit>;private final frames : List<List<String>>;State : public => {this=sources;this=frames;}State : public => {this(sources, JavaList());}public exit : State => {return State(sources, frames.popFirst().map(Tuple.right).orElse(frames));}public enter : State => {return State(sources, frames.push(JavaList()));}public isDefined : boolean => {if(isDefinedAsLocation(value)){return true;}return frames.stream().anyMatch(() => frame.contains(value));}private isDefinedAsLocation : boolean => {return sources.stream().map(Unit.computeName).anyMatch(() => name.equals(value));}public computeDepth : int => {return frames.size();}public define : Result<State, Error_> => {if(frames.isEmpty()){return Err(CompileError("No frames present.", frames.toString()));}newFrames : var=frames.mapLast(() => last.add(name)).orElse(frames);return Ok(State(sources, newFrames));}public defineAll : Result<State, Error_> => {return names.stream().foldLeftToResult(this, State.define);}}