
import magma.api.Tuple;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
public class def JavaToMagmaGenerator() => {
	private static def preVisitBlock(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("block"))
		return Optional.empty();
		
		newBlock : var=
		node.mapNodes("children", JavaToMagmaGenerator.removePackagesFromList);
		return Optional.of(Tuple(newBlock, depth+1));
	}
	private static def removePackagesFromList(children : List<Node>) : List<Node> => {
		return children.stream().filter(() => !child.is("package")).toList();
	}
	protected def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		return postVisitFunction(node, depth).or(() => postVisitBlock(node, depth)).orElse(Tuple(node, depth));
	}
	private def postVisitBlock(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("block"))
		return Optional.empty();
		
		prefix : var=
		"\n" + "\t".repeat(depth);
		
		newBlock : var=
		node.mapNodes("children", () => {
			return children.stream().filter(() => !child.is("empty")).map(() => child.withString(StripRule.DEFAULT_LEFT, prefix)).toList();
		}).withString("after-content", "\n" + "\t".repeat(depth==0?0:depth-1));
		return Optional.of(Tuple(newBlock, depth-1));
	}
	private def postVisitFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(node.is("function"))
		{
			
			oldDefinition : var=
			node.findNode("definition");
			if
			(oldDefinition.isPresent())
			{
				
				params : var=
				node.findNodeList("params").orElse(Collections.emptyList());
				if
				(node.has("child"))
				{
					
					newDefinition : var=
					oldDefinition.get().withNodeList("params", params).mapOrSetStringList("modifiers", () => {
						
						copy : var=
						ArrayList(list);
						copy.add("def");
						return copy;
					}, () => List.of("def"));
					return Optional.of(Tuple(node.withNode("definition", newDefinition), depth));
				}
				else
				{
					return Optional.of(Tuple(oldDefinition.get(), depth));
				}
			}
		}
		return Optional.empty();
	}
	protected def preVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		return preVisitBlock(node, depth).or(() => replaceClassWithFunction(node, depth)).or(() => replaceMethodWithFunction(node, depth)).or(() => replaceLambdaWithFunction(node, depth)).or(() => replaceRecordWithFunction(node, depth)).or(() => replaceConstructorsWithInvocation(node, depth)).or(() => replaceInterfaceWithStruct(node, depth)).or(() => replaceMethodReferenceWithAccess(node, depth)).orElse(Tuple(node, depth));
	}
	private def replaceMethodReferenceWithAccess(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("method-reference"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("access"), depth));
	}
	private def replaceRecordWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("record"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceInterfaceWithStruct(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("interface"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("struct"), depth));
	}
	private def replaceLambdaWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("lambda"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceConstructorsWithInvocation(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("constructor"))
		return Optional.empty();
		
		oldChildrenOptional : var=
		node.findNodeList("children");
		if
		(oldChildrenOptional.isPresent())
		{
			
			originalArguments : var=
			node.findNodeList("arguments").orElse(Collections.emptyList());
			
			oldChildren : var=
			oldChildrenOptional.get();
			
			nonFunctions : var=
			ArrayList();
			
			functions : var=
			ArrayList();
			for(oldChild : Node in oldChildren){
				if
				(oldChild.is("method"))
				{
					functions.add(oldChild);
				}
				else
				{
					nonFunctions.add(oldChild);
				}
			}
			
			construction : var=
			node.clear("construction").withNode("child", node.clear("block").withNodeList("children", functions));
			
			newChildren : var=
			ArrayList(nonFunctions);
			newChildren.add(Node("return").withNode("child", construction));
			
			lambdaBody : var=
			node.clear("block").withNodeList("children", newChildren);
			
			lambda : var=
			node.clear("function").withNode("child", lambdaBody);
			
			lambda1 : var=
			node.clear("invocation").withNode("caller", node.clear("quantity").withNode("value", lambda)).withNodeList("arguments", Collections.emptyList());
			
			classCreator : var=
			node.retype("invocation").remove("children").withNodeList("arguments", Collections.singletonList(lambda1));
			return Optional.of(Tuple(node.clear("invocation").withNode("caller", classCreator).withNodeList("arguments", originalArguments), depth));
		}
		else
		{
			return Optional.of(Tuple(node.retype("invocation"), depth));
		}
	}
	private def replaceMethodWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("method"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceClassWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("class"))
		return Optional.empty();
		
		name : var=
		node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
		
		modifiers : var=
		node.findStringList("modifiers").orElseThrow();
		
		newModifiers : var=
		ArrayList(modifiers);
		newModifiers.add("class");
		
		definition : var=
		node.clear("definition").withString("name", name).withStringList("modifiers", newModifiers);
		
		function : var=
		node.retype("function").withNode("definition", definition);
		return Optional.of(Tuple(function, depth));
	}
}
