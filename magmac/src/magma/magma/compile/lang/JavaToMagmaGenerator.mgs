
import magma.api.Tuple;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import java.util.List;
import java.util.Optional;
public JavaToMagmaGenerator => {
	private static preVisitBlock : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("block"))
		return Optional.empty();
		
		newBlock : var=
		node.mapNodes("children", JavaToMagmaGenerator.removePackagesFromList);
		return Optional.of(Tuple(newBlock, depth+1));}
	private static removePackagesFromList : List<Node> => {
		return children.stream().filter(() => !child.is("package")).toList();}
	protected postVisit : Tuple<Node, Integer> => {
		return unwrapUnimplementedFunction(node, depth).or(() => postVisitBlock(node, depth)).orElse(Tuple(node, depth));}
	private postVisitBlock : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("block"))
		return Optional.empty();
		
		prefix : var=
		"\n" + "\t".repeat(depth);
		
		newBlock : var=
		node.mapNodes("children", () => {
			return children.stream().map(() => child.withString(StripRule.DEFAULT_LEFT, prefix)).toList();});
		return Optional.of(Tuple(newBlock, depth-1));}
	private unwrapUnimplementedFunction : Optional<Tuple<Node, Integer>> => {
		if
		(node.is("function"))
		{
			if
			(!node.has("child"))
			{
				
				definition : var=
				node.findNode("definition");
				if
				(definition.isPresent())
				{
					return Optional.of(Tuple(definition.get(), depth));}}}
		return Optional.empty();}
	protected preVisit : Tuple<Node, Integer> => {
		return preVisitBlock(node, depth).or(() => replaceClassWithFunction(node, depth)).or(() => replaceMethodWithFunction(node, depth)).or(() => replaceLambdaWithFunction(node, depth)).or(() => replaceRecordWithFunction(node, depth)).or(() => replaceConstructorsWithInvocation(node, depth)).or(() => replaceInterfaceWithStruct(node, depth)).or(() => replaceMethodReferenceWithAccess(node, depth)).orElse(Tuple(node, depth));}
	private replaceMethodReferenceWithAccess : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("method-reference"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("access"), depth));}
	private replaceRecordWithFunction : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("record"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));}
	private replaceInterfaceWithStruct : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("interface"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("struct"), depth));}
	private replaceLambdaWithFunction : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("lambda"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));}
	private replaceConstructorsWithInvocation : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("constructor"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("invocation"), depth));}
	private replaceMethodWithFunction : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("method"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));}
	private replaceClassWithFunction : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("class"))
		return Optional.empty();
		
		name : var=
		node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
		
		modifiers : var=
		node.findStringList("modifiers").orElseThrow();
		
		definition : var=
		node.clear("definition").withString("name", name).withStringList("modifiers", modifiers);
		
		function : var=
		node.retype("function").withNode("definition", definition);
		return Optional.of(Tuple(function, depth));}}