
import magma.api.Tuple;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
public class def JavaToMagmaGenerator() => {
	private static def preVisitBlock(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("block"))
		return Optional.empty();
		newBlock = node.mapNodes("children", JavaToMagmaGenerator.removePackagesFromList);
		return Optional.of(Tuple(newBlock, depth+1));
	}
	private static def removePackagesFromList(children : List<Node>) : List<Node> => {
		return children.stream().filter(() => !child.is("package")).toList();
	}
	private static def removeType(node : Node) : Node => {
		definition = node.findNode("definition").orElseThrow();
		typeOptional = definition.findNode("type").orElseThrow();
		type = typeOptional;
		if
		(!type.is("symbol"))
		return node;
		value = type.findString("value").orElseThrow();
		if
		(value.equals("var"))
		{
			return node.withNode("definition", definition.remove("type"));
		}
		return node;
	}
	protected def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		return postVisitFunction(node, depth).or(() => postVisitBlock(node, depth)).or(() => formatDeclaration(node, depth)).orElse(Tuple(node, depth));
	}
	private def formatDeclaration(node : Node, depth : int) : Optional<? extends Tuple<Node, Integer>> => {
		if
		(!node.is("declaration"))
		return Optional.empty();
		return Optional.of(Tuple(node.withString("after-definition", " ").withString("after-value-separator", " "), depth));
	}
	private def postVisitBlock(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("block"))
		return Optional.empty();
		prefix = "\n" + "\t".repeat(depth);
		newBlock = node.mapNodes("children", () => {
			return children.stream().filter(() => !child.is("empty")).map(() => child.withString(StripRule.DEFAULT_LEFT, prefix)).toList();
		}).withString("after-content", "\n" + "\t".repeat(depth==0?0:depth-1));
		return Optional.of(Tuple(newBlock, depth-1));
	}
	private def postVisitFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(node.is("function"))
		{
			oldDefinition = node.findNode("definition");
			if
			(oldDefinition.isPresent())
			{
				params = node.findNodeList("params").orElse(Collections.emptyList());
				if
				(node.has("child"))
				{
					newDefinition = oldDefinition.get().withNodeList("params", params).mapOrSetStringList("modifiers", () => {
						copy = ArrayList(list);
						copy.add("def");
						return copy;
					}, () => List.of("def"));
					return Optional.of(Tuple(node.withNode("definition", newDefinition), depth));
				}
				else
				{
					return Optional.of(Tuple(oldDefinition.get(), depth));
				}
			}
		}
		return Optional.empty();
	}
	protected def preVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		return preVisitBlock(node, depth).or(() => replaceClassWithFunction(node, depth)).or(() => replaceMethodWithFunction(node, depth)).or(() => replaceLambdaWithFunction(node, depth)).or(() => replaceRecordWithFunction(node, depth)).or(() => replaceConstructorsWithInvocation(node, depth)).or(() => replaceInterfaceWithStruct(node, depth)).or(() => replaceMethodReferenceWithAccess(node, depth)).or(() => replaceGenericWithFunctionType(node, depth)).or(() => preVisitDeclaration(node, depth)).orElse(Tuple(node, depth));
	}
	private def preVisitDeclaration(node : Node, depth : int) : Optional<? extends Tuple<Node, Integer>> => {
		if
		(!node.is("declaration"))
		return Optional.empty();
		removed = removeType(node);
		return Optional.of(Tuple(removed, depth));
	}
	private def replaceGenericWithFunctionType(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("generic"))
		return Optional.empty();
		parent = node.findString("parent").orElseThrow();
		if
		(!parent.equals("Function"))
		return Optional.of(Tuple(node, depth));
		children = node.findNodeList("children").orElseThrow();
		if
		(children.size()!=2)
		{
			return Optional.empty();
		}
		from = children.get(0);
		to = children.get(1);
		return Optional.of(Tuple(node.clear("function-type").withNodeList("params", List.of(from)).withNode("returns", to), depth));
	}
	private def replaceMethodReferenceWithAccess(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("method-reference"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("access"), depth));
	}
	private def replaceRecordWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("record"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceInterfaceWithStruct(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("interface"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("struct"), depth));
	}
	private def replaceLambdaWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("lambda"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceConstructorsWithInvocation(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("constructor"))
		return Optional.empty();
		oldChildrenOptional = node.findNodeList("children");
		if
		(oldChildrenOptional.isPresent())
		{
			originalArguments = node.findNodeList("arguments").orElse(Collections.emptyList());
			oldChildren = oldChildrenOptional.get();
			nonFunctions = ArrayList();
			functions = ArrayList();
			for(oldChild : Node in oldChildren){
				if
				(oldChild.is("method"))
				{
					functions.add(oldChild);
				}
				else
				{
					nonFunctions.add(oldChild);
				}
			}
			construction = node.clear("construction").withNode("child", node.clear("block").withNodeList("children", functions));
			newChildren = ArrayList(nonFunctions);
			newChildren.add(Node("return").withNode("child", construction));
			lambdaBody = node.clear("block").withNodeList("children", newChildren);
			lambda = node.clear("function").withNode("child", lambdaBody);
			lambda1 = node.clear("invocation").withNode("caller", node.clear("quantity").withNode("value", lambda)).withNodeList("arguments", Collections.emptyList());
			classCreator = node.retype("invocation").remove("children").withNodeList("arguments", Collections.singletonList(lambda1));
			return Optional.of(Tuple(node.clear("invocation").withNode("caller", classCreator).withNodeList("arguments", originalArguments), depth));
		}
		else
		{
			return Optional.of(Tuple(node.retype("invocation"), depth));
		}
	}
	private def replaceMethodWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("method"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceClassWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if
		(!node.is("class"))
		return Optional.empty();
		name = node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
		modifiers = node.findStringList("modifiers").orElseThrow();
		newModifiers = ArrayList(modifiers);
		newModifiers.add("class");
		definition = node.clear("definition").withString("name", name).withStringList("modifiers", newModifiers);
		function = node.retype("function").withNode("definition", definition);
		return Optional.of(Tuple(function, depth));
	}
}
