import magma.api.Tuple;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.Error_;
import magma.compile.annotate.State;
import magma.compile.rule.Node;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
export class def JavaToMagmaGenerator() => {
private static def preVisitBlock(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("block"))
return Optional.empty();
let mut newBlock : var = node.mapNodes("children", JavaToMagmaGenerator.removePackagesFromList);
return Optional.of(Ok(newBlock));}
private static def removePackagesFromList(this, children : List<Node>) : List<Node> => {
return children.stream().filter(() => !child.is("package")).toList();}
private static def removeType(this, node : Node) : Node => {
let mut definition : var = node.findNode("definition").orElseThrow();
let mut type : var = definition.findNode("type").orElseThrow();
if(!type.is("symbol"))
return node;
let mut value : var = type.findString("value").orElseThrow();
if(value.equals("var"))
{
return node.withNode("definition", definition.remove("type"));}
return node;}
private static def computeMutator(this, modifiers : List<String>) : List<String> => {
if(modifiers.contains("final"))
{
return List.of("let");}
else
{
return List.of("let", "mut");}}
private static def attachModifiers(this, withParams : Node) : Node => {
return withParams.mapOrSetStringList("modifiers", () => {
let mut copy : var = ArrayList(list);
copy.add("def");
return copy;}, () => List.of("def"));}
private static def replaceConcreteWithFunction(this, node : Node) : Result<Node, Error_> => {
let mut name : var = node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
let mut oldModifiers : var = node.findStringList("modifiers").orElseThrow();
let mut newModifiers : var = computeAccess(oldModifiers);
newModifiers.add("class");
let mut definition : var = node.clear("definition").withString("name", name).withStringList("modifiers", newModifiers);
let mut withMaybeTypeParams : var = node.findNodeList("type-params").map(() => definition.withNodeList("type-params", nodes)).orElse(definition);
let mut function : var = node.retype("function").remove("name").remove("modifiers").remove("type-params").withNode("definition", withMaybeTypeParams);
return Ok(function);}
private static def computeAccess(this, oldModifiers : List<String>) : ArrayList<String> => {
let mut newModifiers : var = ArrayList();
if(oldModifiers.contains("public"))
{
newModifiers.add("export");}
return newModifiers;}
private static def replaceAbstractClassWithDefinition(this, node : Node) : Optional<Result<Node, Error_>> => {
let mut name : var = node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
let mut oldModifiers : var = node.findStringList("modifiers").orElseThrow();
let mut newModifiers : var = computeAccess(oldModifiers);
let mut withMaybeTypeParams : var = node.clear("definition").withStringList("modifiers", Collections.singletonList("class"));
let mut function : var = node.retype("function").remove("name").remove("type-params").withNode("definition", withMaybeTypeParams);
let mut factoryDefinition : var = node.clear("definition");
let mut assigneeValue : var = node.clear("function").withNode("definition", factoryDefinition).withNode("child", function);
let mut assignee : var = node.clear("definition").withString("name", name).withStringList("modifiers", newModifiers);
let mut withTypeParams : var = node.findNodeList("type-params").map(() => assignee.withNodeList("type-params", params)).orElse(assignee);
let mut declaration : var = node.clear("declaration").withNode("definition", withTypeParams).withNode("value", assigneeValue);
return Optional.of(Ok(declaration));}
protected def postVisit(this, node : Node, depth : State) : Result<Tuple<Node, State>, Error_> => {
return postVisitFunction(node).or(() => postVisitDeclaration(node)).map(() => result.mapValue(() => Tuple(newNode, depth))).orElse(Ok(Tuple(node, depth)));}
private def postVisitDeclaration(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("declaration"))
return Optional.empty();
let mut withMutator : var = attachMutator(node);
return Optional.of(Ok(withMutator.withString("after-definition", " ").withString("after-value-separator", " ")));}
private def attachMutator(this, node : Node) : Node => {
return node.mapNode("definition", () => {
return definition.mapOrSetStringList("modifiers", () => {
let mut oldModifiers : var = ArrayList(modifiers);
oldModifiers.addAll(computeMutator(modifiers));
return oldModifiers;}, () => List.of("let", "mut"));});}
private def postVisitFunction(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("function"))
return Optional.empty();
let mut oldDefinition : var = node.findNode("definition");
if(oldDefinition.isEmpty())
return Optional.empty();
let mut params : var = node.findNodeList("params").orElse(Collections.emptyList());
if(!node.has("child"))
return Optional.of(Ok(oldDefinition.get()));
let mut withParams : var = oldDefinition.get().withNodeList("params", params);
let mut newDefinition : var = withParams.has("name")?attachModifiers(withParams):withParams;
return Optional.of(Ok(node.withNode("definition", newDefinition)));}
protected def preVisit(this, node : Node, state : State) : Result<Tuple<Node, State>, Error_> => {
return preVisitBlock(node).or(() => replaceClassWithFunction(node)).or(() => replaceMethodWithFunction(node)).or(() => replaceLambdaWithFunction(node)).or(() => replaceRecordWithFunction(node)).or(() => replaceConstructorsWithInvocation(node)).or(() => replaceInterfaceWithStruct(node)).or(() => replaceMethodReferenceWithAccess(node)).or(() => replaceGenericWithFunctionType(node)).or(() => preVisitDeclaration(node)).map(() => result.mapValue(() => Tuple(value, state))).orElse(Ok(Tuple(node, state)));}
private def preVisitDeclaration(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("declaration"))
return Optional.empty();
let mut removed : var = removeType(node);
return Optional.of(Ok(removed));}
private def replaceGenericWithFunctionType(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("generic"))
return Optional.empty();
let mut parent : var = node.findString("parent").orElseThrow();
let mut children : var = node.findNodeList("children").orElseThrow();
if(parent.equals("Function"))
{
if(children.size()!=2)
{
return Optional.empty();}
let mut from : var = children.get(0);
let mut to : var = children.get(1);
return Optional.of(Ok(node.clear("function-type").withNodeList("params", List.of(from)).withNode("returns", to)));}
else if(parent.equals("Supplier")){
let mut returns : var = children.get(0);
let mut returns1 : var = node.clear("function-type").withNode("returns", returns);
return Optional.of(Ok(returns1));}
return Optional.of(Ok(node));}
private def replaceMethodReferenceWithAccess(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("method-reference"))
return Optional.empty();
return Optional.of(Ok(node.retype("access")));}
private def replaceRecordWithFunction(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("record"))
return Optional.empty();
return Optional.of(replaceConcreteWithFunction(node));}
private def replaceInterfaceWithStruct(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("interface"))
return Optional.empty();
return Optional.of(Ok(node.retype("struct")));}
private def replaceLambdaWithFunction(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("lambda"))
return Optional.empty();
return Optional.of(Ok(node.retype("function")));}
private def replaceConstructorsWithInvocation(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("constructor"))
return Optional.empty();
let mut oldChildrenOptional : var = node.findNodeList("children");
if(oldChildrenOptional.isEmpty())
{
return Optional.of(Ok(node.retype("invocation")));}
let mut originalArguments : var = node.findNodeList("arguments").orElse(Collections.emptyList());
let mut oldChildren : var = oldChildrenOptional.get();
let mut nonFunctions : var = ArrayList();
let mut functions : var = ArrayList();
for(oldChild : Node in oldChildren){
if(oldChild.is("method"))
{
functions.add(oldChild);}
else
{
nonFunctions.add(oldChild);}}
let mut construction : var = node.clear("construction").withNode("child", node.clear("block").withNodeList("children", functions));
let mut newChildren : var = ArrayList(nonFunctions);
newChildren.add(Node("return").withNode("child", construction));
let mut lambdaBody : var = node.clear("block").withNodeList("children", newChildren);
let mut lambda : var = node.clear("function").withNode("child", lambdaBody);
let mut lambda1 : var = node.clear("invocation").withNode("caller", node.clear("quantity").withNode("value", lambda)).withNodeList("arguments", Collections.emptyList());
let mut classCreator : var = node.retype("invocation").remove("children").withNodeList("arguments", Collections.singletonList(lambda1));
return Optional.of(Ok(node.clear("invocation").withNode("caller", classCreator).withNodeList("arguments", originalArguments)));}
private def replaceMethodWithFunction(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("method"))
return Optional.empty();
let mut params : var = node.findNodeList("params").orElse(Collections.emptyList());
let mut copy : var = ArrayList();
let mut thisDefinition : var = node.clear("definition").withString("name", "this");
copy.add(thisDefinition);
copy.addAll(params);
let mut newFunction : var = node.retype("function").withNodeList("params", copy);
return Optional.of(Ok(newFunction));}
private def replaceClassWithFunction(this, node : Node) : Optional<Result<Node, Error_>> => {
if(!node.is("class"))
return Optional.empty();
let mut oldModifiers : var = node.findStringList("modifiers").orElseThrow();
if(oldModifiers.contains("abstract"))
{
return replaceAbstractClassWithDefinition(node);}
else
{
return Optional.of(replaceConcreteWithFunction(node));}}}