
import magma.api.Tuple;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
export class def JavaToMagmaGenerator() => {
	private static def preVisitBlock(this, node : Node, state : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("block"))
		return Optional.empty();
		let mut newBlock = node.mapNodes("children", JavaToMagmaGenerator.removePackagesFromList);
		return Optional.of(Tuple(newBlock, state.enter()));
	}
	private static def removePackagesFromList(this, children : List<Node>) : List<Node> => {
		return children.stream().filter(() => !child.is("package")).toList();
	}
	private static def removeType(this, node : Node) : Node => {
		let mut definition = node.findNode("definition").orElseThrow();
		let mut type = definition.findNode("type").orElseThrow();
		if(!type.is("symbol"))
		return node;
		let mut value = type.findString("value").orElseThrow();
		if(value.equals("var"))
		{
			return node.withNode("definition", definition.remove("type"));
		}
		return node;
	}
	private static def attachFormatting(this, children : List<Node>, prefix : String) : List<Node> => {
		return children.stream().filter(() => !child.is("empty")).map(() => child.withString(StripRule.DEFAULT_LEFT, prefix)).toList();
	}
	private static def computeMutator(this, modifiers : List<String>) : List<String> => {
		if(modifiers.contains("final"))
		{
			return List.of("let");
		}
		else
		{
			return List.of("let", "mut");
		}
	}
	private static def attachModifiers(this, withParams : Node) : Node => {
		return withParams.mapOrSetStringList("modifiers", () => {
			let mut copy = ArrayList(list);
			copy.add("def");
			return copy;
		}, () => List.of("def"));
	}
	private static def replaceConcreteWithFunction(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		let mut name = node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
		let mut oldModifiers = node.findStringList("modifiers").orElseThrow();
		let mut newModifiers = computeAccess(oldModifiers);
		newModifiers.add("class");
		let mut definition = node.clear("definition").withString("name", name).withStringList("modifiers", newModifiers);
		let mut withMaybeTypeParams = node.findNodeList("type-params").map(() => definition.withNodeList("type-params", nodes)).orElse(definition);
		let mut function = node.retype("function").remove("name").remove("modifiers").remove("type-params").withNode("definition", withMaybeTypeParams);
		return Optional.of(Tuple(function, depth));
	}
	private static def computeAccess(this, oldModifiers : List<String>) : ArrayList<String> => {
		let mut newModifiers = ArrayList();
		if(oldModifiers.contains("public"))
		{
			newModifiers.add("export");
		}
		return newModifiers;
	}
	private static def replaceAbstractClassWithDefinition(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		let mut name = node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
		let mut oldModifiers = node.findStringList("modifiers").orElseThrow();
		let mut newModifiers = computeAccess(oldModifiers);
		let mut withMaybeTypeParams = node.clear("definition").withStringList("modifiers", Collections.singletonList("class"));
		let mut function = node.retype("function").remove("name").remove("type-params").withNode("definition", withMaybeTypeParams);
		let mut factoryDefinition = node.clear("definition");
		let mut assigneeValue = node.clear("function").withNode("definition", factoryDefinition).withNode("child", function);
		let mut assignee = node.clear("definition").withString("name", name).withStringList("modifiers", newModifiers);
		let mut withTypeParams = node.findNodeList("type-params").map(() => assignee.withNodeList("type-params", params)).orElse(assignee);
		let mut declaration = node.clear("declaration").withNode("definition", withTypeParams).withNode("value", assigneeValue);
		return Optional.of(Tuple(declaration, depth));
	}
	protected def postVisit(this, node : Node, depth : State) : Tuple<Node, State> => {
		return postVisitFunction(node, depth).or(() => postVisitBlock(node, depth)).or(() => postVisitDeclaration(node, depth)).orElse(Tuple(node, depth));
	}
	private def postVisitDeclaration(this, node : Node, depth : State) : Optional<? extends Tuple<Node, State>> => {
		if(!node.is("declaration"))
		return Optional.empty();
		let mut withMutator = attachMutator(node);
		return Optional.of(Tuple(withMutator.withString("after-definition", " ").withString("after-value-separator", " "), depth));
	}
	private def attachMutator(this, node : Node) : Node => {
		return node.mapNode("definition", () => {
			return definition.mapOrSetStringList("modifiers", () => {
				let mut oldModifiers = ArrayList(modifiers);
				oldModifiers.addAll(computeMutator(modifiers));
				return oldModifiers;
			}, () => List.of("let", "mut"));
		});
	}
	private def postVisitBlock(this, node : Node, state : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("block"))
		return Optional.empty();
		let mut depth = state.depth();
		let mut prefix = "\n" + "\t".repeat(depth);
		let mut newBlock = node.mapNodes("children", () => attachFormatting(children, prefix)).withString("after-content", "\n" + "\t".repeat(depth==0?0:depth-1));
		return Optional.of(Tuple(newBlock, state.exit()));
	}
	private def postVisitFunction(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("function"))
		return Optional.empty();
		let mut oldDefinition = node.findNode("definition");
		if(oldDefinition.isEmpty())
		return Optional.empty();
		let mut params = node.findNodeList("params").orElse(Collections.emptyList());
		if(!node.has("child"))
		return Optional.of(Tuple(oldDefinition.get(), depth));
		let mut withParams = oldDefinition.get().withNodeList("params", params);
		let mut newDefinition = withParams.has("name")?attachModifiers(withParams):withParams;
		return Optional.of(Tuple(node.withNode("definition", newDefinition), depth));
	}
	protected def preVisit(this, node : Node, depth : State) : Tuple<Node, State> => {
		return preVisitBlock(node, depth).or(() => replaceClassWithFunction(node, depth)).or(() => replaceMethodWithFunction(node, depth)).or(() => replaceLambdaWithFunction(node, depth)).or(() => replaceRecordWithFunction(node, depth)).or(() => replaceConstructorsWithInvocation(node, depth)).or(() => replaceInterfaceWithStruct(node, depth)).or(() => replaceMethodReferenceWithAccess(node, depth)).or(() => replaceGenericWithFunctionType(node, depth)).or(() => preVisitDeclaration(node, depth)).orElse(Tuple(node, depth));
	}
	private def preVisitDeclaration(this, node : Node, depth : State) : Optional<? extends Tuple<Node, State>> => {
		if(!node.is("declaration"))
		return Optional.empty();
		let mut removed = removeType(node);
		return Optional.of(Tuple(removed, depth));
	}
	private def replaceGenericWithFunctionType(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("generic"))
		return Optional.empty();
		let mut parent = node.findString("parent").orElseThrow();
		let mut children = node.findNodeList("children").orElseThrow();
		if(parent.equals("Function"))
		{
			if(children.size()!=2)
			{
				return Optional.empty();
			}
			let mut from = children.get(0);
			let mut to = children.get(1);
			return Optional.of(Tuple(node.clear("function-type").withNodeList("params", List.of(from)).withNode("returns", to), depth));
		}
		else if(parent.equals("Supplier")){
			let mut returns = children.get(0);
			let mut returns1 = node.clear("function-type").withNode("returns", returns);
			return Optional.of(Tuple(returns1, depth));
		}
		return Optional.of(Tuple(node, depth));
	}
	private def replaceMethodReferenceWithAccess(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("method-reference"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("access"), depth));
	}
	private def replaceRecordWithFunction(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("record"))
		return Optional.empty();
		return replaceConcreteWithFunction(node, depth);
	}
	private def replaceInterfaceWithStruct(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("interface"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("struct"), depth));
	}
	private def replaceLambdaWithFunction(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("lambda"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceConstructorsWithInvocation(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("constructor"))
		return Optional.empty();
		let mut oldChildrenOptional = node.findNodeList("children");
		if(oldChildrenOptional.isPresent())
		{
			let mut originalArguments = node.findNodeList("arguments").orElse(Collections.emptyList());
			let mut oldChildren = oldChildrenOptional.get();
			let mut nonFunctions = ArrayList();
			let mut functions = ArrayList();
			for(oldChild : Node in oldChildren){
				if(oldChild.is("method"))
				{
					functions.add(oldChild);
				}
				else
				{
					nonFunctions.add(oldChild);
				}
			}
			let mut construction = node.clear("construction").withNode("child", node.clear("block").withNodeList("children", functions));
			let mut newChildren = ArrayList(nonFunctions);
			newChildren.add(Node("return").withNode("child", construction));
			let mut lambdaBody = node.clear("block").withNodeList("children", newChildren);
			let mut lambda = node.clear("function").withNode("child", lambdaBody);
			let mut lambda1 = node.clear("invocation").withNode("caller", node.clear("quantity").withNode("value", lambda)).withNodeList("arguments", Collections.emptyList());
			let mut classCreator = node.retype("invocation").remove("children").withNodeList("arguments", Collections.singletonList(lambda1));
			return Optional.of(Tuple(node.clear("invocation").withNode("caller", classCreator).withNodeList("arguments", originalArguments), depth));
		}
		else
		{
			return Optional.of(Tuple(node.retype("invocation"), depth));
		}
	}
	private def replaceMethodWithFunction(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("method"))
		return Optional.empty();
		let mut newFunction = node.retype("function").mapNodes("params", () => {
			let mut copy = ArrayList();
			let mut thisDefinition = node.clear("definition").withString("name", "this");
			copy.add(thisDefinition);
			copy.addAll(params);
			return copy;
		});
		return Optional.of(Tuple(newFunction, depth));
	}
	private def replaceClassWithFunction(this, node : Node, depth : State) : Optional<Tuple<Node, State>> => {
		if(!node.is("class"))
		return Optional.empty();
		let mut oldModifiers = node.findStringList("modifiers").orElseThrow();
		if(oldModifiers.contains("abstract"))
		{
			return replaceAbstractClassWithDefinition(node, depth);
		}
		else
		{
			return replaceConcreteWithFunction(node, depth);
		}
	}
}
