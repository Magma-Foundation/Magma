
import magma.api.Tuple;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
export class def JavaToMagmaGenerator() => {
	private static def preVisitBlock(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("block"))
		return Optional.empty();
		let mut newBlock = node.mapNodes("children", JavaToMagmaGenerator.removePackagesFromList);
		return Optional.of(Tuple(newBlock, depth+1));
	}
	private static def removePackagesFromList(children : List<Node>) : List<Node> => {
		return children.stream().filter(() => !child.is("package")).toList();
	}
	private static def removeType(node : Node) : Node => {
		let mut definition = node.findNode("definition").orElseThrow();
		let mut type = definition.findNode("type").orElseThrow();
		if(!type.is("symbol"))
		return node;
		let mut value = type.findString("value").orElseThrow();
		if(value.equals("var"))
		{
			return node.withNode("definition", definition.remove("type"));
		}
		return node;
	}
	private static def attachFormatting(children : List<Node>, prefix : String) : List<Node> => {
		return children.stream().filter(() => !child.is("empty")).map(() => child.withString(StripRule.DEFAULT_LEFT, prefix)).toList();
	}
	protected def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		return postVisitFunction(node, depth).or(() => postVisitBlock(node, depth)).or(() => postVisitDeclaration(node, depth)).orElse(Tuple(node, depth));
	}
	private def postVisitDeclaration(node : Node, depth : int) : Optional<? extends Tuple<Node, Integer>> => {
		if(!node.is("declaration"))
		return Optional.empty();
		let mut withMutator = attachMutator(node);
		return Optional.of(Tuple(withMutator.withString("after-definition", " ").withString("after-value-separator", " "), depth));
	}
	private def attachMutator(node : Node) : Node => {
		return node.mapNode("definition", () => {
			return definition.mapOrSetStringList("modifiers", () => {
				if(modifiers.contains("final"))
				{
					return List.of("let");
				}
				else
				{
					return List.of("let", "mut");
				}
			}, () => List.of("let", "mut"));
		});
	}
	private def postVisitBlock(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("block"))
		return Optional.empty();
		let mut prefix = "\n" + "\t".repeat(depth);
		let mut newBlock = node.mapNodes("children", () => attachFormatting(children, prefix)).withString("after-content", "\n" + "\t".repeat(depth==0?0:depth-1));
		return Optional.of(Tuple(newBlock, depth-1));
	}
	private def postVisitFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("function"))
		return Optional.empty();
		let mut oldDefinition = node.findNode("definition");
		if(oldDefinition.isEmpty())
		return Optional.empty();
		let mut params = node.findNodeList("params").orElse(Collections.emptyList());
		if(!node.has("child"))
		return Optional.of(Tuple(oldDefinition.get(), depth));
		let mut newDefinition = oldDefinition.get().withNodeList("params", params).mapOrSetStringList("modifiers", () => {
			let mut copy = ArrayList(list);
			copy.add("def");
			return copy;
		}, () => List.of("def"));
		return Optional.of(Tuple(node.withNode("definition", newDefinition), depth));
	}
	protected def preVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		return preVisitBlock(node, depth).or(() => replaceClassWithFunction(node, depth)).or(() => replaceMethodWithFunction(node, depth)).or(() => replaceLambdaWithFunction(node, depth)).or(() => replaceRecordWithFunction(node, depth)).or(() => replaceConstructorsWithInvocation(node, depth)).or(() => replaceInterfaceWithStruct(node, depth)).or(() => replaceMethodReferenceWithAccess(node, depth)).or(() => replaceGenericWithFunctionType(node, depth)).or(() => preVisitDeclaration(node, depth)).orElse(Tuple(node, depth));
	}
	private def preVisitDeclaration(node : Node, depth : int) : Optional<? extends Tuple<Node, Integer>> => {
		if(!node.is("declaration"))
		return Optional.empty();
		let mut removed = removeType(node);
		return Optional.of(Tuple(removed, depth));
	}
	private def replaceGenericWithFunctionType(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("generic"))
		return Optional.empty();
		let mut parent = node.findString("parent").orElseThrow();
		if(!parent.equals("Function"))
		return Optional.of(Tuple(node, depth));
		let mut children = node.findNodeList("children").orElseThrow();
		if(children.size()!=2)
		{
			return Optional.empty();
		}
		let mut from = children.get(0);
		let mut to = children.get(1);
		return Optional.of(Tuple(node.clear("function-type").withNodeList("params", List.of(from)).withNode("returns", to), depth));
	}
	private def replaceMethodReferenceWithAccess(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("method-reference"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("access"), depth));
	}
	private def replaceRecordWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("record"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceInterfaceWithStruct(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("interface"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("struct"), depth));
	}
	private def replaceLambdaWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("lambda"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceConstructorsWithInvocation(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("constructor"))
		return Optional.empty();
		let mut oldChildrenOptional = node.findNodeList("children");
		if(oldChildrenOptional.isPresent())
		{
			let mut originalArguments = node.findNodeList("arguments").orElse(Collections.emptyList());
			let mut oldChildren = oldChildrenOptional.get();
			let mut nonFunctions = ArrayList();
			let mut functions = ArrayList();
			for(oldChild : Node in oldChildren){
				if(oldChild.is("method"))
				{
					functions.add(oldChild);
				}
				else
				{
					nonFunctions.add(oldChild);
				}
			}
			let mut construction = node.clear("construction").withNode("child", node.clear("block").withNodeList("children", functions));
			let mut newChildren = ArrayList(nonFunctions);
			newChildren.add(Node("return").withNode("child", construction));
			let mut lambdaBody = node.clear("block").withNodeList("children", newChildren);
			let mut lambda = node.clear("function").withNode("child", lambdaBody);
			let mut lambda1 = node.clear("invocation").withNode("caller", node.clear("quantity").withNode("value", lambda)).withNodeList("arguments", Collections.emptyList());
			let mut classCreator = node.retype("invocation").remove("children").withNodeList("arguments", Collections.singletonList(lambda1));
			return Optional.of(Tuple(node.clear("invocation").withNode("caller", classCreator).withNodeList("arguments", originalArguments), depth));
		}
		else
		{
			return Optional.of(Tuple(node.retype("invocation"), depth));
		}
	}
	private def replaceMethodWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("method"))
		return Optional.empty();
		return Optional.of(Tuple(node.retype("function"), depth));
	}
	private def replaceClassWithFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("class"))
		return Optional.empty();
		let mut name = node.findString("name").orElseThrow(() => RuntimeException("No name present: "+node));
		let mut oldModifiers = node.findStringList("modifiers").orElseThrow();
		let mut newModifiers = ArrayList();
		if(oldModifiers.contains("public"))
		{
			newModifiers.add("export");
		}
		newModifiers.add("class");
		let mut definition = node.clear("definition").withString("name", name).withStringList("modifiers", newModifiers);
		let mut withMaybeTypeParams = node.findNodeList("type-params").map(() => definition.withNodeList("type-params", nodes)).orElse(definition);
		let mut function = node.retype("function").remove("name").remove("modifiers").remove("type-params").withNode("definition", withMaybeTypeParams);
		return Optional.of(Tuple(function, depth));
	}
}
