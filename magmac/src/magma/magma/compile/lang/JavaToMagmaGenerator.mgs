import magma.api.Tuple;import magma.compile.rule.Node;import java.util.List;import java.util.Optional;() => {private static removePackagesFromBlock : Optional<Node> => {if(!node.is("block"))return Optional.empty();return Optional.of(node.mapNodes("children", JavaToMagmaGenerator.removePackagesFromList));}private static removePackagesFromList : List<Node> => {return children.stream().filter(() => !child.is("package")).toList();}protected postVisit : Tuple<Node, Integer> => {newNode : var=unwrapUnimplementedFunction(node).orElse(node);return Tuple(newNode, depth);}private unwrapUnimplementedFunction : Optional<Node> => {if(node.is("function")){if(!node.has("child")){definition : var=node.findNode("definition");if(definition.isPresent()){return definition;}}}return Optional.empty();}protected preVisit : Tuple<Node, Integer> => {newNode : var=removePackagesFromBlock(node).or(() => replaceClassWithFunction(node)).or(() => replaceMethodWithFunction(node)).or(() => replaceLambdaWithFunction(node)).or(() => replaceRecordWithFunction(node)).or(() => replaceConstructorsWithInvocation(node)).or(() => replaceInterfaceWithStruct(node)).or(() => replaceMethodReferenceWithAccess(node)).orElse(node);return Tuple(newNode, depth);}private replaceMethodReferenceWithAccess : Optional<Node> => {if(!node.is("method-reference"))return Optional.empty();return Optional.of(node.retype("access"));}private replaceRecordWithFunction : Optional<Node> => {if(!node.is("record"))return Optional.empty();return Optional.of(node.retype("function"));}private replaceInterfaceWithStruct : Optional<Node> => {if(!node.is("interface"))return Optional.empty();return Optional.of(node.retype("struct"));}private replaceLambdaWithFunction : Optional<Node> => {if(!node.is("lambda"))return Optional.empty();return Optional.of(node.retype("function"));}private replaceConstructorsWithInvocation : Optional<Node> => {if(!node.is("constructor"))return Optional.empty();return Optional.of(node.retype("invocation"));}private replaceMethodWithFunction : Optional<Node> => {if(!node.is("method"))return Optional.empty();return Optional.of(node.retype("function"));}private replaceClassWithFunction : Optional<Node> => {if(!node.is("class"))return Optional.empty();return Optional.of(node.retype("function"));}}