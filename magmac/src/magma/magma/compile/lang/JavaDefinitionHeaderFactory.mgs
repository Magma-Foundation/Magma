import magma.compile.CompileError;
import magma.compile.Error_;
import magma.compile.rule.ContextRule;
import magma.compile.rule.OrRule;
import magma.compile.rule.Rule;
import magma.compile.rule.TypeRule;
import magma.compile.rule.split.BackwardsRule;
import magma.compile.rule.split.LastRule;
import magma.compile.rule.split.SplitMultipleRule;
import magma.compile.rule.split.Splitter;
import magma.compile.rule.text.LeftRule;
import magma.compile.rule.text.RightRule;
import magma.compile.rule.text.StripRule;
import magma.compile.rule.text.extract.ExtractNodeRule;
import magma.compile.rule.text.extract.ExtractStringListRule;
import magma.compile.rule.text.extract.ExtractStringRule;
import magma.compile.rule.text.extract.SimpleExtractStringListRule;
import java.util.List;
import java.util.Optional;
export object JavaDefinitionHeaderFactory {
	def createDefinitionHeaderRule() => {
		type : var=ExtractNodeRule("type", Lang.createTypeRule());
		name : var=ExtractStringRule("name");
		generics : var=LeftRule("<", RightRule(Lang.createTypeParamsRule(), ">"));
		withGenerics : var=ContextRule("With generics.", StripRule(BackwardsRule(generics, " ", type)));
		withoutGenerics : var=ContextRule("Without generics.", type);
		maybeGenerics : var=OrRule(List.of(withGenerics, withoutGenerics));
		modifiers : var=ModifiersRule();
		withModifiers : var=ContextRule("With modifiers.", BackwardsRule(modifiers, " ", maybeGenerics));
		withoutModifiers : var=ContextRule("Without modifiers.", maybeGenerics);
		maybeModifiers : var=OrRule(List.of(withModifiers, withoutModifiers));
		annotation : var=TypeRule("annotation", LeftRule("@", ExtractStringRule("value")));
		annotations : var=SplitMultipleRule(SimpleSplitter(), ", ", "annotations", annotation);
		withAnnotations : var=ContextRule("With annotations.", LastRule(annotations, "\r\n", maybeModifiers));
		withoutAnnotations : var=ContextRule("Without annotations.", maybeModifiers);
		maybeAnnotations : var=OrRule(List.of(withAnnotations, withoutAnnotations));
		beforeName : var=ContextRule("Cannot parse before name.", maybeAnnotations);
		return TypeRule("definition", StripRule(LastRule(beforeName, " ", name)));
	}
}
export class def JavaDefinitionHeaderFactory() => {
	 object ModifiersRule {
		public static final MODIFIERS : List<String>=List.of("public", "static", "final", "private", "default", "protected", "abstract");
		def qualify(child : String) => {
			if(MODIFIERS.contains(child))
			{
				return Optional.empty();
			}
			else
			{
				return Optional.of(CompileError("Invalid modifier.", child));
			}
		}
	}
	class def SimpleSplitter() => {
		public def split(input : String) => List.of(input.split("\r\n"));
		implements Splitter;
	}
}