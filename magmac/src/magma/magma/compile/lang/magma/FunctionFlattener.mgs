import magma.api.Tuple;
import magma.api.result.Err;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.CompileError;
import magma.compile.Error_;
import magma.compile.annotate.State;
import magma.compile.lang.Visitor;
import magma.compile.rule.Node;
import magma.java.JavaList;
export default class def FunctionFlattener() => {
	private static flattenChild(child : Node, node : Node, state : State) : Result<Tuple<Node, State>, Error_> => {
		if
		(child.is("block"))
		return flattenInner(child, node).mapValue(() => Tuple(newNode, state));
		// Child is already flattened, probably in a lambda...
		return Ok(Tuple(node, state));
	}
	private static flattenInner(child : Node, node : Node) : Result<Node, Error_> => {
		
		children : var=
		
		child.findNodeList("children").orElse(JavaList.empty());
		if
		(children.size()!=1)
		{
			return Ok(node);
		}
		
		firstOptional : var=
		
		children.first();
		if
		(firstOptional.isPresent())
		{
			
			first : var=
			
			firstOptional.orElsePanic();
			
			value : var=
			
			first.is("return")?first.retype("statement"):first;
			return Ok(node.withNode("child", value));
		}
		else
		{
			return Err(CompileError("List implementation is malformed.", node.toString()));
		}
	}
	public preVisit(node : Node, state : State) : Result<Tuple<Node, State>, Error_> => node.findNode("child").map(() => flattenChild(child, node, state)).orElseGet(() => Err(CompileError("No child is present.", node.toString())));
}