import magma.api.Tuple;
import magma.api.collect.List;
import magma.api.collect.stream.Streams;
import magma.api.option.Options;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.Error_;
import magma.compile.annotate.State;
import magma.compile.lang.Visitor;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import magma.java.JavaList;
export default class def BlockFormatter() => {
	private static indentChildren(children : List<Node>, state : State) : List<Node> => return Streams.rangeTo(children.size()).extend(children.get).map(Options.invertRight).flatMap(Streams.fromOption).map(() => attachAfterChild(child, state)).collect(JavaList.collecting());
	private static attachAfterChild(child : Tuple<Integer, Node>, state : State) : Node => {
		
		depth : var=
		
		state.computeDepth();
		
		childIndent : var=
		
		"\n" + "\t".repeat(depth-1);
		
		index : var=
		
		child.left();
		if
		(index==0&&depth==1)
		return child.right();
		return child.right().withString(StripRule.DEFAULT_LEFT, childIndent);
	}
	private static attachAfterChildren(node : Node, depth : int) : Node => {
		if
		(depth<=1)
		return node;
		
		count : var=
		
		depth-2;
		
		endIndent : var=
		
		"\n" + "\t".repeat(count);
		return node.withString("after-children", endIndent);
	}
	public preVisit(node : Node, state : State) : Result<Tuple<Node, State>, Error_> => return Ok(Tuple(node, state.enter()));
	public postVisit(node : Node, state : State) : Result<Tuple<Node, State>, Error_> => {
		
		withChildren : var=
		
		node.mapNodes("children", () => indentChildren(children, state));
		
		exited : var=
		
		state.exit();
		
		depth : var=
		
		state.computeDepth();
		
		withAfterChildren : var=
		
		attachAfterChildren(withChildren, depth);
		
		tuple : var=
		
		Tuple(withAfterChildren, exited);
		return Ok(tuple);
	}
}