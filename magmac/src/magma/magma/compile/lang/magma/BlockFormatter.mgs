import magma.api.Tuple;
import magma.api.collect.List;
import magma.api.collect.stream.Streams;
import magma.api.option.Options;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.Error_;
import magma.compile.annotate.State;
import magma.compile.lang.Visitor;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import magma.java.JavaList;
export default class def BlockFormatter() => {
	def indentChildren(children : List<Node>, state : State) => Streams.rangeTo(children.size()).extend(children.get).map(Options.invertRight).flatMap(Streams.fromOption).map(() => attachAfterChild(child, state)).collect(JavaList.collecting());
	def attachAfterChild(child : Tuple<Integer, Node>, state : State) => {
		
		depth : var=
		
		state.computeDepth();
		
		childIndent : var=
		
		"\n" + "\t".repeat(depth-1);
		
		index : var=
		
		child.left();
		if
		(index==0&&depth==1)
		return child.right();
		return child.right().withString(StripRule.DEFAULT_LEFT, childIndent);
	}
	def attachAfterChildren(node : Node, depth : int) => {
		if
		(depth<=1)
		return node;
		
		count : var=
		
		depth-2;
		
		endIndent : var=
		
		"\n" + "\t".repeat(count);
		return node.withString("after-children", endIndent);
	}
	public def preVisit(node : Node, state : State) => Ok(Tuple(node, state.enter()));
	public def postVisit(node : Node, state : State) => {
		
		withChildren : var=
		
		node.mapNodes("children", () => indentChildren(children, state));
		
		exited : var=
		
		state.exit();
		
		depth : var=
		
		state.computeDepth();
		
		withAfterChildren : var=
		
		attachAfterChildren(withChildren, depth);
		
		tuple : var=
		
		Tuple(withAfterChildren, exited);
		return Ok(tuple);
	}
	implements Visitor;
}