import magma.api.Tuple;
import magma.compile.attribute.Attribute;
import magma.compile.attribute.NodeAttribute;
import magma.compile.attribute.StringListAttribute;
import magma.compile.rule.Node;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
export class def MagmaGenerator extends Generator() => {
	def attachModifiers(definition : Node) : Node => {
		let oldModifiers = definition.attributes().apply("modifiers").flatMap(Attribute.asStringList).orElse(ArrayList());
		let copy = ArrayList();
		if(oldModifiers.contains("final")){
			copy.add("const");
		}
		else
		{
			copy.add("let");
		}
		return definition.withStringList("modifiers", copy);
	}
	def removeImplicitType(definition : Node) : Node => {
		let typeOptional = definition.attributes().apply("type").flatMap(Attribute.asNode);
		if(typeOptional.isEmpty())return definition;
		let type = typeOptional.get();
		if(type.is("symbol")){
			let value = type.attributes().apply("value").flatMap(Attribute.asString).orElseThrow();
			if(value.equals("var")){
				return definition.remove("type");
			}
			else
			{
				return definition;
			}
		
		}
		else
		{
			return definition;
		}
	
	}
	def generateFromInterface(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("interface")){
			return Optional.empty();
		}
		let struct = node.retype("struct").mapAttributes((attribute) => {
			let withModifiers = attribute.mapValue("modifiers", StringListAttribute.Factory, (list) => {
				let newList = ArrayList();
				if(list.contains("public")){
					newList.add("export");
				}
				return newList;
			});
			return withModifiers.mapValue("child", NodeAttribute.Factory, (interfaceChild) => interfaceChild.mapNodes("children", (children) => children.stream().map(MagmaGenerator.migrateDefinition).toList()));
		});
		return Optional.of(Tuple(struct, depth));
	}
	def migrateDefinition(child : Node) : Node => {
		if(!child.is("definition"))return child;
		let paramsOptional = child.attributes().apply("params").flatMap(Attribute.asNodeList);
		if(paramsOptional.isEmpty())return child;
		let params = paramsOptional.get().stream().map(Node.attributes).map((attributes) => attributes.apply("type")).flatMap(Optional.stream).map(Attribute.asNode).flatMap(Optional.stream).toList();
		return child.remove("params").mapOrSetStringList("modifiers", (list) => add(list, "const"), () => Collections.singletonList("const")).mapNode("type", (returnType) => buildFunctionType(returnType, params));
	}
	def add(list : List<T>, element : T) : List<T> => {
		let copy = ArrayList(list);
		copy.add(element);
		return copy;
	}
	def buildFunctionType(returnType : Node, params : List<Node>) : Node => {
		return Node("function-type").withNodeList("params", params).withNode("returns", returnType);
	}
	def getNodeIntegerTuple3(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("record")){
			return Tuple(node.retype("function"), depth);
		}
		return null;
	}
	def getNodeIntegerTuple2(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("constructor")){
			return Tuple(node.retype("invocation"), depth);
		}
		return null;
	}
	def getNodeIntegerTuple1(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("definition")){
			let removed = removeImplicitType(node);
			let modifiers = removed.attributes().apply("modifiers").flatMap(Attribute.asStringList);
			if(modifiers.isEmpty()||modifiers.get().isEmpty()){
				return Tuple(removed.remove("modifiers"), depth);
			}
			else
			{
				return Tuple(removed, depth);
			}
		
		}
		return null;
	}
	def getTuple(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("declaration")){
			let definition = node.mapNode("definition:scope", (scope) => {
				return scope.mapNode("definition", MagmaGenerator.attachModifiers);
			});
			return Tuple(definition, depth);
		}
		return null;
	}
	def getIntegerTuple(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("function")){
			if(!node.has("child")){
				let definition = node.attributes().apply("definition").flatMap(Attribute.asNode).orElseThrow();
				return Tuple(definition, depth);
			}
		}
		return null;
	}
	def getNodeIntegerTuple(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("generic-type")){
			let parent = node.attributes().apply("parent").flatMap(Attribute.asNode).orElseThrow();
			if(parent.is("symbol")){
				let value = parent.attributes().apply("value").flatMap(Attribute.asString).orElseThrow();
				if(value.equals("Function")){
					let children = node.attributes().apply("children").flatMap(Attribute.asNodeList).orElseThrow();
					let first = children.get(0);
					let second = children.get(1);
					let newNode = buildFunctionType(second, Collections.singletonList(first));
					return Tuple(newNode, depth);
				}
			}
		}
		return null;
	}
	def generateFromFunction(node : Node, depth : int) : Optional<Tuple<Node, Integer>> => {
		if(!node.is("function"))return Optional.empty();
		let node1 = node.mapAttributes((attributes) => attributes.mapValue("definition", NodeAttribute.Factory, (definition) => {
			if(!definition.attributes().has("name")){
				return definition;
			}
			return definition.mapAttributes((attributes1) => attributes1.mapValue("modifiers", StringListAttribute.Factory, (list) => {
				if(list.contains("class"))return list;
				let copy = ArrayList();
				if(list.contains("public")){
					copy.add("public");
				}
				copy.add("def");
				return copy;
			}));
		}));
		return Optional.of(Tuple(node1, depth));
	}
	def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("block")){
			return Tuple(node.mapNodes("children", (list) => {
				return list.stream().filter((child) => !child.is("empty")).toList();
			}), depth);
		}
		let newNode = getNodeIntegerTuple(node, depth);
		if(newNode!=null)return newNode;
		let definition = getIntegerTuple(node, depth);
		if(definition!=null)return definition;
		let definition1 = getTuple(node, depth);
		if(definition1!=null)return definition1;
		let removed = getNodeIntegerTuple1(node, depth);
		if(removed!=null)return removed;
		let node2 = getNodeIntegerTuple2(node, depth);
		if(node2!=null)return node2;
		let node3 = getNodeIntegerTuple3(node, depth);
		if(node3!=null)return node3;
		let struct = generateFromInterface(node, depth);
		if(struct.isPresent())return struct.get();
		let node1 = generateFromFunction(node, depth);
		return node1.orElseGet(() => Tuple(node, depth));
	}
}
