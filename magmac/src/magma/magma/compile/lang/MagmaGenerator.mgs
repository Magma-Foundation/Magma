import magma.api.Tuple;
import magma.compile.attribute.Attribute;
import magma.compile.attribute.NodeAttribute;
import magma.compile.attribute.StringListAttribute;
import magma.compile.rule.Node;
import java.util.ArrayList;
export class def MagmaGenerator extends Generator() => {
	def attachModifiers(definition : Node) : Node => {
		oldModifiers : var = definition.attributes().apply("modifiers").flatMap(Attribute.asStringList).orElse(ArrayList());
		copy : var = ArrayList();
		if(oldModifiers.contains("final")){
			copy.add("const");
		}
		else
		{
			copy.add("let");
		}
		return definition.withStringList("modifiers", copy);
	}
	def removeImplicitType(definition : Node) : Node => {
		type : var = definition.attributes().apply("type").flatMap(Attribute.asNode).orElseThrow();
		if(type.is("symbol")){
			value : var = type.attributes().apply("value").flatMap(Attribute.asString).orElseThrow();
			if(value.equals("var")){
				return definition.remove("type");
			}
			else
			{
				return definition;
			}
		
		}
		else
		{
			return definition;
		}
	
	}
	def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("constructor")){
			return Tuple(node.retype("invocation"), depth);
		}
		if(node.is("record")){
			return Tuple(node.retype("function"), depth);
		}
		if(node.is("interface")){
			return Tuple(node.retype("trait"), depth);
		}
		if(node.is("function")){
			node1 : var = node.mapAttributes( (attributes) => {
				return attributes.mapValue("definition", NodeAttribute.Factory,  (definition) => {
					if(!definition.attributes().has("name")){
						return definition;
					}
					return definition.mapAttributes( (attributes1) => {
						return attributes1.mapValue("modifiers", StringListAttribute.Factory,  (list) => {
							if(list.contains("class"))return list;
							copy : var = ArrayList();
							if(list.contains("public")){
								copy.add("public");
							}
							copy.add("def");
							return copy;
						});
					});
				});
			});
			return Tuple(node1, depth);
		}
		if(node.is("declaration")){
			node1 : var = node.mapAttributes( (attributes) => {
				return attributes.mapValue("definition", NodeAttribute.Factory,  (definition) => {
					withModifiers : var = attachModifiers(definition);
					return removeImplicitType(withModifiers);
				});
			});
			return Tuple(node1, depth);
		}
		return Tuple(node, depth);
	}
}
