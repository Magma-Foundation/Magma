import magma.api.Tuple;
import magma.compile.attribute.Attribute;
import magma.compile.attribute.NodeAttribute;
import magma.compile.attribute.StringListAttribute;
import magma.compile.rule.Node;
import java.util.ArrayList;
export class def MagmaGenerator extends Generator() => {
	def attachModifiers(definition : Node) : Node => {
		let oldModifiers = definition.attributes().apply("modifiers").flatMap(Attribute.asStringList).orElse(ArrayList());
		let copy = ArrayList();
		if(oldModifiers.contains("final")){
			copy.add("const");
		}
		else
		{
			copy.add("let");
		}
		return definition.withStringList("modifiers", copy);
	}
	def removeImplicitType(definition : Node) : Node => {
		let typeOptional = definition.attributes().apply("type").flatMap(Attribute.asNode);
		if(typeOptional.isEmpty())return definition;
		let type = typeOptional.get();
		if(type.is("symbol")){
			let value = type.attributes().apply("value").flatMap(Attribute.asString).orElseThrow();
			if(value.equals("var")){
				return definition.remove("type");
			}
			else
			{
				return definition;
			}
		
		}
		else
		{
			return definition;
		}
	
	}
	def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("generic-type")){
			let parent = node.attributes().apply("parent").flatMap(Attribute.asNode).orElseThrow();
			if(parent.is("symbol")){
				let value = parent.attributes().apply("value").flatMap(Attribute.asString).orElseThrow();
				if(value.equals("Function")){
					let children = node.attributes().apply("children").flatMap(Attribute.asNodeList).orElseThrow();
					let first = children.get(0);
					let second = children.get(1);
					let newNode = Node("function-type").withNode("from", first).withNode("to", second);
					return Tuple(newNode, depth);
				}
			}
		}
		if(node.is("function")){
			if(!node.has("child")){
				let definition = node.attributes().apply("definition").flatMap(Attribute.asNode).orElseThrow();
				return Tuple(definition, depth);
			}
		}
		if(node.is("declaration")){
			let definition = node.mapNode("definition:scope", (scope) => {
				return scope.mapNode("definition", MagmaGenerator.attachModifiers);
			});
			return Tuple(definition, depth);
		}
		if(node.is("definition")){
			let removed = removeImplicitType(node);
			let modifiers = removed.attributes().apply("modifiers").flatMap(Attribute.asStringList);
			if(modifiers.isEmpty()||modifiers.get().isEmpty()){
				return Tuple(removed.remove("modifiers"), depth);
			}
			else
			{
				return Tuple(removed, depth);
			}
		
		}
		if(node.is("constructor")){
			return Tuple(node.retype("invocation"), depth);
		}
		if(node.is("record")){
			return Tuple(node.retype("function"), depth);
		}
		if(node.is("interface")){
			let struct = node.retype("struct").mapAttributes((attribute) => {
				return attribute.mapValue("modifiers", StringListAttribute.Factory, (list) => {
					let newList = ArrayList();
					if(list.contains("public")){
						newList.add("export");
					}
					return newList;
				});
			});
			return Tuple(struct, depth);
		}
		if(node.is("function")){
			let node1 = node.mapAttributes((attributes) => {
				return attributes.mapValue("definition", NodeAttribute.Factory, (definition) => {
					if(!definition.attributes().has("name")){
						return definition;
					}
					return definition.mapAttributes((attributes1) => {
						return attributes1.mapValue("modifiers", StringListAttribute.Factory, (list) => {
							if(list.contains("class"))return list;
							let copy = ArrayList();
							if(list.contains("public")){
								copy.add("public");
							}
							copy.add("def");
							return copy;
						});
					});
				});
			});
			return Tuple(node1, depth);
		}
		return Tuple(node, depth);
	}
}
