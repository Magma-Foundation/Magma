import magma.compile.rule.ContextRule;import magma.compile.rule.LazyRule;import magma.compile.rule.OptionalRule;import magma.compile.rule.OrRule;import magma.compile.rule.Rule;import magma.compile.rule.SymbolRule;import magma.compile.rule.TypeRule;import magma.compile.rule.split.FirstRule;import magma.compile.rule.split.LastRule;import magma.compile.rule.split.ParamSplitter;import magma.compile.rule.split.SplitMultipleRule;import magma.compile.rule.split.SplitOnceRule;import magma.compile.rule.split.Splitter;import magma.compile.rule.text.LeftRule;import magma.compile.rule.text.RightRule;import magma.compile.rule.text.StripRule;import magma.compile.rule.text.extract.ExtractNodeRule;import magma.compile.rule.text.extract.ExtractStringRule;import magma.compile.rule.text.extract.SimpleExtractStringListRule;import java.util.ArrayList;import java.util.Arrays;import java.util.List;() => {public static createRootRule : Rule => {return Lang.createBlock(createRootMemberRule());}private static createRootMemberRule : OrRule => {namespace : var=Lang.createNamespaceRule();importRule : var=Lang.createImportRule(namespace);member : var=LazyRule();statement : var=LazyRule();definition : var=JavaDefinitionHeaderFactory.createDefinitionHeaderRule();value : var=createValueRule(member, statement);initStatements(definition, statement, member, value);contents : var=LazyRule();initContentMember(member, contents, definition, statement, value);contents.setRule(OrRule(List.of(createContentRule("class", member, Lang.createTypeRule(), definition), createContentRule("record", member, Lang.createTypeRule(), definition), createContentRule("interface", member, Lang.createTypeRule(), definition))));return OrRule(List.of(TypeRule("package", LeftRule("package ", RightRule(ExtractNodeRule("internal", namespace), ";"))), importRule, contents, Lang.createBlockCommentRule()));}private static initContentMember : void => {content : var=StripRule(RightRule(ExtractNodeRule("child", Lang.createBlock(statement)), "}"));withoutThrows : var=ContextRule("No throws statement present.", StripRule(RightRule(Lang.createParamsRule(definition), ")")));thrownValues : var=SplitMultipleRule(SplitThrows(), ", ", "thrown", StripRule(Lang.createTypeRule()));withThrows : var=ContextRule("Throws statement present.", LastRule(withoutThrows, "throws ", thrownValues));maybeThrows : var=OrRule(List.of(withThrows, withoutThrows));withValue : var=ContextRule("Value present.", FirstRule(maybeThrows, "{", content));withoutValue : var=ContextRule("No value present.", RightRule(maybeThrows, ";"));maybeValue : var=OrRule(List.of(withValue, withoutValue));definitionNode : var=ExtractNodeRule("definition", TypeRule("definition", definition));methodRule : var=TypeRule("method", FirstRule(definitionNode, "(", maybeValue));contentMember.setRule(OrRule(List.of(Lang.createEmptyStatementRule(), Lang.createBlockCommentRule(), methodRule, Lang.createDeclarationRule(definition, value), Lang.createDefinitionRule(definition), contents)));}private static initStatements : void => {rules : var=List.of(Lang.createBlockCommentRule(), Lang.createCommentRule(), Lang.createKeywordRule("break"), Lang.createKeywordRule("continue"), Lang.createReturnRule(value), Lang.createConditionRule("if", value, statement), Lang.createElseRule(statement), Lang.createConditionRule("while", value, statement), Lang.createForRule(definition, value, statement, ":"), Lang.createTryRule(statement), Lang.createCatchRule(definition, statement), Lang.createThrowRule(value), Lang.createDeclarationRule(definition, value), Lang.createAssignmentRule(value), TypeRule("invocation", RightRule(Lang.createInvocationRule(value), ";")), Lang.createEmptyStatementRule(), Lang.createPostIncrementRule(value), Lang.createPostDecrementRule(value));copy : var=ArrayList(rules);copy.add(TypeRule("constructor", RightRule(createConstructorRule(value, classMember), ";")));statement.setRule(OrRule(copy));}private static createContentRule : TypeRule => {modifiers : var=Lang.createModifiersRule();block : var=ExtractNodeRule("child", Lang.createBlock(classMember));name : var=StripRule(SymbolRule(ExtractStringRule("name")));typeParams : var=Lang.createTypeParamsRule();withTypeParams : var=StripRule(FirstRule(name, "<", RightRule(typeParams, ">")));maybeTypeParams : var=OptionalRule("type-params", withTypeParams, name);params : var=Lang.createParamsRule(definition);withParams : var=FirstRule(maybeTypeParams, "(", StripRule(RightRule(params, ")")));maybeParams : var=OptionalRule("params", withParams, maybeTypeParams);withExtends : var=FirstRule(maybeParams, " extends ", StripRule(ExtractStringRule("superclass")));maybeExtends : var=OptionalRule("extends", withExtends, maybeParams);withImplements : var=FirstRule(maybeExtends, " implements ", ExtractNodeRule("interface", type));maybeImplements : var=OptionalRule("implements", withImplements, maybeExtends);withoutModifiers : var=FirstRule(maybeImplements, "{", RightRule(block, "}"));return TypeRule(keyword, FirstRule(modifiers, keyword+" ", withoutModifiers));}private static createValueRule : LazyRule => {value : var=LazyRule();parent : var=ExtractNodeRule("parent", StripRule(value));value.setRule(OrRule(List.of(Lang.createStringRule(), Lang.createCharRule(), Lang.createSymbolRule(), Lang.createNumberRule(), createLambdaRule(value, statement), createConstructorRule(value, classMember), Lang.createTernaryRule(value), Lang.createInvocationRule(value), createAccessRule(parent, Lang.createTypeRule()), Lang.createAccessRule("method-reference", "::", value), Lang.createOperatorRule("and", "&&", value), Lang.createOperatorRule("equals", "==", value), Lang.createOperatorRule("not-equals", "!=", value), Lang.createOperatorRule("add", "+", value), Lang.createOperatorRule("subtract", "-", value), Lang.createOperatorRule("greater-than-or-equals", ">=", value), Lang.createOperatorRule("greater-than", ">", value), Lang.createOperatorRule("or", "||", value), Lang.createOperatorRule("less-than", "<", value), Lang.createNotRule(value))));return value;}private static createAccessRule : TypeRule => {withoutTypeArguments : var=StripRule(SymbolRule(ExtractStringRule("child")));withTypeArguments : var=StripRule(LeftRule("<", LastRule(ExtractNodeRule("type", type), ">", withoutTypeArguments)));child : var=StripRule(OrRule(List.of(withTypeArguments, withoutTypeArguments)));return TypeRule("access", LastRule(parent, ".", child));}private static createLambdaRule : Rule => {asMultiple : var=StripRule(LeftRule("(", RightRule(SimpleExtractStringListRule("params", ","), ")")));asSingle : var=StripRule(SymbolRule(ExtractStringRule("param")));left : var=OrRule(List.of(asMultiple, asSingle));maybeValue : var=OrRule(List.of(StripRule(LeftRule("{", RightRule(Lang.createBlock(statement), "}"))), value));right : var=StripRule(ExtractNodeRule("child", maybeValue));return TypeRule("lambda", FirstRule(left, "->", right));}private static createConstructorRule : Rule => {arguments : var=OrRule(List.of(SplitMultipleRule(ParamSplitter(), ", ", "arguments", StripRule(value))));caller : var=ExtractNodeRule("caller", value);withGenerics : var=OrRule(List.of(FirstRule(caller, "<", ExtractStringRule("temp")), caller));before : var=RightRule(SplitOnceRule(withGenerics, "(", arguments, InvocationStartSearcher()), ")");child : var=OrRule(List.of(FirstRule(StripRule(before), "{", RightRule(Lang.createBlock(classMember), "}")), before));return TypeRule("constructor", StripRule(LeftRule("new ", child)));}() => {public split : List<String> => {return Arrays.asList(input.split(","));}}}