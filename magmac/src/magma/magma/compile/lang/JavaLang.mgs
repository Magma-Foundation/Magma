import magma.compile.rule.ContextRule;
import magma.compile.rule.LazyRule;
import magma.compile.rule.OptionalRule;
import magma.compile.rule.OrRule;
import magma.compile.rule.Rule;
import magma.compile.rule.SymbolRule;
import magma.compile.rule.TypeRule;
import magma.compile.rule.split.FirstRule;
import magma.compile.rule.split.LastRule;
import magma.compile.rule.split.ParamSplitter;
import magma.compile.rule.split.SplitMultipleRule;
import magma.compile.rule.split.SplitOnceRule;
import magma.compile.rule.split.Splitter;
import magma.compile.rule.text.LeftRule;
import magma.compile.rule.text.RightRule;
import magma.compile.rule.text.StripRule;
import magma.compile.rule.text.extract.ExtractNodeRule;
import magma.compile.rule.text.extract.ExtractStringRule;
import magma.compile.rule.text.extract.SimpleExtractStringListRule;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
export object JavaLang {
	public def createRootRule() => Lang.createBlock(createRootMemberRule());
	def createRootMemberRule() => {
		
		namespace : var=
		
		Lang.createNamespaceRule();
		
		importRule : var=
		
		Lang.createImportRule(namespace);
		
		member : var=
		
		LazyRule();
		
		statement : var=
		
		LazyRule();
		
		definition : var=
		
		JavaDefinitionHeaderFactory.createDefinitionHeaderRule();
		
		value : var=
		
		createValueRule(member, statement);
		initStatements(definition, statement, member, value);
		
		contents : var=
		
		LazyRule();
		initContentMember(member, contents, definition, statement, value);
		contents.setRule(OrRule(List.of(createContentRule("class", member, Lang.createTypeRule(), definition), createContentRule("record", member, Lang.createTypeRule(), definition), createContentRule("interface", member, Lang.createTypeRule(), definition))));
		return OrRule(List.of(TypeRule("package", LeftRule("package ", RightRule(ExtractNodeRule("internal", namespace), ";"))), importRule, contents, Lang.createBlockCommentRule()));
	}
	def initContentMember(contentMember : LazyRule, contents : Rule, definition : Rule, statement : Rule, value : Rule) => {
		
		content : var=
		
		StripRule(RightRule(ExtractNodeRule("child", Lang.createBlock(statement)), "}"));
		
		withoutThrows : var=
		
		ContextRule("No throws statement present.", StripRule(RightRule(Lang.createParamsRule(definition), ")")));
		
		thrownValues : var=
		
		SplitMultipleRule(SplitThrows(), ", ", "thrown", StripRule(Lang.createTypeRule()));
		
		withThrows : var=
		
		ContextRule("Throws statement present.", LastRule(withoutThrows, "throws ", thrownValues));
		
		maybeThrows : var=
		
		OrRule(List.of(withThrows, withoutThrows));
		
		withValue : var=
		
		ContextRule("Value present.", FirstRule(maybeThrows, "{", content));
		
		withoutValue : var=
		
		ContextRule("No value present.", RightRule(maybeThrows, ";"));
		
		maybeValue : var=
		
		OrRule(List.of(withValue, withoutValue));
		
		definitionNode : var=
		
		ExtractNodeRule("definition", TypeRule("definition", definition));
		
		methodRule : var=
		
		TypeRule("method", FirstRule(definitionNode, "(", maybeValue));
		contentMember.setRule(OrRule(List.of(Lang.createEmptyStatementRule(), Lang.createBlockCommentRule(), methodRule, Lang.createDeclarationRule(definition, value), Lang.createDefinitionRule(definition), contents)));
	}
	def initStatements(definition : Rule, statement : LazyRule, classMember : LazyRule, value : LazyRule) => {
		
		rules : var=
		
		List.of(Lang.createBlockCommentRule(), Lang.createCommentRule(), Lang.createKeywordRule("break"), Lang.createKeywordRule("continue"), Lang.createReturnRule(value), Lang.createConditionRule("if", value, statement), Lang.createElseRule(statement), Lang.createConditionRule("while", value, statement), Lang.createForRule(definition, value, statement, ":"), Lang.createTryRule(statement), Lang.createCatchRule(definition, statement), Lang.createThrowRule(value), Lang.createDeclarationRule(definition, value), Lang.createAssignmentRule(value), TypeRule("invocation", RightRule(Lang.createInvocationRule(value), ";")), Lang.createEmptyStatementRule(), Lang.createPostIncrementRule(value), Lang.createPostDecrementRule(value));
		
		copy : var=
		
		ArrayList(rules);
		copy.add(TypeRule("constructor", RightRule(createConstructorRule(value, classMember), ";")));
		statement.setRule(OrRule(copy));
	}
	def createContentRule(keyword : String, classMember : LazyRule, type : LazyRule, definition : Rule) => {
		
		modifiers : var=
		
		Lang.createModifiersRule();
		
		block : var=
		
		ExtractNodeRule("child", Lang.createBlock(classMember));
		
		name : var=
		
		StripRule(SymbolRule(ExtractStringRule("name")));
		
		typeParams : var=
		
		Lang.createTypeParamsRule();
		
		withTypeParams : var=
		
		StripRule(FirstRule(name, "<", RightRule(typeParams, ">")));
		
		maybeTypeParams : var=
		
		OptionalRule("type-params", withTypeParams, name);
		
		params : var=
		
		Lang.createParamsRule(definition);
		
		withParams : var=
		
		FirstRule(maybeTypeParams, "(", StripRule(RightRule(params, ")")));
		
		maybeParams : var=
		
		OptionalRule("params", withParams, maybeTypeParams);
		
		withExtends : var=
		
		FirstRule(maybeParams, " extends ", StripRule(ExtractStringRule("superclass")));
		
		maybeExtends : var=
		
		OptionalRule("extends", withExtends, maybeParams);
		
		withImplements : var=
		
		FirstRule(maybeExtends, " implements ", ExtractNodeRule("interface", type));
		
		maybeImplements : var=
		
		OptionalRule("implements", withImplements, maybeExtends);
		
		withoutModifiers : var=
		
		FirstRule(maybeImplements, "{", RightRule(block, "}"));
		return TypeRule(keyword, FirstRule(modifiers, keyword+" ", withoutModifiers));
	}
	def createValueRule(classMember : LazyRule, statement : Rule) => {
		
		value : var=
		
		LazyRule();
		
		parent : var=
		
		ExtractNodeRule("parent", StripRule(value));
		value.setRule(OrRule(List.of(Lang.createStringRule(), Lang.createCharRule(), Lang.createSymbolRule(), Lang.createNumberRule(), createLambdaRule(value, statement), createConstructorRule(value, classMember), Lang.createTernaryRule(value), Lang.createInvocationRule(value), createAccessRule(parent, Lang.createTypeRule()), Lang.createAccessRule("method-reference", "::", value), Lang.createOperatorRule("and", "&&", value), Lang.createOperatorRule("equals", "==", value), Lang.createOperatorRule("not-equals", "!=", value), Lang.createOperatorRule("add", "+", value), Lang.createOperatorRule("subtract", "-", value), Lang.createOperatorRule("greater-than-or-equals", ">=", value), Lang.createOperatorRule("less-than-or-equals", "<=", value), Lang.createOperatorRule("greater-than", ">", value), Lang.createOperatorRule("or", "||", value), Lang.createOperatorRule("less-than", "<", value), Lang.createNotRule(value))));
		return value;
	}
	def createAccessRule(parent : Rule, type : Rule) => {
		
		withoutTypeArguments : var=
		
		StripRule(SymbolRule(ExtractStringRule("child")));
		
		withTypeArguments : var=
		
		StripRule(LeftRule("<", LastRule(ExtractNodeRule("type", type), ">", withoutTypeArguments)));
		
		child : var=
		
		StripRule(OrRule(List.of(withTypeArguments, withoutTypeArguments)));
		return TypeRule("access", LastRule(parent, ".", child));
	}
	def createLambdaRule(value : Rule, statement : Rule) => {
		
		asMultiple : var=
		
		StripRule(LeftRule("(", RightRule(SimpleExtractStringListRule("params", ","), ")")));
		
		asSingle : var=
		
		StripRule(SymbolRule(ExtractStringRule("param")));
		
		left : var=
		
		OrRule(List.of(asMultiple, asSingle));
		
		maybeValue : var=
		
		OrRule(List.of(StripRule(LeftRule("{", RightRule(Lang.createBlock(statement), "}"))), value));
		
		right : var=
		
		StripRule(ExtractNodeRule("child", maybeValue));
		return TypeRule("lambda", FirstRule(left, "->", right));
	}
	def createConstructorRule(value : Rule, classMember : Rule) => {
		
		arguments : var=
		
		OrRule(List.of(SplitMultipleRule(ParamSplitter(), ", ", "arguments", StripRule(value))));
		
		caller : var=
		
		ExtractNodeRule("caller", value);
		
		withGenerics : var=
		
		OrRule(List.of(FirstRule(caller, "<", RightRule(ExtractStringRule("generics"), ">")), caller));
		
		before : var=
		
		RightRule(SplitOnceRule(withGenerics, "(", arguments, InvocationStartSearcher()), ")");
		
		child : var=
		
		OrRule(List.of(FirstRule(StripRule(before), "{", RightRule(Lang.createBlock(classMember), "}")), before));
		return TypeRule("constructor", StripRule(LeftRule("new ", child)));
	}
}
export class def JavaLang() => class def SplitThrows() => {
	public def split(input : String) => Arrays.asList(input.split(","));
	implements Splitter;
}