import magma.api.Tuple;
import magma.compile.attribute.Attribute;
import magma.compile.attribute.StringListAttribute;
import magma.compile.rule.Node;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
export class def JavaNormalizer extends Generator() => {
	def getNode(name : Optional<Attribute>, withType : Node) : Node => {
		if(name.isEmpty())return withType;
		let paramName = name.flatMap(Attribute.asString).orElseThrow();
		let param = Node("definition").withString("name", paramName);
		let definition = Node("definition").withNodeList("params", List.of(param)).withStringList("modifiers", Collections.emptyList());
		return withType.withNode("definition", definition);
	}
	def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("method-reference")){
			return Tuple(node.retype("access"), depth);
		}
		if(node.is("lambda")){
			let withType = node.retype("function");
			let name = node.attributes().apply("param-name");
			let withDefinition = getNode(name, withType);
			return Tuple(withDefinition, depth);
		}
		if(node.is("declaration")){
			let withModifiers = node.mapAttributes( (attributes) => {
				let list = attributes.apply("modifiers").flatMap(Attribute.asStringList).orElse(Collections.emptyList());
				let copy = ArrayList();
				if(list.contains("final")){
					copy.add("const");
				}
				else
				{
					copy.add("let");
				}
				return attributes.with("modifiers", StringListAttribute(copy));
			}).mapAttributes( (attributes) => {
				let type = attributes.apply("type").flatMap(Attribute.asNode);
				if(type.isEmpty())return attributes;
				let inner = type.get();
				if(inner.is("symbol")){
					let value = inner.attributes().apply("value").flatMap(Attribute.asString).orElseThrow();
					if(value.equals("var")){
						return attributes.remove("type");
					}
					else
					{
						return attributes;
					}
				
				}
				else
				{
					return attributes;
				}
			
			});
			return Tuple(withModifiers, depth);
		}
		if(node.is("method")){
			let attributes = node.attributes();
			let definition = attributes.apply("definition").flatMap(Attribute.asNode).orElseThrow();
			let params = attributes.apply("params").flatMap(Attribute.asNodeList).orElse(Collections.emptyList());
			let withParams = definition.withNodeList("params", params);
			let function = node.retype("function").remove("params").withNode("definition", withParams);
			return Tuple(function, depth);
		}
		return Tuple(node, depth);
	}
}
