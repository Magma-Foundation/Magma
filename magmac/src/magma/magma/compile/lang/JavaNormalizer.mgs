import magma.api.Tuple;
import magma.compile.attribute.Attribute;
import magma.compile.attribute.StringListAttribute;
import magma.compile.rule.Node;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
export class def JavaNormalizer extends Generator() => {
	def getNode(name : Optional<Attribute>, withType : Node) : Node => {
		if(name.isEmpty())return withType;
		paramName : var = name.flatMap(Attribute.asString).orElseThrow();
		param : var = Node("definition").withString("name", paramName);
		definition : var = Node("definition").withNodeList("params", List.of(param)).withStringList("modifiers", Collections.emptyList());
		return withType.withNode("definition", definition);
	}
	def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("method-reference")){
			return Tuple(node.retype("access"), depth);
		}
		if(node.is("lambda")){
			withType : var = node.retype("function");
			name : var = node.attributes().apply("param-name");
			withDefinition : var = getNode(name, withType);
			return Tuple(withDefinition, depth);
		}
		if(node.is("declaration")){
			withModifiers : var = node.mapAttributes( (attributes) => {
				list : var = attributes.apply("modifiers").flatMap(Attribute.asStringList).orElse(Collections.emptyList());
				copy : var = ArrayList();
				if(list.contains("final")){
					copy.add("const");
				}
				else
				{
					copy.add("let");
				}
				return attributes.with("modifiers", StringListAttribute(copy));
			}).mapAttributes( (attributes) => {
				type : var = attributes.apply("type").flatMap(Attribute.asNode);
				if(type.isEmpty())return attributes;
				inner : var = type.get();
				if(inner.is("symbol")){
					value : var = inner.attributes().apply("value").flatMap(Attribute.asString).orElseThrow();
					if(value.equals("var")){
						return attributes.remove("type");
					}
					else
					{
						return attributes;
					}
				
				}
				else
				{
					return attributes;
				}
			
			});
			return Tuple(withModifiers, depth);
		}
		if(node.is("method")){
			attributes : var = node.attributes();
			definition : var = attributes.apply("definition").flatMap(Attribute.asNode).orElseThrow();
			params : var = attributes.apply("params").flatMap(Attribute.asNodeList).orElse(Collections.emptyList());
			withParams : var = definition.withNodeList("params", params);
			function : var = node.retype("function").remove("params").withNode("definition", withParams);
			return Tuple(function, depth);
		}
		return Tuple(node, depth);
	}
}
