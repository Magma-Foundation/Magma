import magma.api.result.Err;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.CompileError;
import magma.compile.Error_;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
export class def State(locations : Set<List<String>>, frames : List<List<String>>) => {
	def State(this, locations : Set<List<String>>) : public => {
		this(locations, ArrayList());
	}
	def State(this, locations : Set<List<String>>, frames : List<List<String>>) : public => {
		this=locations;
		this=frames;
	}
	public def exit(this) : State => {
		let mut previous : var = frames.subList(0, frames.size()-1);
		return State(locations, previous);
	}
	public def enter(this) : State => {
		let mut copy : var = ArrayList(frames);
		copy.add(ArrayList());
		return State(locations, copy);
	}
	public def isDefined(this, value : String) : boolean => {
		if(isDefinedAsLocation(value))
		{
			return true;
		}
		return frames.stream().anyMatch(() => frame.contains(value));
	}
	private def isDefinedAsLocation(this, value : String) : boolean => {
		return locations.stream().filter(() => !location.isEmpty()).map(() => location.get(location.size()-1)).anyMatch(() => last.equals(value));
	}
	public def computeDepth(this) : int => {
		return frames.size();
	}
	public def define(this, name : String) : Result<State, Error_> => {
		if(frames.isEmpty())
		{
			return Err(CompileError("No frames present.", frames.toString()));
		}
		let mut framesCopy : var = ArrayList(frames);
		let mut frameCopy : var = ArrayList(framesCopy.remove(framesCopy.size()-1));
		frameCopy.add(name);
		framesCopy.add(frameCopy);
		return Ok(State(locations, framesCopy));
	}
}
