import magma.api.Tuple;
import magma.api.result.Err;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.CompileError;
import magma.compile.Error_;
import magma.compile.annotate.State;
import magma.compile.rule.Node;
import magma.compile.rule.text.StripRule;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
export class def MagmaFormatter() => {
	private static def attachFormatting(this, children : List<Node>, prefix : String, depth : int) : List<Node> => {
		let mut list : List<Node> = ArrayList();
		let mut i : int = 0;
		while(i<children.size())
		{
			let mut child : Node = children.get(i);
			if(!child.is("empty"))
			{
				if(i==0&&depth==0)
				{
					list.add(child);
				}
				else
				{
					let mut node : Node = child.withString(StripRule.DEFAULT_LEFT, prefix);
					list.add(node);
				}
			}
			i++;
		}
		return list;
	}
	protected def postVisit(this, node : Node, state : State) : Result<Tuple<Node, State>, Error_> => {
		return postVisitBlock(node).map(() => result.mapValue(() => Tuple(inner, state))).orElse(Ok(Tuple(node, state)));
	}
	private def postVisitBlock(this, node : Node) : Optional<Result<Node, Error_>> => {
		if(!node.is("block"))
		return Optional.empty();
		let mut depthString : var = node.findString("depth");
		if(depthString.isEmpty())
		{
			return Optional.of(Err(CompileError("No depth present.", node.toString())));
		}
		let mut depth : var = Integer.parseInt(depthString.get())-1;
		let mut prefix : var = "\n" + "\t".repeat(depth);
		let mut newBlock : var = node.mapNodes("children", () => attachFormatting(children, prefix, depth)).withString("after-content", "\n" + "\t".repeat(depth==0?0:depth-1));
		return Optional.of(Ok(newBlock));
	}
}
