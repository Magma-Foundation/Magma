import magma.api.Tuple;
import magma.compile.attribute.Attribute;
import magma.compile.attribute.NodeListAttribute;
import magma.compile.rule.Node;
import java.util.ArrayList;
import java.util.List;
export class def MagmaFormatter extends Generator() => {
	def getNodes(depth : int, list : List<Node>) : List<Node> => {
		let result : List<Node> = ArrayList();
		let i : int = 0;
		while(i<list.size()){
			let child : Node = list.get(i);
			let withLeft = attachLeft(depth, i, child);
			let withRight = attachRight(depth, list, i, withLeft);
			result.add(withRight);
			i++;
		}
		return result;
	}
	def attachRight(depth : int, list : List<Node>, i : int, withLeft : Node) : Node => {
		if(i==list.size()-1){
			let count = depth==0?depth:depth-1;
			return withLeft.withString("right-indent", "\n" + "\t".repeat(count));
		}
		else
		{
			return withLeft;
		}
	
	}
	def attachLeft(depth : int, i : int, child : Node) : Node => {
		if(depth!=0||i!=0){
			return child.withString("left-indent", "\n" + "\t".repeat(depth));
		}
		else
		{
			return child;
		}
	
	}
	def preVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(node.is("declaration")){
			let attributes = node.attributes();
			let oldDefinition = attributes.apply("definition:scope").flatMap(Attribute.asNode).orElseThrow();
			let oldValue = attributes.apply("value:scope").flatMap(Attribute.asNode).orElseThrow();
			let newNode = node.withNode("definition:scope", oldDefinition.withString("right-indent", " ")).withNode("value:scope", oldValue.withString("left-indent", " "));
			return Tuple(newNode, depth);
		}
		if(node.is("block"))return Tuple(node, depth+1);
		return Tuple(node, depth);
	}
	def postVisit(node : Node, depth : int) : Tuple<Node, Integer> => {
		if(!node.is("block"))return Tuple(node, depth);
		let indented = node.mapAttributes( (attributes) => attributes.mapValue("children", NodeListAttribute.Factory,  (list) => getNodes(depth, list);););
		return Tuple(indented, depth-1);
	}
}
