import magma.api.Tuple;
import magma.api.collect.List;
import magma.api.collect.stream.ExceptionalCollector;
import magma.api.collect.stream.ResultStream;
import magma.api.collect.stream.Stream;
import magma.api.collect.stream.Streams;
import magma.api.option.None;
import magma.api.option.Option;
import magma.api.option.Some;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.Error_;
import magma.compile.annotate.State;
import magma.compile.lang.Visitor;
import magma.compile.rule.Node;
import magma.java.JavaList;
export default object BlockNormalizer {
	def removeFromChildren(this : Self, children : List<Node>) => children.stream().filter(() => !child.is("package")).collect(JavaList.collecting());
	def flattenChild(this : Self, flattening : Flattening, node : Node, outerName : String) => {
		if
		(!node.is("function"))
		return Ok(flattening.withInstanceMember(node));
		
		definitionOptional : var=
		
		node.findNode("definition");
		if
		(definitionOptional.isEmpty())
		return Ok(flattening.withInstanceMember(node));
		
		definition : var=
		
		definitionOptional.orElsePanic();
		
		modifiers : var=
		
		definition.findStringList("modifiers").orElse(JavaList.empty());
		
		cleanedOptional : var=
		
		cleanup(node, outerName);
		if
		(cleanedOptional.isEmpty())
		return Ok(flattening);
		
		cleaned : var=
		
		cleanedOptional.orElsePanic();
		if
		(modifiers.contains("static"))
		{
			return Ok(flattening.withStaticMember(cleaned));
		}
		else
		{
			return Ok(flattening.withInstanceMember(cleaned));
		}
	}
	def splitIntoObject(this : Self, node : Node, flattening : Flattening, name : String, modifiers : List<String>) => {
		
		staticMembers : var=
		
		flattening.staticMembers;
		
		instanceMembers : var=
		
		flattening.instanceMembers;
		if
		(staticMembers.isEmpty())
		{
			return Streams.of(createFunction(node, instanceMembers));
		}
		else if(instanceMembers.isEmpty()){
			return Streams.of(createObject(node, modifiers, name, staticMembers));
		}
		else
		{
			
			object : var=
			
			createObject(node, modifiers, name, staticMembers);
			
			withChild : var=
			
			createFunction(node, instanceMembers);
			return Streams.of(object, withChild);
		}
	}
	def createFunction(this : Self, node : Node, instanceMembers : List<Node>) => {
		
		instanceBlock : var=
		
		node.clear("block").withNodeList("children", instanceMembers);
		return node.withNode("child", instanceBlock);
	}
	def createObject(this : Self, node : Node, oldModifiers : List<String>, name : String, staticMembers : List<Node>) => {
		
		staticBlock : var=
		
		node.clear("block").withNodeList("children", staticMembers);
		
		newModifiers : var=
		
		oldModifiers.remove("class").remove("def");
		return node.clear("object").withStringList("modifiers", newModifiers).withString("name", name).withNode("child", staticBlock);
	}
	def cleanup(this : Self, node : Node, outerName : String) => {
		if
		(!node.is("function"))
		return Some(node);
		
		definitionOptional : var=
		
		node.findNode("definition");
		if
		(definitionOptional.isEmpty())
		return Some(node);
		
		definition : var=
		
		definitionOptional.orElsePanic();
		
		nameOptional : var=
		
		definition.findString("name");
		if
		(nameOptional.isEmpty())
		return Some(node);
		if
		(nameOptional.orElsePanic().equals(outerName))
		{
			return None();
		}
		
		modifiers : var=
		
		definition.findStringList("modifiers").orElse(JavaList.empty());
		
		withNewModifiers : var=
		
		definition.withStringList("modifiers", modifiers.remove("static"));
		
		withNewDefinition : var=
		
		node.withNode("definition", withNewModifiers);
		return Some(withNewDefinition);
	}
}
export default class def BlockNormalizer() => {
	public def postVisit(this : Self, node : Node, state : State) => {
		
		childrenOptional : var=
		
		node.findNodeList("children");
		if
		(childrenOptional.isEmpty())
		return Ok(Tuple(node, state));
		return flattenChildren(childrenOptional.orElsePanic()).mapValue(() => Tuple(node.withNodeList("children", children), state));
	}
	def flattenChildren(this : Self, nodeList : List<Node>) => nodeList.stream().map(this.flattenChild).into(ResultStream.new).flatMapValue(() => value).collect(ExceptionalCollector(JavaList.collecting()));
	def flattenChild(this : Self, node : Node) => {
		if
		(!node.is("function"))
		return Ok(Streams.of(node));
		
		definitionOptional : var=
		
		node.findNode("definition");
		if
		(definitionOptional.isEmpty())
		return Ok(Streams.of(node));
		
		definition : var=
		
		definitionOptional.orElsePanic();
		
		modifiers : var=
		
		definition.findStringList("modifiers").orElse(JavaList.empty());
		
		nameOptional : var=
		
		definition.findString("name");
		if
		(nameOptional.isEmpty())
		return Ok(Streams.of(node));
		
		name : var=
		
		nameOptional.orElsePanic();
		
		childOptional : var=
		
		node.findNode("child");
		if
		(childOptional.isEmpty())
		return Ok(Streams.of(node));
		
		child : var=
		
		childOptional.orElsePanic();
		if
		(!child.is("block"))
		return Ok(Streams.of(node));
		
		oldChildren : var=
		
		child.findNodeList("children").orElse(JavaList.empty());
		if
		(hasFactory(oldChildren, name))
		{
			
			children1 : var=
			
			oldChildren.stream().map(() => cleanup(oldChild, name)).flatMap(Streams.fromOption).collect(JavaList.collecting());
			return Ok(Streams.of(createObject(node, modifiers, name, children1)));
		}
		return oldChildren.stream().foldLeftToResult(Flattening(JavaList.empty(), JavaList.empty()), () => flattenChild(flattening1, node1, name)).mapValue(() => splitIntoObject(node, flattening, name, modifiers));
	}
	def hasFactory(this : Self, children : List<Node>, outerName : String) => children.stream().anyMatch(() => {
		if
		(!child.is("function"))
		return false;
		
		definition : var=
		
		child.findNode("definition");
		if
		(definition.isEmpty())
		return false;
		
		name : var=
		
		definition.orElsePanic().findString("name");
		if
		(name.isEmpty())
		return false;
		return name.orElsePanic().equals(outerName);
	});
	public def preVisit(this : Self, node : Node, state : State) => Ok(Tuple(node.mapNodes("children", BlockNormalizer.removeFromChildren), state));
	() => {
		public def withStaticMember(this : Self, staticMember : Node) => Flattening(instanceMembers, staticMembers.addLast(staticMember));
		public def withInstanceMember(this : Self, instanceMember : Node) => Flattening(instanceMembers.addLast(instanceMember), staticMembers);
	}
	implements Visitor;
}