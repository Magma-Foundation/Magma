import magma.api.Tuple;
import magma.compile.CompileError;
import magma.compile.Error_;
import magma.compile.rule.EmptyRule;
import magma.compile.rule.LazyRule;
import magma.compile.rule.NumberRule;
import magma.compile.rule.OrRule;
import magma.compile.rule.Rule;
import magma.compile.rule.SymbolRule;
import magma.compile.rule.TypeRule;
import magma.compile.rule.split.FirstRule;
import magma.compile.rule.split.LastRule;
import magma.compile.rule.split.MembersSplitter;
import magma.compile.rule.split.ParamSplitter;
import magma.compile.rule.split.SplitMultipleRule;
import magma.compile.rule.split.SplitOnceRule;
import magma.compile.rule.text.LeftRule;
import magma.compile.rule.text.RightRule;
import magma.compile.rule.text.StripRule;
import magma.compile.rule.text.extract.ExtractNodeRule;
import magma.compile.rule.text.extract.ExtractStringListRule;
import magma.compile.rule.text.extract.ExtractStringRule;
import magma.compile.rule.text.extract.SimpleExtractStringListRule;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
export class def Lang() => {
	def createBlock(child : Rule) : Rule => {
		return TypeRule("block", SplitMultipleRule(MembersSplitter(), "", "children", StripRule(child)));
	}
	def createImportRule(namespace : TypeRule) : TypeRule => {
		return TypeRule("import", LeftRule("import ", RightRule(ExtractNodeRule("external", namespace), ";")));
	}
	def createNamespaceRule() : TypeRule => {
		return TypeRule("namespace", SimpleExtractStringListRule("namespace", "."));
	}
	def createCatchRule(definition : Rule, statement : Rule) : TypeRule => {
		declaration : var =StripRule(LeftRule("(", RightRule(definition, ")")));
		value : var =ExtractNodeRule("child", createBlock(statement));
		afterKeyword : var =FirstRule(ExtractNodeRule("condition", TypeRule("declaration", declaration)), "{", RightRule(value, "}"));
		return TypeRule("catch", LeftRule("catch ", afterKeyword));
	}
	def createTypeRule() : LazyRule => {
		type : var =LazyRule();
		children : var =SplitMultipleRule(ParamSplitter(), ", ", "children", StripRule(type));
		generic : var =TypeRule("generic", FirstRule(ExtractNodeRule("parent", type), "<", RightRule(children, ">")));
		type.setRule(OrRule(List.of(TypeRule("array", RightRule(ExtractNodeRule("child", type), "[]")), generic, TypeRule("symbol", SymbolRule(ExtractStringRule("value"))), TypeRule("access", LastRule(ExtractNodeRule("parent", type), ".", ExtractStringRule("member"))))));
		return type;
	}
	def createTryRule(statement : Rule) : TypeRule => {
		return TypeRule("try", LeftRule("try ", StripRule(LeftRule("{", RightRule(ExtractNodeRule("child", createBlock(statement)), "}")))));
	}
	def createModifiersRule() : StripRule => {
		return createModifiersRule(List.of("public", "abstract", "static", "private", "final"));
	}
	def createModifiersRule(final modifiers : List<String>) : StripRule => {
		return StripRule(ExtractStringListRule("modifiers", " "));
	}
	def createInvocationRule(value : Rule) : TypeRule => {
		arguments : var =OrRule(List.of(SplitMultipleRule(ParamSplitter(), ", ", "arguments", StripRule(value))));
		caller : var =ExtractNodeRule("caller", StripRule(value));
		return TypeRule("invocation", RightRule(InvocationStartRule(caller, arguments), ")"));
	}
	def createCommentRule() : TypeRule => {
		return TypeRule("comment", LeftRule("//", ExtractStringRule("value")));
	}
	def createIfRule(type : String, value : Rule, statement : Rule) : TypeRule => {
		child : var =ExtractNodeRule("condition", value);
		conditionParent : var =createScope("condition", StripRule(LeftRule("(", child)));
		valueWithBlock : var =LeftRule("{", RightRule(ExtractNodeRule("value", createBlock(statement)), "}"));
		valueWithoutBlock : var =ExtractNodeRule("value", statement);
		valueParent : var =createScope("value", StripRule(OrRule(List.of(valueWithBlock, valueWithoutBlock))));
		return TypeRule(type, LeftRule(type, ConditionEndRule(conditionParent, valueParent)));
	}
	public def createScope(name : String, rule : Rule) : Rule => {
		withScope : var =name+":scope";
		type : var =TypeRule(withScope, rule);
		return ExtractNodeRule(withScope, type);
	}
	def createReturnRule(value : Rule) : Rule => {
		maybeChild : var =OrRule(List.of(LeftRule(" ", ExtractNodeRule("child", StripRule(value))), EmptyRule()));
		after : var =OrRule(List.of(RightRule(maybeChild, ";"), maybeChild));
		return TypeRule("return", LeftRule("return", after));
	}
	def createForRule(definition : Rule, value : Rule, statement : Rule, delimiter : String) : Rule => {
		collection : var =StripRule(ExtractNodeRule("collection", value));
		condition : var =RightRule(LastRule(StripRule(definition), delimiter, collection), ")");
		content : var =RightRule(ExtractNodeRule("child", createBlock(statement)), "}");
		child : var =StripRule(LeftRule("(", condition));
		leftRule : var =ExtractNodeRule("condition-parent", TypeRule("condition-parent", child));
		after : var =FirstRule(leftRule, "{", content);
		return TypeRule("for", LeftRule("for", after));
	}
	def createElseRule(statement : Rule) : Rule => {
		child : var =RightRule(ExtractNodeRule("child", createBlock(statement)), "}");
		child1 : var =LeftRule("{", child);
		anElse : var =LeftRule("else", StripRule(child1));
		anElse1 : var =LeftRule("else ", ExtractNodeRule("child", statement));
		return TypeRule("else", OrRule(List.of(anElse, anElse1)));
	}
	def createAssignmentRule(value : Rule) : Rule => {
		reference : var =SymbolRule(ExtractStringRule("reference"));
		assignable : var =OrRule(List.of(StripRule(reference), LastRule(reference, ".", ExtractStringRule("member"))));
		left : var =ExtractNodeRule("assignable", TypeRule("assignable-parent", assignable));
		right : var =RightRule(ExtractNodeRule("value", StripRule(value)), ";");
		return TypeRule("assignment", FirstRule(left, "=", right));
	}
	def createDeclarationRule(definition : Rule, value : Rule) : TypeRule => {
		extractNodeRule : var =ExtractNodeRule("definition", TypeRule("definition", definition));
		left : var =createScope("definition", StripRule(extractNodeRule));
		withoutTerminator : var =ExtractNodeRule("value", StripRule(value));
		maybeTerminating : var =OrRule(List.of(RightRule(withoutTerminator, ";"), withoutTerminator));
		return TypeRule("declaration", FirstRule(left, "=", maybeTerminating));
	}
	def createParamsRule(definition : Rule) : Rule => {
		return SplitMultipleRule(ParamSplitter(), ", ", "params", StripRule(TypeRule("definition", definition)));
	}
	def createStringRule() : TypeRule => {
		return TypeRule("string", LeftRule("\"", RightRule(ExtractStringRule("value"), "\"")));
	}
	def createAccessRule(type : String, separator : String, value : Rule) : TypeRule => {
		parent : var =ExtractNodeRule("parent", StripRule(value));
		return TypeRule(type, LastRule(parent, separator, StripRule(SymbolRule(ExtractStringRule("child")))));
	}
	def createSymbolRule() : TypeRule => {
		return TypeRule("symbol", SymbolRule(ExtractStringRule("value")));
	}
	def createTernaryRule(value : LazyRule) : TypeRule => {
		return TypeRule("ternary", FirstRule(StripRule(ExtractNodeRule("condition", value)), "?", FirstRule(StripRule(ExtractNodeRule("true", value)), ":", StripRule(ExtractNodeRule("false", value)))));
	}
	def createOperatorRule(name : String, slice : String, value : Rule) : TypeRule => {
		return TypeRule(name, OperatorFinderRule(value, slice));
	}
	def createNumberRule() : TypeRule => {
		return TypeRule("number", NumberRule(ExtractStringRule("value")));
	}
	def createCharRule() : TypeRule => {
		return TypeRule("char", LeftRule("'", RightRule(ExtractStringRule("value"), "'")));
	}
	def createEmptyStatementRule() : TypeRule => {
		return TypeRule("empty", RightRule(StripRule(EmptyRule()), ";"));
	}
	def createThrowRule(value : Rule) : Rule => {
		after : var =RightRule(createScope("value", ExtractNodeRule("value", value)), ";");
		return TypeRule("throw", LeftRule("throw ", after));
	}
	def createNotRule(value : LazyRule) : TypeRule => {
		return TypeRule("not", LeftRule("!", ExtractNodeRule("child", value)));
	}
	def createDefinitionRule(definition : Rule) : TypeRule => {
		return TypeRule("definition", RightRule(definition, ";"));
	}
	def createBlockCommentRule() : TypeRule => {
		return TypeRule("block-comment", StripRule(LeftRule("/*", RightRule(ExtractStringRule("value"), "*/"))));
	}
	def createPostDecrementRule(value : LazyRule) : TypeRule => {
		return TypeRule("post-decrement", RightRule(ExtractNodeRule("value", value), "--;"));
	}
	def createPostIncrementRule(value : LazyRule) : TypeRule => {
		return TypeRule("post-increment", RightRule(ExtractNodeRule("value", value), "++;"));
	}
	def createKeywordRule(keyword : String) : TypeRule => {
		return TypeRule(keyword, LeftRule(keyword, RightRule(StripRule(EmptyRule()), ";")));
	}
	class def OperatorFinderRule extends SplitOnceRule() => {
		OperatorFinderRule(value : Rule, slice : String) : public => {
			super(StripRule(ExtractNodeRule("leftRule", value)), slice, StripRule(ExtractNodeRule("right", value)));
		}
		def computeIndex(input : String) : Optional<Integer> => {
			if(!input.contains(slice))return Optional.empty();
			queue : var =IntStream.range(0, input.length()).mapToObj( (i) => {Tuple(i, input.charAt(i));}).collect(Collectors.toCollection(LinkedList.new));
			depth : var =0;
			while(!queue.isEmpty()){
				tuple : var =queue.pop();
				i : var =tuple.left();
				maybeSlice : var =input.substring(i, Math.min(i+slice.length(), input.length()));
				if(maybeSlice.equals(slice)&&depth==0){
					return Optional.of(i);
				}
				else
				{
					c : var =maybeSlice.charAt(0);
					if(c=='\''){
						pop : var =queue.pop();
						if(pop.right()=='\\')queue.pop();
						queue.pop();
						continue
						
					;
					}
					if(c=='(')depth++;
					if(c==')')depth--;
				}
			
			}
			
			/*
            TODO: find the operator
             */
			return Optional.empty();
		}
	}
}
