import magma.api.Tuple;import magma.api.collect.stream.Streams;import magma.api.result.Ok;import magma.api.result.Result;import magma.compile.CompileParentError;import magma.compile.Error_;import magma.compile.annotate.State;import magma.compile.attribute.Attribute;import magma.compile.attribute.Attributes;import magma.compile.attribute.MapAttributes;import magma.compile.attribute.NodeAttribute;import magma.compile.attribute.NodeListAttribute;import magma.compile.rule.Node;import java.util.ArrayList;import java.util.List;() => {private final visitor : Visitor;VisitingGenerator : public => {this=visitor;}private generateAttribute : Result<Tuple<Attribute, State>, Error_> => {nodeList : var=attribute.asNodeList();if(nodeList.isPresent()){initial : var=Tuple(ArrayList(), state);return Streams.fromNativeList(nodeList.get()).foldLeftToResult(initial, this.generateThenFold).mapValue(() => tuple.mapLeft(NodeListAttribute.new));}return attribute.asNode().map(() => generate(value, state).mapValue(() => inner.mapLeft(NodeAttribute.from))).orElseGet(() => Ok(Tuple(attribute, state)));}private generateThenFold : Result<Tuple<List<Node>, State>, Error_> => {return generate(node, current.right()).mapValue(() => {newNode : var=tuple.left();newState : var=tuple.right();list : var=current.left();list.add(newNode);return Tuple(list, newState);});}public generate : Result<Tuple<Node, State>, Error_> => {return visitor.preVisit(node, depth).flatMapValue(() => {preVisited : var=preVisitedTuple.left();preVisitedAttributes : var=preVisited.attributes().streamEntries().toList();preVisitedState : var=preVisitedTuple.right();return Streams.fromNativeList(preVisitedAttributes).foldLeftToResult(Tuple(MapAttributes(), preVisitedState), this.generateAttributeWithState).flatMapValue(() => visitor.postVisit(preVisited.withAttributes(tuple.left()), tuple.right()));}).mapErr(() => CompileParentError("Failed to parse node.", node.toString(), err));}private generateAttributeWithState : Result<Tuple<Attributes, State>, Error_> => {key : var=next.left();value : var=next.right();return generateAttribute(value, current.right()).mapValue(() => Tuple(current.left().with(key, inner.left()), inner.right()));}}