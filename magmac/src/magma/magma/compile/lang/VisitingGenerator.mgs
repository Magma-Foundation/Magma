import magma.api.Tuple;
import magma.api.collect.stream.Streams;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.compile.CompileParentError;
import magma.compile.Error_;
import magma.compile.annotate.State;
import magma.compile.rule.Node;
import magma.java.JavaList;
import magma.java.JavaOptionals;
import java.util.ArrayList;
import java.util.List;
export default class def VisitingGenerator() => {
	private final visitor : Visitor;
	VisitingGenerator(visitor : Visitor) : public => this=visitor;
	private generateAttribute(key : String, node : Node, state : State) : Result<Tuple<Node, State>, Error_> => {
		
		nodeList : var=
		
		JavaOptionals.toNative(node.findNodeList(key).map(JavaList.toNative));
		if
		(nodeList.isPresent())
		{
			
			initial : var=
			
			Tuple(ArrayList(), state);
			return Streams.fromNativeList(nodeList.get()).foldLeftToResult(initial, this.generateThenFold).mapValue(() => tuple.mapLeft(() => node.withNodeList(key, JavaList.fromNative(list))));
		}
		return JavaOptionals.toNative(node.findNode(key)).map(() => generate(value, state).mapValue(() => inner.mapLeft(() => node.withNode(key, child)))).orElseGet(() => Ok(Tuple(node, state)));
	}
	private generateThenFold(current : Tuple<List<Node>, State>, node : Node) : Result<Tuple<List<Node>, State>, Error_> => return generate(node, current.right()).mapValue(() => {
		
		newNode : var=
		
		tuple.left();
		
		newState : var=
		
		tuple.right();
		
		list : var=
		
		current.left();
		list.add(newNode);
		return Tuple(list, newState);
	});
	public generate(node : Node, depth : State) : Result<Tuple<Node, State>, Error_> => return visitor.preVisit(node, depth).flatMapValue(() => {
		
		preVisitedNode : var=
		
		preVisitedTuple.left();
		
		preVisitedState : var=
		
		preVisitedTuple.right();
		return preVisitedNode.streamKeys().foldLeftToResult(Tuple(preVisitedNode, preVisitedState), () => generateAttribute(key, tuple.left(), tuple.right())).flatMapValue(() => visitor.postVisit(tuple.left(), tuple.right()));
	}).mapErr(() => CompileParentError("Failed to parse node.", node.toString(), err));
}