import magma.api.Tuple;import magma.api.result.Ok;import magma.api.result.Result;import magma.api.collect.stream.Streams;import magma.compile.CompileParentError;import magma.compile.Error_;import magma.compile.annotate.State;import magma.compile.attribute.Attribute;import magma.compile.attribute.Attributes;import magma.compile.attribute.MapAttributes;import magma.compile.attribute.NodeAttribute;import magma.compile.attribute.NodeListAttribute;import magma.compile.rule.Node;import java.util.ArrayList;import java.util.List;export class def TreeGenerator() => {private def generateAttribute(this, attribute : Attribute, state : State) : Result<Tuple<Attribute, State>, Error_> => {let mut nodeList : var = attribute.asNodeList();if(nodeList.isPresent()){let mut initial : var = Tuple(ArrayList(), state);return Streams.fromNativeList(nodeList.get()).foldRightToResult(initial, this.generateThenFold).mapValue(() => tuple.mapLeft(NodeListAttribute.new));}return attribute.asNode().map(() => generate(value, state).mapValue(() => inner.mapLeft(NodeAttribute.from))).orElseGet(() => Ok(Tuple(attribute, state)));}private def generateThenFold(this, current : Tuple<List<Node>, State>, node : Node) : Result<Tuple<List<Node>, State>, Error_> => {return generate(node, current.right()).mapValue(() => {let mut newNode : var = tuple.left();let mut newState : var = tuple.right();let mut list : var = current.left();list.add(newNode);return Tuple(list, newState);});}public def generate(this, node : Node, depth : State) : Result<Tuple<Node, State>, Error_> => {return preVisit(node, depth).flatMapValue(() => {let mut preVisited : var = preVisitedTuple.left();let mut preVisitedAttributes : var = preVisited.attributes().streamEntries().toList();let mut preVisitedState : var = preVisitedTuple.right();return Streams.fromNativeList(preVisitedAttributes).foldRightToResult(Tuple(MapAttributes(), preVisitedState), this.generateAttributeWithState).flatMapValue(() => postVisit(preVisited.withAttributes(tuple.left()), tuple.right()));}).mapErr(() => CompileParentError("Failed to parse node.", node.toString(), err));}private def generateAttributeWithState(this, current : Tuple<Attributes, State>, next : Tuple<String, Attribute>) : Result<Tuple<Attributes, State>, Error_> => {let mut key : var = next.left();let mut value : var = next.right();return generateAttribute(value, current.right()).mapValue(() => Tuple(current.left().with(key, inner.left()), inner.right()));}protected def preVisit(this, node : Node, state : State) : Result<Tuple<Node, State>, Error_> => {return Ok(Tuple(node, state));}protected def postVisit(this, node : Node, state : State) : Result<Tuple<Node, State>, Error_> => {return Ok(Tuple(node, state));}}