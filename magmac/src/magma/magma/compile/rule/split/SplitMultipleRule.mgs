import magma.api.collect.stream.Collector;
import magma.api.collect.stream.ExceptionalCollector;
import magma.api.collect.stream.JoiningCollector;
import magma.api.collect.stream.Streams;
import magma.api.result.Err;
import magma.api.result.Result;
import magma.compile.CompileError;
import magma.compile.CompileParentError;
import magma.compile.Error_;
import magma.compile.attribute.MapAttributes;
import magma.compile.attribute.NodeListAttribute;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import magma.compile.rule.result.ErrorRuleResult;
import magma.compile.rule.result.RuleResult;
import magma.compile.rule.result.UntypedRuleResult;
import magma.java.JavaList;
import magma.java.JavaOptionals;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
export default class def SplitMultipleRule() => {
	private final propertyKey : String;
	private final childRule : Rule;
	private final splitter : Splitter;
	private final delimiter : String;
	SplitMultipleRule(splitter : Splitter, delimiter : String, propertyKey : String, childRule : Rule) : public => {
		this=propertyKey;
		this=childRule;
		this=splitter;
		this=delimiter;
	}
	public toNode(input : String) : RuleResult => {
		
		split : var=
		
		splitter.split(input);
		
		members : var=
		
		ArrayList();
		for(childString : String in split){
			
			result : var=
			
			childRule.toNode(childString);
			if
			(JavaOptionals.toNative(result.findError()).isPresent())
			return result.mapErr(() => CompileParentError("Cannot process child.", childString, err));
			
			optional : var=
			
			JavaOptionals.toNative(result.tryCreate());
			if
			(optional.isEmpty())
			{
				return ErrorRuleResult(CompileError("No name present for.", childString));
			}
			members.add(optional.get());
		}
		return UntypedRuleResult(MapAttributes(Map.of(propertyKey, NodeListAttribute(members))));
	}
	private joinNodes(list : List<Node>) : Result<String, Error_> => {
		
		collector : Collector<String, Optional<String>>=
		
		JoiningCollector(delimiter);
		return Streams.fromNativeList(list).map(() => childRule.fromNode(node)).collect(ExceptionalCollector(collector)).mapValue(() => inner.orElse(""));
	}
	public fromNode(node : Node) : Result<String, Error_> => JavaOptionals.toNative(node.findNodeList(propertyKey).map(JavaList.toNative)).map(this.joinNodes).orElseGet(() => createErr(node));
	private createErr(node : Node) : Err<String, Error_> => {
		
		format : var=
		
		"Property '%s' does not exist on node.";
		
		message : var=
		
		format.formatted(propertyKey);
		return Err(CompileError(message, node.toString()));
	}
}