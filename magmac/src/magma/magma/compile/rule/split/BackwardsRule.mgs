
import magma.api.Result;
import magma.compile.CompileError;
import magma.compile.CompileParentError;
import magma.compile.Error_;
import magma.compile.MultipleError;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import magma.compile.rule.result.ErrorRuleResult;
import magma.compile.rule.result.RuleResult;
import magma.compile.rule.result.UntypedRuleResult;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
() => {
	public def toNode(input : String) : RuleResult => {
		allIndexes = findAllIndexesReverse(input);
		errors = ArrayList();
		for(index : Integer in allIndexes){
			leftSlice = input.substring(0, index);
			rightSlice = input.substring(index+slice.length());
			leftResult = leftRule.toNode(leftSlice);
			if
			(leftResult.findError().isPresent())
			{
				errors.add(wrapError(leftSlice, rightSlice, leftResult.findError().get()));
				continue
				;
			}
			rightResult = rightRule.toNode(rightSlice);
			if
			(rightResult.findError().isPresent())
			{
				errors.add(wrapError(leftSlice, rightSlice, rightResult.findError().get()));
				continue
				;
			}
			optional = leftResult.findAttributes().flatMap(() => rightResult.findAttributes().map(() => rightAttributes.merge(leftAttributes))).map(UntypedRuleResult.new);
			if
			(optional.isPresent())
			{
				return optional.get();
			}
		}
		if
		(errors.isEmpty())
		{
			return ErrorRuleResult(CompileError("No rules were present.", input));
		}
		else
		{
			return ErrorRuleResult(MultipleError(errors));
		}
	}
	private static def wrapError(leftSlice : String, rightSlice : String, error : Error_) : CompileParentError => {
		return CompileParentError("Invalid combination.", "[\"" + leftSlice + "\", \"" + rightSlice + "\"]", error);
	}
	private def findAllIndexesReverse(input : String) : List<Integer> => {
		indexes : List<Integer> = ArrayList();
		index : int = input.indexOf(slice);
		while
		(index>=0)
		{
			indexes.add(index);
			index=input.indexOf(slice, index+1);
		}
		Collections.reverse(indexes);
		return indexes;
	}
	public def fromNode(node : Node) : Result<String, Error_> => {
		return leftRule.fromNode(node).flatMapValue(() => rightRule.fromNode(node).mapValue(() => leftResult+slice+rightResult));
	}
}
