import magma.api.Result;import magma.compile.CompileError;import magma.compile.Error_;import magma.compile.MultipleError;import magma.compile.rule.Node;import magma.compile.rule.Rule;import magma.compile.rule.result.ErrorRuleResult;import magma.compile.rule.result.RuleResult;import magma.compile.rule.result.UntypedRuleResult;import java.util.ArrayList;import java.util.Collections;import java.util.List;() => {public toNode : RuleResult => {allIndexes : var=findAllIndexesReverse(input);errors : var=ArrayList();for(index : Integer in allIndexes){leftSlice : var=input.substring(0, index);rightSlice : var=input.substring(index+slice.length());leftResult : var=leftRule.toNode(leftSlice);if(leftResult.findError().isPresent()){errors.add(leftResult.findError().get());continue;}rightResult : var=rightRule.toNode(rightSlice);if(rightResult.findError().isPresent()){errors.add(rightResult.findError().get());continue;}optional : var=leftResult.findAttributes().flatMap(() => rightResult.findAttributes().map(() => rightAttributes.merge(leftAttributes))).map(UntypedRuleResult.new);if(optional.isPresent()){return optional.get();}}if(errors.isEmpty()){return ErrorRuleResult(CompileError("No rules were present.", input));}else{return ErrorRuleResult(MultipleError(errors));}}private findAllIndexesReverse : List<Integer> => {indexes : List<Integer>=ArrayList();index : int=input.indexOf(slice);while(index>=0){indexes.add(index);index=input.indexOf(slice, index+1);}Collections.reverse(indexes);return indexes;}public fromNode : Result<String, Error_> => {return leftRule.fromNode(node).flatMapValue(() => rightRule.fromNode(node).mapValue(() => leftResult+slice+rightResult));}}