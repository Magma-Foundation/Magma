
import magma.compile.attribute.Attribute;
import magma.compile.attribute.Attributes;
import magma.compile.attribute.MapAttributes;
import magma.compile.attribute.NodeAttribute;
import magma.compile.attribute.NodeListAttribute;
import magma.compile.attribute.StringAttribute;
import magma.compile.attribute.StringListAttribute;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Supplier;
() => {
	def Node() : public => {
		this(type, MapAttributes());}
	public def mapNode() : Node => {
		return mapAttributes(() => attributes.mapValue(key, NodeAttribute.Factory, nodeNodeFunction));}
	public def withString() : Node => {
		return with(key, StringAttribute(value));}
	private def with() : Node => {
		return mapAttributes(() => attributes.with(key, value));}
	public def formatWithDepth() : String => {
		return "\t".repeat(depth)+format(depth);}
	public def format() : String => {
		return type+" = "+attributes.format(depth);}
	public def toString() : String => {
		return formatWithDepth(0);}
	public def is() : boolean => {
		return this.type.equals(type);}
	public def mapAttributes() : Node => {
		return Node(type, mapper.apply(attributes));}
	public def retype() : Node => {
		return Node(type, attributes);}
	public def withAttributes() : Node => {
		return Node(type, attributes);}
	public def withNode() : Node => {
		return with(key, NodeAttribute(value));}
	public def withNodeList() : Node => {
		return with(key, NodeListAttribute(values));}
	public def withStringList() : Node => {
		return with(key, StringListAttribute(values));}
	public def remove() : Node => {
		return Node(type, attributes.remove(key));}
	public def has() : boolean => {
		return attributes.has(child);}
	public def mapNodes() : Node => {
		return mapAttributes(() => attributes.mapValue(key, NodeListAttribute.Factory, mapper));}
	public def mapOrSetNodeList() : Node => {
		if
		(has(key))
		{
			return mapAttributes(() => attributes.mapValue(key, NodeListAttribute.Factory, onPresent));}
		else
		{
			return with(key, NodeListAttribute(onEmpty.get()));}}
	public def mapOrSetStringList() : Node => {
		if
		(has(key))
		{
			return mapAttributes(() => attributes.mapValue(key, StringListAttribute.Factory, onPresent));}
		else
		{
			return with(key, StringListAttribute(onEmpty.get()));}}
	public def findNode() : Optional<Node> => {
		return attributes.apply(key).flatMap(Attribute.asNode);}
	public def findString() : Optional<String> => {
		return attributes.apply(key).flatMap(Attribute.asString);}
	public def findStringList() : Optional<List<String>> => {
		return attributes.apply(key).flatMap(Attribute.asStringList);}
	public def clear() : Node => {
		return Node(type);}}