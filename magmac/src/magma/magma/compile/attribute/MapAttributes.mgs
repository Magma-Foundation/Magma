import magma.api.Tuple;
import magma.api.collect.stream.HeadedStream;
import magma.java.NativeListHead;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
() => {
	MapAttributes() : public => {
		this(Collections.emptyMap());
	}
	public mapValue<T>(key : String, factory : Factory<T>, mapper : Function<T, T>) : Attributes => {
		if
		(!values.containsKey(key))
		return this;
		return factory.fromAttribute(values.get(key)).map(mapper).map(factory.toAttribute).map(() => with(key, inner)).orElse(this);
	}
	public with(key : String, value : Attribute) : Attributes => {
		
		copy : var=
		
		HashMap(values);
		copy.put(key, value);
		return MapAttributes(copy);
	}
	public apply(key : String) : Optional<Attribute> => {
		return values.containsKey(key)?Optional.of(values.get(key)):Optional.empty();
	}
	public merge(other : Attributes) : Attributes => {
		
		entries : var=
		
		other.streamEntries().collect(Collectors.toSet());
		
		current : Attributes=
		
		this;
		for(entry : var in entries){
			current=current.with(entry.left(), entry.right());
		}
		return current;
	}
	public streamEntries() : Stream<Tuple<String, Attribute>> => {
		return values.entrySet().stream().map(() => Tuple(entry.getKey(), entry.getValue()));
	}
	public format(depth : int) : String => {
		return values.entrySet().stream().map(() => "\n"+"\t".repeat(depth+1)+entry.getKey()+" : "+entry.getValue().format(depth+1)).sorted(Comparator.comparingInt(String.length)).collect(Collectors.joining(",", "{", "\n" + "\t".repeat(depth) + "}"));
	}
	public has(name : String) : boolean => {
		return this.values.containsKey(name);
	}
	public isEmpty() : boolean => {
		return values.isEmpty();
	}
	public streamKeys() : magma.api.collect.stream.Stream<String> => {
		return HeadedStream(NativeListHead(ArrayList(values.keySet())));
	}
}