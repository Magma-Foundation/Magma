
import magma.api.Tuple;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
() => {
	def MapAttributes() : public => {
		this(Collections.emptyMap());}
	public def mapValue() : Attributes => {
		if
		(!values.containsKey(key))
		return this;
		return factory.fromAttribute(values.get(key)).map(mapper).map(factory.toAttribute).map(() => with(key, inner)).orElse(this);}
	public def with() : Attributes => {
		
		copy : var=
		HashMap(values);
		copy.put(key, value);
		return MapAttributes(copy);}
	public def apply() : Optional<Attribute> => {
		return values.containsKey(key)?Optional.of(values.get(key)):Optional.empty();}
	public def merge() : Attributes => {
		
		entries : var=
		other.streamEntries().collect(Collectors.toSet());
		
		current : Attributes=
		this;
		for(entry : var in entries){
			current=current.with(entry.left(), entry.right());}
		return current;}
	public def streamEntries() : Stream<Tuple<String, Attribute>> => {
		return values.entrySet().stream().map(() => Tuple(entry.getKey(), entry.getValue()));}
	public def mapValues() : Attributes => {
		
		copy : var=
		HashMap();
		for(stringAttributeEntry : Map.Entry<String, Attribute> in values.entrySet()){
			copy.put(stringAttributeEntry.getKey(), mapper.apply(stringAttributeEntry.getValue()));}
		return MapAttributes(copy);}
	public def format() : String => {
		return values.entrySet().stream().map(() => "\n"+"\t".repeat(depth+1)+entry.getKey()+" : "+entry.getValue().format(depth+1)).sorted(Comparator.comparingInt(String.length)).collect(Collectors.joining(",", "{", "\n" + "\t".repeat(depth) + "}"));}
	public def remove() : Attributes => {
		
		copy : var=
		HashMap(values);
		copy.remove(key);
		return MapAttributes(copy);}
	public def has() : boolean => {
		return this.values.containsKey(name);}
	public def isEmpty() : boolean => {
		return values.isEmpty();}}