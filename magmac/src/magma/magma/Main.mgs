import magma.api.Tuple;
import magma.api.result.Err;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.api.result.Results;
import magma.api.stream.Streams;
import magma.compile.CompileException;
import magma.compile.Error_;
import magma.compile.lang.Generator;
import magma.compile.lang.JavaAnnotator;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaToMagmaGenerator;
import magma.compile.lang.MagmaAnnotator;
import magma.compile.lang.MagmaFormatter;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.State;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import magma.java.JavaOptionals;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;
export class def Main() => {
	public static final let TARGET_DIRECTORY : Path = Paths.get(".", "magmac", "src", "magma");
	public static final let SOURCE_DIRECTORY : Path = Paths.get(".", "magmac", "src", "java");
	public static final let DEBUG_DIRECTORY : Path = Paths.get(".", "magmac", "debug", "java-mgs");
	public static def main(this, args : String[]) : void => {
		try 
		{
			run();
		}
		catch (e : IOException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
		catch (e : CompileException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
	}
	private static def run(this) : void => {
		let mut sources : var = Files.walk(SOURCE_DIRECTORY).filter(() => value.toString().endsWith(".java")).filter(Files.isRegularFile).toList();
		let mut sourceTrees : var = parseSources(sources);
		let mut targetTrees : var = HashMap();
		for(entry : Map.Entry<List<String>, Node> in sourceTrees.entrySet()){
			let mut location : var = entry.getKey();
			let mut namespace : var = location.subList(0, location.size()-1);
			let mut name : var = location.get(location.size()-1);
			System.out.println("Generating target: "+String.join(".", namespace)+"."+name);
			let mut generated : var = Results.unwrap(generate(entry, sourceTrees).mapValue(Tuple.left).mapErr(() => {
				writeError(error, location);
				return CompileException("Failed to generate: "+String.join(".", location));
			}));
			let mut relativizedDebug : var = createDebug(namespace);
			writeImpl(relativizedDebug.resolve(name+".output.ast"), generated.toString());
			targetTrees.put(location, generated);
		}
		for(entry : Map.Entry<List<String>, Node> in targetTrees.entrySet()){
			let mut location : var = entry.getKey();
			let mut namespace : var = location.subList(0, location.size()-1);
			let mut name : var = location.get(location.size()-1);
			System.out.println("Writing target: "+String.join(".", namespace)+"."+name);
			let mut targetParent : var = TARGET_DIRECTORY;
			for(segment : String in namespace){
				targetParent=targetParent.resolve(segment);
			}
			if(!Files.exists(targetParent))
			createDirectory(targetParent);
			let mut target : var = targetParent.resolve(name+".mgs");
			let mut rule : Rule = MagmaLang.createRootRule();
			let mut generateResult : var = rule.fromNode(entry.getValue());
			let mut generateErrorOptional : var = JavaOptionals.toNative(generateResult.findErr());
			if(generateErrorOptional.isPresent())
			{
				let mut generateError : var = generateErrorOptional.get();
				print(generateError, 0);
				writeError(generateError, location);
			}
			writeImpl(target, JavaOptionals.toNative(generateResult.findValue()).orElseThrow(() => CompileException("Nothing was generated.")));
		}
	}
	private static def generate(this, entry : Map.Entry<List<String>, Node>, sourceTrees : Map<List<String>, Node>) : Result<Tuple<Node, State>, Error_> => {
		let mut state : var = State(sourceTrees.keySet());
		let mut list : var = List.of(JavaAnnotator(), JavaToMagmaGenerator(), MagmaAnnotator(), MagmaFormatter());
		let mut initial : var = Tuple(entry.getValue(), state);
		return Streams.fromNativeList(list).foldRightToResult(initial, Main.generateImpl);
	}
	private static def generateImpl(this, tuple : Tuple<Node, State>, generator : Generator) : Result<Tuple<Node, State>, Error_> => {
		let mut node : var = tuple.left();
		let mut state1 : var = tuple.right();
		return generator.generate(node, state1);
	}
	private static def parseSources(this, sources : List<Path>) : Map<List<String>, Node> => {
		let mut trees : var = HashMap();
		for(source : var in sources){
			let mut relativized : var = SOURCE_DIRECTORY.relativize(source.getParent());
			let mut namespace : var = computeNamespace(relativized);
			let mut name : var = computeName(source);
			let mut result : var = parseSource(source, namespace, name);
			let mut error : var = JavaOptionals.toNative(result.findErr());
			if(error.isPresent())
			{
				throw error.get();
			}
			else
			{
				let mut list : var = ArrayList(namespace);
				list.add(name);
				trees.put(list, JavaOptionals.toNative(result.findValue()).orElseThrow());
			}
		}
		return trees;
	}
	private static def parseSource(this, source : Path, namespace : List<String>, name : String) : Result<Node, CompileException> => {
		System.out.println("Parsing source: "+SOURCE_DIRECTORY.relativize(source));
		let mut location : var = ArrayList(namespace);
		location.add(name);
		let mut input : var = readImpl(source);
		return JavaLang.createRootRule().toNode(input).create().match(() => parse(root, namespace, name), () => writeError(err, location));
	}
	private static def computeName(this, source : Path) : String => {
		let mut fileName : var = source.getFileName().toString();
		let mut name : var = fileName.substring(0, fileName.indexOf('.'));
		return name;
	}
	private static def parse(this, root : Node, namespace : List<String>, name : String) : Result<Node, CompileException> => {
		try 
		{
			let mut relativizedDebug : var = createDebug(namespace);
			writeImpl(relativizedDebug.resolve(name+".input.ast"), root.toString());
			return Ok(root);
		}
		catch (e : CompileException){
			return Err(e);
		}
	}
	private static def computeNamespace(this, relativized : Path) : List<String> => {
		return IntStream.range(0, relativized.getNameCount()).mapToObj(() => relativized.getName(index).toString()).toList();
	}
	private static def createDebug(this, namespace : List<String>) : Path => {
		let mut relativizedDebug : var = DEBUG_DIRECTORY;
		for(s : String in namespace){
			relativizedDebug=relativizedDebug.resolve(s);
		}
		if(!Files.exists(relativizedDebug))
		createDirectory(relativizedDebug);
		return relativizedDebug;
	}
	private static def writeError(this, err : Error_, location : List<String>) : Err<Node, CompileException> => {
		try 
		{
			let mut result : var = print(err, 0);
			writeImpl(DEBUG_DIRECTORY.resolve("error.xml"), result);
			return Err(CompileException(String.join(".", location)));
		}
		catch (e : CompileException){
			return Err(e);
		}
	}
	private static def readImpl(this, source : Path) : String => {
		try 
		{
			return Files.readString(source);
		}
		catch (e : IOException){
			throw CompileException("Failed to read input: "+source, e);
		}
	}
	private static def createDirectory(this, targetParent : Path) : Path => {
		try 
		{
			return Files.createDirectories(targetParent);
		}
		catch (e : IOException){
			throw CompileException("Failed to make parent.", e);
		}
	}
	private static def writeImpl(this, target : Path, csq : String) : void => {
		try 
		{
			Files.writeString(target, csq);
		}
		catch (e : IOException){
			throw CompileException("Cannot write.", e);
		}
	}
	private static def print(this, error : Error_, depth : int) : String => {
		let mut context : var = formatContext(error, depth);
		let mut anyMessage : var = error.findMessage();
		anyMessage.ifPresent(() => System.err.println(" ".repeat(depth)+depth+" = "+s+" "+context));
		let mut message : var = error.findMessage().orElse("");
		let mut messageAttribute : var = message.isEmpty()?"":" message=\"" + message.replace("\"", "&quot;") + "\"";
		let mut causes : var = error.findCauses().orElse(Collections.emptyList());
		let mut escapedContext : var = error.findContext().orElse("").replace("&", "&amp;").replace("\"", "&quot;").replace("<", "&lt;").replace(">", "&gt;").replace("'", "&apos;");
		let mut formattedContext : var = "\n"+escapedContext;
		if(causes.isEmpty())
		{
			return "\n" + "\t".repeat(depth) + "<child" + messageAttribute + ">" + formattedContext + "</child>";
		}
		let mut contextAttribute : var = escapedContext.isEmpty()?"":" context=\"" + escapedContext + "\"";
		if(causes.size()==1)
		{
			return "\n" + "\t".repeat(depth) + "<parent" + messageAttribute + contextAttribute + ">" + print(causes.get(0), depth + 1) + "</parent>";
		}
		let mut list : var = causes.stream().sorted(Comparator.comparingInt(Error_.calculateDepth)).toList();
		let mut builder : var = StringBuilder();
		for(cause : var in list){
			let mut result : var = print(cause, depth+1);
			builder.append(result);
		}
		return "\n" + "\t".repeat(depth) + "<collection" + messageAttribute + contextAttribute + ">" + builder + "</collection>";
	}
	private static def formatContext(this, e : Error_, depth : int) : String => {
		let mut actualContext : var = e.findContext().orElse("");
		if(e.findCauses().isPresent())
		return actualContext;
		let mut spacing : var = " ".repeat(depth+1);
		let mut formatted : var = actualContext.replace("\n", "\n" + " ".repeat(depth==0?0:depth-1));
		return "\n" + spacing + "---\n" + spacing + formatted + "\n" + spacing + "---";
	}
}
