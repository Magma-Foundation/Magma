import magma.compile.CompileException;
import magma.compile.Error_;
import magma.compile.lang.ClassSplitter;
import magma.compile.lang.Generator;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaNormalizer;
import magma.compile.lang.MagmaFormatter;
import magma.compile.lang.MagmaGenerator;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.PackageRemover;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Optional;
export class def Main() => {
	const TARGET_DIRECTORY : Path = Paths.get(".", "magmac", "src", "magma");
	const SOURCE_DIRECTORY : Path = Paths.get(".", "magmac", "src", "java");
	const DEBUG_DIRECTORY : Path = Paths.get(".", "magmac", "debug", "java-mgs");
	public def main(args : String[]) : void => {
		try 
		{
			run();
		}
		catch (e : IOException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
		catch (e : CompileException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
	}
	def run() : void => {
		let sources = Files.walk(SOURCE_DIRECTORY).filter((value) => value.toString().endsWith(".java")).filter(Files.isRegularFile).toList();
		for(source : var in sources){
			let error = compileSource(source);
			if(error.isPresent()){
				throw error.get();
			}
		}
	}
	def compileSource(source : Path) : Optional<CompileException> => {
		let relativized = SOURCE_DIRECTORY.relativize(source.getParent());
		System.out.println("Compiling source: "+SOURCE_DIRECTORY.relativize(source));
		let targetParent = TARGET_DIRECTORY.resolve(relativized);
		let fileName = source.getFileName().toString();
		let name = fileName.substring(0, fileName.indexOf('.'));
		let target = targetParent.resolve(name+".mgs");
		let input = readImpl(source);
		let parseResult = JavaLang.createRootRule().toNode(input);
		return parseResult.create().match((root) => handle(root, targetParent, relativized, name, target), Main.getCompileException);
	}
	def getCompileException(err : Error_) : Optional<CompileException> => {
		try 
		{
			let result = print(err, 0);
			writeImpl(DEBUG_DIRECTORY.resolve("error.xml"), result);
			return Optional.of(CompileException());
		}
		catch (e : CompileException){
			return Optional.of(e);
		}
	}
	def handle(root : Node, targetParent : Path, relativized : Path, name : String, target : Path) : Optional<CompileException> => {
		try 
		{
			if(!Files.exists(targetParent))createDirectory(targetParent);
			let relativizedDebug = DEBUG_DIRECTORY.resolve(relativized);
			if(!Files.exists(relativizedDebug))createDirectory(relativizedDebug);
			writeImpl(relativizedDebug.resolve(name+".input.ast"), root.toString());
			let generated = generate(root);
			writeImpl(relativizedDebug.resolve(name+".output.ast"), generated.toString());
			let rule : Rule = MagmaLang.createRootRule();
			let generateResult = rule.fromNode(generated);
			let generateError = generateResult.findErr();
			generateError.ifPresent((error) => print(error, 0));
			writeImpl(target, generateResult.findValue().orElseThrow(() => CompileException("Nothing was generated.")));
			return Optional.empty();
		}
		catch (e : CompileException){
			return Optional.of(e);
		}
	}
	def readImpl(source : Path) : String => {
		try 
		{
			return Files.readString(source);
		}
		catch (e : IOException){
			throw CompileException("Failed to read input: "+source, e);
		}
	}
	def createDirectory(targetParent : Path) : Path => {
		try 
		{
			return Files.createDirectories(targetParent);
		}
		catch (e : IOException){
			throw CompileException("Failed to make parent.", e);
		}
	}
	def writeImpl(target : Path, csq : String) : void => {
		try 
		{
			Files.writeString(target, csq);
		}
		catch (e : IOException){
			throw CompileException("Cannot write.", e);
		}
	}
	def print(error : Error_, depth : int) : String => {
		let context = formatContext(error, depth);
		let anyMessage = error.findMessage();
		anyMessage.ifPresent((s) => System.err.println(" ".repeat(depth)+depth+" = "+s+" "+context));
		let message = error.findMessage().orElse("");
		let messageAttribute = message.isEmpty()?"":" message=\"" + message.replace("\"", "&quot;") + "\"";
		let causes = error.findCauses().orElse(Collections.emptyList());
		let escapedContext = error.findContext().orElse("").replace("&", "&amp;").replace("\"", "&quot;").replace("<", "&lt;").replace(">", "&gt;").replace("'", "&apos;");
		let formattedContext = "\n"+escapedContext;
		if(causes.isEmpty()){
			return "\n" + "\t".repeat(depth) + "<child" + messageAttribute + ">" + formattedContext + "</child>";
		}
		let contextAttribute = escapedContext.isEmpty()?"":" context=\"" + escapedContext + "\"";
		if(causes.size()==1){
			return "\n" + "\t".repeat(depth) + "<parent" + messageAttribute + contextAttribute + ">" + print(causes.get(0), depth + 1) + "</parent>";
		}
		let list = causes.stream().sorted(Comparator.comparingInt(Error_.calculateDepth)).toList();
		let builder = StringBuilder();
		for(cause : var in list){
			let result = print(cause, depth+1);
			builder.append(result);
		}
		return "\n" + "\t".repeat(depth) + "<collection" + messageAttribute + contextAttribute + ">" + builder + "</collection>";
	}
	def formatContext(e : Error_, depth : int) : String => {
		let actualContext = e.findContext().orElse("");
		if(e.findCauses().isPresent())return actualContext;
		let spacing = " ".repeat(depth+1);
		let formatted = actualContext.replace("\n", "\n" + " ".repeat(depth-1));
		return "\n" + spacing + "---\n" + spacing + formatted + "\n" + spacing + "---";
	}
	def generate(root : Node) : Node => {
		let list = Arrays.asList(PackageRemover(), ClassSplitter(), JavaNormalizer(), MagmaGenerator(), MagmaFormatter());
		let acc : Node = root;
		for(generator : Generator in list){
			acc=generator.generate(acc, -1);
		}
		return acc;
	}
}
