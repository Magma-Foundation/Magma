
import magma.compile.CompileException;
import magma.compile.Error_;
import magma.compile.lang.Generator;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaToMagmaGenerator;
import magma.compile.lang.MagmaLang;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Optional;
public class def Main() => {
	public static final TARGET_DIRECTORY : Path = Paths.get(".", "magmac", "src", "magma");
	public static final SOURCE_DIRECTORY : Path = Paths.get(".", "magmac", "src", "java");
	public static final DEBUG_DIRECTORY : Path = Paths.get(".", "magmac", "debug", "java-mgs");
	public static def main(args : String[]) : void => {
		try 
		{
			run();
		}
		catch (e : IOException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
		catch (e : CompileException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
	}
	private static def run() : void => {
		sources = Files.walk(SOURCE_DIRECTORY).filter(() => value.toString().endsWith(".java")).filter(Files.isRegularFile).toList();
		for(source : var in sources){
			error = compileSource(source);
			if
			(error.isPresent())
			{
				throw error.get();
			}
		}
	}
	private static def compileSource(source : Path) : Optional<CompileException> => {
		relativized = SOURCE_DIRECTORY.relativize(source.getParent());
		System.out.println("Compiling source: "+SOURCE_DIRECTORY.relativize(source));
		targetParent = TARGET_DIRECTORY.resolve(relativized);
		fileName = source.getFileName().toString();
		name = fileName.substring(0, fileName.indexOf('.'));
		target = targetParent.resolve(name+".mgs");
		input = readImpl(source);
		parseResult = JavaLang.createRootRule().toNode(input);
		return parseResult.create().match(() => handle(root, targetParent, relativized, name, target), Main.writeError);
	}
	private static def writeError(err : Error_) : Optional<CompileException> => {
		try 
		{
			result = print(err, 0);
			writeImpl(DEBUG_DIRECTORY.resolve("error.xml"), result);
			return Optional.of(CompileException());
		}
		catch (e : CompileException){
			return Optional.of(e);
		}
	}
	private static def handle(root : Node, targetParent : Path, relativized : Path, name : String, target : Path) : Optional<CompileException> => {
		try 
		{
			if
			(!Files.exists(targetParent))
			createDirectory(targetParent);
			relativizedDebug = DEBUG_DIRECTORY.resolve(relativized);
			if
			(!Files.exists(relativizedDebug))
			createDirectory(relativizedDebug);
			writeImpl(relativizedDebug.resolve(name+".input.ast"), root.toString());
			generated = generate(root);
			writeImpl(relativizedDebug.resolve(name+".output.ast"), generated.toString());
			rule : Rule = MagmaLang.createRootRule();
			generateResult = rule.fromNode(generated);
			generateErrorOptional = generateResult.findErr();
			if
			(generateErrorOptional.isPresent())
			{
				generateError = generateErrorOptional.get();
				print(generateError, 0);
				writeError(generateError);
			}
			writeImpl(target, generateResult.findValue().orElseThrow(() => CompileException("Nothing was generated.")));
			return Optional.empty();
		}
		catch (e : CompileException){
			return Optional.of(e);
		}
	}
	private static def readImpl(source : Path) : String => {
		try 
		{
			return Files.readString(source);
		}
		catch (e : IOException){
			throw CompileException("Failed to read input: "+source, e);
		}
	}
	private static def createDirectory(targetParent : Path) : Path => {
		try 
		{
			return Files.createDirectories(targetParent);
		}
		catch (e : IOException){
			throw CompileException("Failed to make parent.", e);
		}
	}
	private static def writeImpl(target : Path, csq : String) : void => {
		try 
		{
			Files.writeString(target, csq);
		}
		catch (e : IOException){
			throw CompileException("Cannot write.", e);
		}
	}
	private static def print(error : Error_, depth : int) : String => {
		context = formatContext(error, depth);
		anyMessage = error.findMessage();
		anyMessage.ifPresent(() => System.err.println(" ".repeat(depth)+depth+" = "+s+" "+context));
		message = error.findMessage().orElse("");
		messageAttribute = message.isEmpty()?"":" message=\"" + message.replace("\"", "&quot;") + "\"";
		causes = error.findCauses().orElse(Collections.emptyList());
		escapedContext = error.findContext().orElse("").replace("&", "&amp;").replace("\"", "&quot;").replace("<", "&lt;").replace(">", "&gt;").replace("'", "&apos;");
		formattedContext = "\n"+escapedContext;
		if
		(causes.isEmpty())
		{
			return "\n" + "\t".repeat(depth) + "<child" + messageAttribute + ">" + formattedContext + "</child>";
		}
		contextAttribute = escapedContext.isEmpty()?"":" context=\"" + escapedContext + "\"";
		if
		(causes.size()==1)
		{
			return "\n" + "\t".repeat(depth) + "<parent" + messageAttribute + contextAttribute + ">" + print(causes.get(0), depth + 1) + "</parent>";
		}
		list = causes.stream().sorted(Comparator.comparingInt(Error_.calculateDepth)).toList();
		builder = StringBuilder();
		for(cause : var in list){
			result = print(cause, depth+1);
			builder.append(result);
		}
		return "\n" + "\t".repeat(depth) + "<collection" + messageAttribute + contextAttribute + ">" + builder + "</collection>";
	}
	private static def formatContext(e : Error_, depth : int) : String => {
		actualContext = e.findContext().orElse("");
		if
		(e.findCauses().isPresent())
		return actualContext;
		spacing = " ".repeat(depth+1);
		formatted = actualContext.replace("\n", "\n" + " ".repeat(depth-1));
		return "\n" + spacing + "---\n" + spacing + formatted + "\n" + spacing + "---";
	}
	private static def generate(root : Node) : Node => {
		list = Arrays.asList(JavaToMagmaGenerator());
		acc : Node = root;
		for(generator : Generator in list){
			acc=generator.generate(acc, -1);
		}
		return acc;
	}
}
