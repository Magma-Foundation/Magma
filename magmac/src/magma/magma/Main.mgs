
import magma.api.result.Err;
import magma.api.result.Ok;
import magma.api.result.Result;
import magma.api.result.Results;
import magma.compile.CompileException;
import magma.compile.Error_;
import magma.compile.lang.JavaLang;
import magma.compile.lang.JavaToMagmaGenerator;
import magma.compile.lang.MagmaLang;
import magma.compile.lang.State;
import magma.compile.rule.Node;
import magma.compile.rule.Rule;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;
export class def Main() => {
	public static final let TARGET_DIRECTORY : Path = Paths.get(".", "magmac", "src", "magma");
	public static final let SOURCE_DIRECTORY : Path = Paths.get(".", "magmac", "src", "java");
	public static final let DEBUG_DIRECTORY : Path = Paths.get(".", "magmac", "debug", "java-mgs");
	public static def main(this, args : String[]) : void => {
		try 
		{
			run();
		}
		catch (e : IOException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
		catch (e : CompileException){
			//noinspection CallToPrintStackTrace
			e.printStackTrace();
		}
	}
	private static def run(this) : void => {
		let mut sources = Files.walk(SOURCE_DIRECTORY).filter(() => value.toString().endsWith(".java")).filter(Files.isRegularFile).toList();
		let mut sourceTrees = parseSources(sources);
		let mut targetTrees = HashMap();
		for(entry : Map.Entry<List<String>, Node> in sourceTrees.entrySet()){
			let mut location = entry.getKey();
			let mut namespace = location.subList(0, location.size()-1);
			let mut name = location.get(location.size()-1);
			System.out.println("Generating target: "+String.join(".", namespace)+"."+name);
			let mut generated = Results.unwrap(JavaToMagmaGenerator().generate(entry.getValue(), State(-1)).mapErr(() => CompileException(error.message())));
			let mut relativizedDebug = createDebug(namespace);
			writeImpl(relativizedDebug.resolve(name+".output.ast"), generated.toString());
			targetTrees.put(location, generated);
		}
		for(entry : Map.Entry<List<String>, Node> in targetTrees.entrySet()){
			let mut location = entry.getKey();
			let mut namespace = location.subList(0, location.size()-1);
			let mut name = location.get(location.size()-1);
			System.out.println("Writing target: "+String.join(".", namespace)+"."+name);
			let mut targetParent = TARGET_DIRECTORY;
			for(segment : String in namespace){
				targetParent=targetParent.resolve(segment);
			}
			if(!Files.exists(targetParent))
			createDirectory(targetParent);
			let mut target = targetParent.resolve(name+".mgs");
			let mut rule : Rule = MagmaLang.createRootRule();
			let mut generateResult = rule.fromNode(entry.getValue());
			let mut generateErrorOptional = generateResult.findErr();
			if(generateErrorOptional.isPresent())
			{
				let mut generateError = generateErrorOptional.get();
				print(generateError, 0);
				writeError(generateError);
			}
			writeImpl(target, generateResult.findValue().orElseThrow(() => CompileException("Nothing was generated.")));
		}
	}
	private static def parseSources(this, sources : List<Path>) : Map<List<String>, Node> => {
		let mut trees = HashMap();
		for(source : var in sources){
			let mut relativized = SOURCE_DIRECTORY.relativize(source.getParent());
			let mut namespace = computeNamespace(relativized);
			let mut name = computeName(source);
			let mut result = parseSource(source, namespace, name);
			let mut error = result.findErr();
			if(error.isPresent())
			{
				throw error.get();
			}
			else
			{
				let mut list = ArrayList(namespace);
				list.add(name);
				trees.put(list, result.findValue().orElseThrow());
			}
		}
		return trees;
	}
	private static def parseSource(this, source : Path, namespace : List<String>, name : String) : Result<Node, CompileException> => {
		System.out.println("Parsing source: "+SOURCE_DIRECTORY.relativize(source));
		let mut input = readImpl(source);
		let mut parseResult = JavaLang.createRootRule().toNode(input);
		return parseResult.create().match(() => parse(root, namespace, name), Main.writeError);
	}
	private static def computeName(this, source : Path) : String => {
		let mut fileName = source.getFileName().toString();
		let mut name = fileName.substring(0, fileName.indexOf('.'));
		return name;
	}
	private static def parse(this, root : Node, namespace : List<String>, name : String) : Result<Node, CompileException> => {
		try 
		{
			let mut relativizedDebug = createDebug(namespace);
			writeImpl(relativizedDebug.resolve(name+".input.ast"), root.toString());
			return Ok(root);
		}
		catch (e : CompileException){
			return Err(e);
		}
	}
	private static def computeNamespace(this, relativized : Path) : List<String> => {
		return IntStream.range(0, relativized.getNameCount()).mapToObj(() => relativized.getName(index).toString()).toList();
	}
	private static def createDebug(this, namespace : List<String>) : Path => {
		let mut relativizedDebug = DEBUG_DIRECTORY;
		for(s : String in namespace){
			relativizedDebug=relativizedDebug.resolve(s);
		}
		if(!Files.exists(relativizedDebug))
		createDirectory(relativizedDebug);
		return relativizedDebug;
	}
	private static def writeError(this, err : Error_) : Err<Node, CompileException> => {
		try 
		{
			let mut result = print(err, 0);
			writeImpl(DEBUG_DIRECTORY.resolve("error.xml"), result);
			return Err(CompileException());
		}
		catch (e : CompileException){
			return Err(e);
		}
	}
	private static def readImpl(this, source : Path) : String => {
		try 
		{
			return Files.readString(source);
		}
		catch (e : IOException){
			throw CompileException("Failed to read input: "+source, e);
		}
	}
	private static def createDirectory(this, targetParent : Path) : Path => {
		try 
		{
			return Files.createDirectories(targetParent);
		}
		catch (e : IOException){
			throw CompileException("Failed to make parent.", e);
		}
	}
	private static def writeImpl(this, target : Path, csq : String) : void => {
		try 
		{
			Files.writeString(target, csq);
		}
		catch (e : IOException){
			throw CompileException("Cannot write.", e);
		}
	}
	private static def print(this, error : Error_, depth : int) : String => {
		let mut context = formatContext(error, depth);
		let mut anyMessage = error.findMessage();
		anyMessage.ifPresent(() => System.err.println(" ".repeat(depth)+depth+" = "+s+" "+context));
		let mut message = error.findMessage().orElse("");
		let mut messageAttribute = message.isEmpty()?"":" message=\"" + message.replace("\"", "&quot;") + "\"";
		let mut causes = error.findCauses().orElse(Collections.emptyList());
		let mut escapedContext = error.findContext().orElse("").replace("&", "&amp;").replace("\"", "&quot;").replace("<", "&lt;").replace(">", "&gt;").replace("'", "&apos;");
		let mut formattedContext = "\n"+escapedContext;
		if(causes.isEmpty())
		{
			return "\n" + "\t".repeat(depth) + "<child" + messageAttribute + ">" + formattedContext + "</child>";
		}
		let mut contextAttribute = escapedContext.isEmpty()?"":" context=\"" + escapedContext + "\"";
		if(causes.size()==1)
		{
			return "\n" + "\t".repeat(depth) + "<parent" + messageAttribute + contextAttribute + ">" + print(causes.get(0), depth + 1) + "</parent>";
		}
		let mut list = causes.stream().sorted(Comparator.comparingInt(Error_.calculateDepth)).toList();
		let mut builder = StringBuilder();
		for(cause : var in list){
			let mut result = print(cause, depth+1);
			builder.append(result);
		}
		return "\n" + "\t".repeat(depth) + "<collection" + messageAttribute + contextAttribute + ">" + builder + "</collection>";
	}
	private static def formatContext(this, e : Error_, depth : int) : String => {
		let mut actualContext = e.findContext().orElse("");
		if(e.findCauses().isPresent())
		return actualContext;
		let mut spacing = " ".repeat(depth+1);
		let mut formatted = actualContext.replace("\n", "\n" + " ".repeat(depth-1));
		return "\n" + spacing + "---\n" + spacing + formatted + "\n" + spacing + "---";
	}
}
