block = {
	children : [
		package = {
			internal : namespace = {
				namespace : ["magma"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "Error_"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "ClassSplitter"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "JavaLang"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "MagmaFormatter"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "MagmaLang"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "MethodMigrator"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "Modifier"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "ModifierAttacher"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "lang", "RootTypeRemover"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "rule", "Node"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["magma", "compile", "rule", "Rule"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["java", "io", "IOException"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["java", "nio", "file", "Files"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["java", "nio", "file", "Paths"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["java", "util", "Arrays"]
			}
		},
		import = {
			external : namespace = {
				namespace : ["java", "util", "Collections"]
			}
		},
		class = {
			name : "Main",
			modifiers : ["public"],
			right : "
    public static final String CLASS_KEYWORD_WITH_SPACE = "class ";

    public static void main(String[] args) {
        try {
            var source = Paths.get(".", "magmac", "src", "magma", "Main.java");
            var input = Files.readString(source);
            var target = source.resolveSibling("Main.mgs");

            var parseResult = JavaLang.createRootRule().toNode(input);
            var parseError = parseResult.findError();
            parseError.ifPresent(error -> print(error, 0));

            var root = parseResult.create().orElseThrow();

            Files.writeString(source.resolveSibling("Main.input.ast"), root.toString());
            var generated = generate(root);
            Files.writeString(source.resolveSibling("Main.output.ast"), generated.toString());

            Rule rule = MagmaLang.createRootRule();
            var generateResult = rule.fromNode(generated);
            var generateError = generateResult.findErr();
            generateError.ifPresent(error -> print(error, 0));

            Files.writeString(target, generateResult.findValue().orElseThrow());
        } catch (IOException e) {
            //noinspection CallToPrintStackTrace
            e.printStackTrace();
        }
    }

    private static void print(Error_ e, int depth) {
        var actualContext = e.findContext().orElse("");
        var index = actualContext.indexOf('\n');
        var context = index == -1 ? actualContext : actualContext.substring(0, index);

        var message = e.findMessage();
        message.ifPresent(s -> System.err.println("\t".repeat(depth) + depth + " = " + s + " " + context));

        var causes = e.findCauses().orElse(Collections.emptyList());
        if (causes.isEmpty()) {
            return;
        }
        if (causes.size() > 1) {
            for (Error_ cause : causes) {
                print(cause, depth);
            }
        } else {
            print(causes.get(0), depth + 1);
        }
    }

    private static Node generate(Node root) {
        var list = Arrays.asList(
                new RootTypeRemover("package"),
                new RootTypeRemover("whitespace"),
                new MethodMigrator(),
                new ModifierAttacher(),
                new ClassSplitter(),
                new MagmaFormatter()
        );

        Node acc = root;
        for (Modifier modifier : list) {
            acc = modifier.generate(acc);
        }
        return acc;
    }
"
		},
		any = {
			value : ""
		}]
}