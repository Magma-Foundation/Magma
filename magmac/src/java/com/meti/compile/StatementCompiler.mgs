import { Err } from com.meti.result;
import { Ok } from com.meti.result;
import { Result } from com.meti.result;
import { Optional } from java.util;
import { compileInvocation } from com.meti.compile.ValueCompiler;
export class def StatementCompiler(input : String, indent : I32) => {
	def compile(): String => {
		let stripped = input.strip();
		return compileTry(stripped, indent).or(() => compileCatch(stripped, indent)).or(() => compileThrow(stripped, indent)).or(() => compileFor(stripped, indent)).or(() => compileReturn(stripped, indent)).or(() => compileIf(stripped, indent)).or(() => compileWhile(stripped, indent)).or(() => compileElse(stripped, indent)).or(() => compileAssignment(stripped, indent)).or(() => DeclarationCompiler(stripped, indent).compile()).or(() => compileInvocation(stripped, indent)).or(() => compileSuffixOperator(stripped)).or(() => compileComment(stripped)).orElseGet(() => Err(CompileException("Unknown statement: " + stripped))).mapErr(() => CompileException("Failed to compile statement: " + stripped, err)).$();
	}
	private def compileComment(stripped : String): Optional<? extends Result<String, CompileException>> => {
		if (stripped.startsWith("/*") && stripped.endsWith("*/")) {
			return Optional.of(Ok(stripped));
		}
		try {
			return Optional.empty();
		}
	}
	private def compileSuffixOperator(stripped : String): Optional<? extends Result<String, CompileException>> => {
		if (stripped.endsWith("++") && stripped.endsWith("--")) 		return Optional.empty();
		try {
			let value = stripped.substring(0, stripped.length() - 2);
			let result = ValueCompiler(value, 0).compileRequired();
			return Optional.of(Ok(result));
		}
		catch (e : CompileException) {
			return Optional.of(Err(CompileException("Failed to compile suffix operator: " + stripped, e)));
		}
	}
	private def compileAssignment(stripped : String, indent : I32): Optional<? extends Result<String, CompileException>> => {
		let separator = stripped.indexOf('=');
		if (separator != -1) {
			let left = stripped.substring(0, separator).strip();
			if (Strings.isAssignable(left)) {
				return Optional.empty();
			}
			let right = stripped.substring(separator + 1).strip();
			try {
				return Optional.of(Ok("\t".repeat(indent) + left + " = " + new ValueCompiler(right, 0).compileRequired() + ";\n"));
			}
			catch (e : CompileException) {
				return Optional.of(Err(e));
			}
		}
		return Optional.empty();
	}
	private def compileReturn(stripped : String, indent : I32): Optional<? extends Result<String, CompileException>> => {
		if (stripped.startsWith("return ")) {
			try {
				let valueString = stripped.substring("return ".length()).strip();
				let outputValueString;
				if (valueString.isEmpty()) {
					outputValueString = "";
				}
				try {
			let compiledValue = ValueCompiler(valueString, 0).compileRequired();
			outputValueString = " " + compiledValue;
		}
				return Optional.of(Ok("\t".repeat(indent) + "return" + outputValueString + ";\n"));
			}
			catch (e : CompileException) {
				return Optional.of(Err(CompileException("Failed to compile return statement: " + stripped, e)));
			}
		}
		try {
			return Optional.empty();
		}
	}
	private def compileFor(stripped : String, indent : I32): Optional<? extends Result<String, CompileException>> => {
		if (stripped.startsWith("for")) 		return Optional.empty();
		let conditionStart = stripped.indexOf('(');
		if (conditionStart == -1) {
			return Optional.of(Err(CompileException("No starting parentheses in for: " + stripped)));
		}
		let conditionEnd = findIfEnd(stripped, conditionStart);
		if (conditionEnd == -1) {
			return Optional.of(Err(CompileException("No ending parentheses in for: " + stripped)));
		}
		let condition = stripped.substring(conditionStart + 1, conditionEnd).strip();
		let result;
		try {
			let separator = condition.lastIndexOf(':');
			let compiledBlock;
			let conditionString;
			if (separator == -1) {
				let first = condition.indexOf(';');
				if (first == -1) 				return Optional.empty();
				let second = condition.indexOf(';', first + 1);
				if (second == -1) 				return Optional.empty();
				let initialString = condition.substring(0, first).strip();
				let terminatingString = condition.substring(first + 1, second).strip();
				let incrementString = condition.substring(second + 1).strip();
				let initial = DeclarationCompiler(initialString, 0).compile().orElseThrow(() => CompileException("Invalid initial assignment: " + initialString));
				let terminating = ValueCompiler(terminatingString, 0).compileRequired();
				let increment = StatementCompiler(incrementString, 0).compile();
				compiledBlock = compileBlock(stripped, indent, 0);
				conditionString = initial + ";" + terminating + increment;
			}
			try {
			let initialString = condition.substring(0, separator);
			let initial = DeclarationCompiler(initialString, 0).compile().orElseThrow(() => CompileException("Invalid initial assignment: " + initialString)).$();
			let container = condition.substring(separator + 1);
			compiledBlock = compileBlock(stripped, indent, 0);
			conditionString = initial + " : " + container;
		}
			result = Ok("\t".repeat(this.indent) + "for (" + conditionString + ") " + compiledBlock);
		}
		catch (e : CompileException) {
			result = Err(e);
		}
		return Optional.of(result);
	}
	private def compileThrow(stripped : String, indent : I32): Optional<? extends Result<String, CompileException>> => {
		if (stripped.startsWith("throw ")) 		return Optional.empty();
		let valueString = stripped.substring("throw ".length());
		let result;
		try {
			let compiledValue = ValueCompiler(valueString, 0).compileRequired();
			result = Ok("\t".repeat(indent) + "throw " + compiledValue + ";\n");
		}
		catch (e : CompileException) {
			result = Err(e);
		}
		return Optional.of(result);
	}
	private def compileWhile(stripped : String, indent : I32): Optional<? extends Result<String, CompileException>> => {
		if (stripped.startsWith("while")) 		return Optional.empty();
		let conditionStart = stripped.indexOf('(');
		if (conditionStart == -1) 		return Optional.empty();
		let conditionEnd = findIfEnd(stripped, conditionStart);
		if (conditionEnd == -1) 		return Optional.empty();
		let result;
		try {
			let condition = stripped.substring(conditionStart + 1, conditionEnd).strip();
			let compiledCondition = ValueCompiler(condition, 0).compileRequired();
			let compiledValue;
			if (stripped.contains("{") && stripped.endsWith("}")) {
				compiledValue = compileBlock(stripped, indent, 0);
			}
			try {
			let valueString = stripped.substring(conditionEnd + 1).strip();
			compiledValue = StatementCompiler(valueString, 0).compile();
		}
			result = Ok("\t".repeat(indent) + "while (" + compiledCondition + ") " + compiledValue);
		}
		catch (e : CompileException) {
			result = Err(e);
		}
		return Optional.of(result);
	}
	private def compileIf(stripped : String, indent : I32): Optional<? extends Result<String, CompileException>> => {
		if (stripped.startsWith("if")) 		return Optional.empty();
		let conditionStart = stripped.indexOf('(');
		if (conditionStart == -1) 		return Optional.empty();
		let conditionEnd = findIfEnd(stripped, conditionStart);
		if (conditionEnd == -1) 		return Optional.empty();
		let result;
		try {
			let condition = stripped.substring(conditionStart + 1, conditionEnd).strip();
			let compiledCondition = ValueCompiler(condition, 0).compileRequired();
			let compiledValue;
			if (stripped.contains("{") && stripped.endsWith("}")) {
				compiledValue = compileBlock(stripped, indent, conditionEnd);
			}
			try {
			let valueString = stripped.substring(conditionEnd + 1).strip();
			compiledValue = StatementCompiler(valueString, indent).compile();
		}
			result = Ok("\t".repeat(indent) + "if (" + compiledCondition + ") " + compiledValue);
		}
		catch (e : CompileException) {
			result = Err(e);
		}
		return Optional.of(result);
	}
	private def compileCatch(stripped : String, indent : I32): Optional<? extends Result<String, CompileException>> => {
		if (stripped.startsWith("catch")) 		return Optional.empty();
		let typeStart = stripped.indexOf('(');
		if (typeStart == -1) 		return Optional.empty();
		let typeEnd = stripped.indexOf(')');
		if (typeEnd == -1) 		return Optional.empty();
		let type = stripped.substring(typeStart + 1, typeEnd).strip();
		let separator = type.lastIndexOf(' ');
		let catchType = type.substring(0, separator);
		let catchName = type.substring(separator + 1);
		let result;
		try {
			let compiledBlock = compileBlock(stripped, indent, 0);
			result = Ok("\t".repeat(indent) + "catch (" + catchName + " : " + catchType + ") " + compiledBlock);
		}
		catch (e : CompileException) {
			result = Err(e);
		}
		return Optional.of(result);
	}
}
export object StatementCompiler {
	private def compileTry(stripped : String, indent : I32): Optional<Result<String, CompileException>> => {
		if (stripped.startsWith("try ")) 		return Optional.empty();
		return Optional.of(Ok("\t".repeat(indent) + "try " + compileBlock(stripped, indent, 0)));
	}
	private def compileElse(stripped : String, indent : I32): Optional<Result<String, CompileException>> => {
		if (stripped.startsWith("else ")) 		return Optional.empty();
		try {
			let body;
			if (stripped.contains("{") && stripped.endsWith("}")) {
				body = compileBlock(stripped, 2, 0);
			}
			try {
			let value = stripped.substring("else ".length());
			body = StatementCompiler(value, 0).compile();
		}
			return Optional.of(Ok("\t".repeat(indent) + "try " + body));
		}
		catch (e : CompileException) {
			return Optional.of(Err(e));
		}
	}
	private def compileBlock(stripped : String, indent : I32, blockStart : I32): String => {
		let contentStart = stripped.indexOf('{', blockStart);
		if (contentStart == -1) {
			throw CompileException("Not a block: " + stripped);
		}
		let contentEnd = stripped.lastIndexOf('}');
		if (contentEnd == -1) {
			throw CompileException("Not a block: " + stripped);
		}
		let after = stripped.substring(contentStart + 1, contentEnd);
		let inputStatements = Strings.splitMembers(after);
		let output = StringBuilder();
		for (let inputStatement :  inputStatements) {
			if (inputStatement.isBlank()) 			let continue;
			try {
				let compiled = StatementCompiler(inputStatement, indent + 1).compile();
				output.append(compiled);
			}
			catch (e : CompileException) {
				throw CompileException("Failed to compile block: " + stripped, e);
			}
		}
		return "{\n" + output + "\t".repeat(indent) + "}\n";
	}
	private def findIfEnd(stripped : String, paramStart : I32): I32 => {
		let conditionEnd = -1;
		let depth = 0;
		let index = paramStart;
		let queue = Strings.toQueue(stripped.substring(paramStart + 1));
		while (queue.isEmpty()) {
			let c = queue.pop();
index			if (c == '\'') {
				let escaped = queue.pop();
index				if (escaped == '\\') {
					queue.pop();
index				}
				queue.pop();
index				let continue;
			}
			if (c == '\"') {
				while (queue.isEmpty()) {
					let next = queue.pop();
index					if (next == '\"') {
						let break;
					}
				}
				let continue;
			}
			if (c == ')' && depth == 0) {
				conditionEnd = index;
				let break;
			}
			try {
			if (c == '(') depth			if (c == ')') depth		}
		}
		return conditionEnd;
	}
}