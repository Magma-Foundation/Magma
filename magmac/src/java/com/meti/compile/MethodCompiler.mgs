import { Err } from com.meti.result;
import { Ok } from com.meti.result;
import { Result } from com.meti.result;
import { Collections } from java.util;
import { List } from java.util;
import { Optional } from java.util;
import { renderDefinedFunction } from com.meti.compile.MagmaLang;
import { $Result } from com.meti.result.Results;
export class def MethodCompiler(input : String) => {
	def compile(): Optional<Result<ClassMemberResult, CompileException>> => {
		let stripped = input().strip();
		let paramStart = stripped.indexOf('(');
		if (paramStart == -1) 		return Optional.empty();
		let paramEnd = stripped.indexOf(')');
		if (paramEnd == -1) 		return Optional.empty();
		let paramString = stripped.substring(paramStart + 1, Optional[Ok[value=paramEnd]]);
		let renderedParams;
		try {
			renderedParams = ParamsCompiler(paramString).compile();
		}
		catch (e : CompileException) {
		return Optional.of(Err(CompileException("Failed to compile parameters: " + paramString, Optional[Ok[value=e]])));
		}
		let before = stripped.substring(0, Optional[Ok[value=paramStart]]).strip();
		let separator = before.lastIndexOf(' ');
		let modifiersAndTypeString = before.substring(0, Optional[Ok[value=separator]]).strip();
		let name = before.substring(separator + 1).strip();
		let modifiersAndType = Strings.splitTypeString(modifiersAndTypeString);
		if (modifiersAndType.isEmpty()) 		return Optional.empty();
		let modifiers = modifiersAndType.subList(0, Optional[Ok[value=modifiersAndType.size() - 1]]);
		let inputType = modifiersAndType.get(modifiersAndType.size() - 1);
		let modifierString = Ok[value=modifiers.contains("private")] ? Ok[value="private "] : Ok[value=""];
		let contentStart = stripped.indexOf("{");
		let contentEnd = stripped.lastIndexOf('}');
		let finalRenderedParams = renderedParams;
		if (contentStart != -1 && contentEnd != -1) {
			let content = stripped.substring(contentStart + 1, Optional[Ok[value=contentEnd]]);
			let inputContent = Strings.splitMembers(content);
		return Optional.of($Result(() => 		let outputType = TypeCompiler(inputType).compile().$();
		let outputContent = compileMethodMembers(inputContent).$();
		let rendered = renderDefinedFunction(1, Optional[Ok[value=modifierString]], Optional[Ok[value=name]], Optional[Ok[value=finalRenderedParams]], Optional[Ok[value=": " + outputType]], Optional[Ok[value="{\n" + outputContent + "\t}"]]);
		return Ok[value=modifiers.contains("static")] ? Ok[value=ClassMemberResult(Collections.emptyList(), Optional[Ok[value=Collections.singletonList(rendered)]])] : Ok[value=ClassMemberResult(Collections.singletonList(rendered), Optional[Ok[value=Collections.emptyList()]])];

));
		}
		try {
		return Optional.of($Result(() => 		let outputType = TypeCompiler(inputType).compile().$();
		let rendered = renderDefinedFunction(1, Optional[Ok[value=modifierString]], Optional[Ok[value=name]], Optional[Ok[value=finalRenderedParams]], Optional[Ok[value=": " + outputType]], Optional[Ok[value=";"]]);
		return Ok[value=modifiers.contains("static")] ? Ok[value=ClassMemberResult(Collections.emptyList(), Optional[Ok[value=Collections.singletonList(rendered)]])] : Ok[value=ClassMemberResult(Collections.singletonList(rendered), Optional[Ok[value=Collections.emptyList()]])];

));
		}
		try {
		return Optional.empty();
		}
	}
}
export object MethodCompiler {
	def compileMethodMembers(inputContent : List<String>): Result<String, CompileException> => {
		let outputContent = StringBuilder();
		for (Ok[value=let inputMember] :  inputContent) {
			if (inputMember.isBlank()) let continue		try {
			outputContent.append(StatementCompiler(inputMember, Optional[Ok[value=2]]).compile());
		}
		catch (e : CompileException) {
		return Err(e);
		}
		}
		return Ok(outputContent.toString());
	}
}