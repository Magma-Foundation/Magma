import { Err } from com.meti.result;
import { Ok } from com.meti.result;
import { Result } from com.meti.result;
import { Collections } from java.util;
import { List } from java.util;
import { Optional } from java.util;
import { renderDefinedFunction } from com.meti.compile.MagmaLang;
import { $Result } from com.meti.result.Results;
export class def MethodCompiler(input : String) => {
	def compile(): Optional<Result<ClassMemberResult, CompileException>> => {
		let stripped = input().strip();
		let paramStart = stripped.indexOf('(');
		if (paramStart == -1) return Optional.empty();
		let paramEnd = stripped.indexOf(')');
		if (paramEnd == -1) return Optional.empty();
		let paramString = stripped.substring(paramStart + 1, paramEnd);
		let renderedParams;
		try {
			renderedParams = ParamsCompiler(paramString).compile();
		}
		catch (e : CompileException) {
			return Optional.of(Err(CompileException("Failed to compile parameters: " + paramString, e)));
		}
		let before = stripped.substring(0, paramStart).strip();
		let separator = before.lastIndexOf(' ');
		let modifiersAndTypeString = before.substring(0, separator).strip();
		let name = before.substring(separator + 1).strip();
		let modifiersAndType = Strings.splitTypeString(modifiersAndTypeString);
		if (modifiersAndType.isEmpty()) return Optional.empty();
		let modifiers = modifiersAndType.subList(0, modifiersAndType.size() - 1);
		let inputType = modifiersAndType.get(modifiersAndType.size() - 1);
		let modifierString = modifiers.contains("private") ? "private " : "";
		let contentStart = stripped.indexOf("{");
		let contentEnd = stripped.lastIndexOf('}');
		let finalRenderedParams = renderedParams;
		if (contentStart != -1 && contentEnd != -1) {
			let content = stripped.substring(contentStart + 1, contentEnd);
			let inputContent = Strings.splitMembers(content);
			return Optional.of($Result(() => {
let outputType = TypeCompiler(inputType).compile().$()let outputContent = compileMethodMembers(inputContent, 2).$()let rendered = renderDefinedFunction(1, modifierString, name, finalRenderedParams, ": " + outputType, "{\n" + outputContent + "\t}")return modifiers.contains("static") ? ClassMemberResult(Collections.emptyList(), Collections.singletonList(rendered)) : ClassMemberResult(Collections.singletonList(rendered), Collections.emptyList());
}));
		}
		try {
			return Optional.of($Result(() => {
let outputType = TypeCompiler(inputType).compile().$()let rendered = MagmaLang.renderFunction(1, modifierString + "def ", name, finalRenderedParams, ": " + outputType, ";")return modifiers.contains("static") ? ClassMemberResult(Collections.emptyList(), Collections.singletonList(rendered)) : ClassMemberResult(Collections.singletonList(rendered), Collections.emptyList());
}));
		}
		try {
			return Optional.empty();
		}
	}
}
export object MethodCompiler {
	def compileMethodMembers(inputContent : List<String>, indent : I32): Result<String, CompileException> => {
		let outputContent = StringBuilder();
		for (let inputMember :  inputContent) {
			if (inputMember.isBlank()) let continue		try {
			outputContent.append(			StatementCompiler(inputMember, indent).compile();
);
		}
		catch (e : CompileException) {
			return Err(e);
		}
		}
		return Ok(outputContent.toString());
	}
}